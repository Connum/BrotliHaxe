// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace encode {
	public class Block_splitter : global::haxe.lang.HxObject {
		
		static Block_splitter() {
			unchecked {
				global::encode.Block_splitter.kMaxLiteralHistograms = 100;
				global::encode.Block_splitter.kMaxCommandHistograms = 50;
				global::encode.Block_splitter.kLiteralBlockSwitchCost = 28.1;
				global::encode.Block_splitter.kCommandBlockSwitchCost = 13.5;
				global::encode.Block_splitter.kDistanceBlockSwitchCost = 14.6;
				global::encode.Block_splitter.kLiteralStrideLength = 70;
				global::encode.Block_splitter.kCommandStrideLength = 40;
				global::encode.Block_splitter.kSymbolsPerLiteralHistogram = 544;
				global::encode.Block_splitter.kSymbolsPerCommandHistogram = 530;
				global::encode.Block_splitter.kSymbolsPerDistanceHistogram = 544;
				global::encode.Block_splitter.kMinLengthForBlockSplitting = 128;
				global::encode.Block_splitter.kIterMulForRefining = 2;
				global::encode.Block_splitter.kMinItersForRefining = 100;
			}
		}
		
		
		public Block_splitter(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Block_splitter() {
			global::encode.Block_splitter.__hx_ctor_encode_Block_splitter(this);
		}
		
		
		public static void __hx_ctor_encode_Block_splitter(global::encode.Block_splitter __hx_this) {
		}
		
		
		public static int kMaxLiteralHistograms;
		
		public static int kMaxCommandHistograms;
		
		public static double kLiteralBlockSwitchCost;
		
		public static double kCommandBlockSwitchCost;
		
		public static double kDistanceBlockSwitchCost;
		
		public static int kLiteralStrideLength;
		
		public static int kCommandStrideLength;
		
		public static int kSymbolsPerLiteralHistogram;
		
		public static int kSymbolsPerCommandHistogram;
		
		public static int kSymbolsPerDistanceHistogram;
		
		public static int kMinLengthForBlockSplitting;
		
		public static int kIterMulForRefining;
		
		public static int kMinItersForRefining;
		
		public static void CopyLiteralsToByteArray(global::Array<object> cmds, int num_commands, uint[] data, int data_off, global::Array<uint> literals) {
			int total_length = 0;
			{
				int _g1 = 0;
				while (( _g1 < num_commands )) {
					total_length += ((global::encode.command.Command) (cmds[_g1++]) ).insert_len_;
				}
				
			}
			
			if (( total_length == 0 )) {
				return;
			}
			
			while (( literals.length > total_length )) {
				literals.pop();
			}
			
			int pos = 0;
			int from_pos = 0;
			int i = 0;
			while (( ( i < num_commands ) && ( pos < total_length ) )) {
				global::DefaultFunctions.memcpyArrayVector(literals, pos, data, ( data_off + from_pos ), ((global::encode.command.Command) (cmds[i]) ).insert_len_);
				pos += ((global::encode.command.Command) (cmds[i]) ).insert_len_;
				from_pos += ( ((global::encode.command.Command) (cmds[i]) ).insert_len_ + ((global::encode.command.Command) (cmds[i]) ).copy_len_ );
				 ++ i;
			}
			
		}
		
		
		public static void CopyCommandsToByteArray(global::Array<object> cmds, int num_commands, global::Array<uint> insert_and_copy_codes, global::Array<uint> distance_prefixes) {
			unchecked {
				int _g1 = 0;
				while (( _g1 < num_commands )) {
					global::encode.command.Command cmd = ((global::encode.command.Command) (cmds[_g1++]) );
					insert_and_copy_codes.push(cmd.cmd_prefix_[0]);
					if (( ( cmd.copy_len_ > 0 ) && ((bool) (( cmd.cmd_prefix_[0] >= 128 )) ) )) {
						distance_prefixes.push(cmd.dist_prefix_[0]);
					}
					
				}
				
			}
		}
		
		
		public static uint MyRand(global::Array<uint> seed) {
			unchecked {
				seed[0] = ((uint) (( seed[0] * 16807 )) );
				seed[0] = ((uint) (((uint) (( ((uint) (seed[0]) ) >> 0 )) )) );
				if (((bool) (( seed[0] == 0 )) )) {
					seed[0] = ((uint) (1) );
				}
				
				return seed[0];
			}
		}
		
		
		public static void InitialEntropyCodes(int HistogramTypeInt, global::Array<uint> data, int length, int literals_per_histogram, int max_histograms, int stride, global::Array<object> vec) {
			unchecked {
				int total_histograms = ( ( length / literals_per_histogram ) + 1 );
				if (( total_histograms > max_histograms )) {
					total_histograms = max_histograms;
				}
				
				int seed_0 = 7;
				int block_length = ( length / total_histograms );
				{
					int _g1 = 0;
					int _g = total_histograms;
					while (( _g1 < _g )) {
						int i = _g1++;
						int pos = ( ( length * i ) / total_histograms );
						if (( i != 0 )) {
							seed_0 = ((uint) (( seed_0 * 16807 )) );
							seed_0 = ((uint) (((uint) (( ((uint) (seed_0) ) >> 0 )) )) );
							if (((bool) (( seed_0 == 0 )) )) {
								seed_0 = ((uint) (1) );
							}
							
							pos = ((int) (((uint) (( ((uint) (( seed_0 % block_length )) ) + pos )) )) );
						}
						
						if (( ( pos + stride ) >= length )) {
							pos = ( ( length - stride ) - 1 );
						}
						
						global::encode.histogram.Histogram histo = new global::encode.histogram.Histogram(((int) (HistogramTypeInt) ));
						histo.Add2(data, pos, stride);
						vec.push(histo);
					}
					
				}
				
			}
		}
		
		
		public static void RandomSample(global::Array<uint> seed, global::Array<uint> data, int length, int stride, global::encode.histogram.Histogram sample) {
			unchecked {
				int pos = 0;
				if (( stride >= length )) {
					pos = 0;
					stride = length;
				}
				else {
					seed[0] = ((uint) (( seed[0] * 16807 )) );
					seed[0] = ((uint) (((uint) (( ((uint) (seed[0]) ) >> 0 )) )) );
					if (((bool) (( seed[0] == 0 )) )) {
						seed[0] = ((uint) (1) );
					}
					
					pos = ((int) (((uint) (( seed[0] % (( ( length - stride ) + 1 )) )) )) );
				}
				
				sample.Add2(data, pos, stride);
			}
		}
		
		
		public static void RefineEntropyCodes(int HistogramTypeInt, global::Array<uint> data, int length, int stride, global::Array<object> vec) {
			unchecked {
				int iters = ( ( ( 2 * length ) / stride ) + 100 );
				global::Array<uint> seed = new global::Array<uint>(new uint[]{((uint) (7) )});
				iters = ( ( (( ( iters + vec.length ) - 1 )) / vec.length ) * vec.length );
				{
					int _g1 = 0;
					int _g = iters;
					while (( _g1 < _g )) {
						global::encode.histogram.Histogram sample = new global::encode.histogram.Histogram(((int) (HistogramTypeInt) ));
						global::encode.Block_splitter.RandomSample(seed, data, length, stride, sample);
						((global::encode.histogram.Histogram) (vec[( _g1++ % vec.length )]) ).AddHistogram(sample);
					}
					
				}
				
			}
		}
		
		
		public static double BitCost(int count) {
			unchecked {
				if (( count == 0 )) {
					return ((double) (-2) );
				}
				else {
					return global::encode.Fast_log.FastLog2(count);
				}
				
			}
		}
		
		
		public static void FindBlocks(int kSize, global::Array<uint> data, int length, double block_switch_bitcost, global::Array<object> vec, uint[] block_id, int block_id_off) {
			unchecked {
				if (( vec.length <= 1 )) {
					{
						int _g1 = 0;
						while (( _g1 < length )) {
							((uint[]) (block_id) )[_g1++] = ((uint) (0) );
						}
						
					}
					
					return;
				}
				
				int vecsize = vec.length;
				double[] insert_cost = global::FunctionMalloc.mallocFloat(( kSize * vecsize ));
				{
					int _g11 = 0;
					while (( _g11 < vecsize )) {
						int j = _g11++;
						((double[]) (insert_cost) )[j] = global::encode.Fast_log.FastLog2(((global::encode.histogram.Histogram) (vec[j]) ).total_count_);
					}
					
				}
				
				int i = ( kSize - 1 );
				while (( i >= 0 )) {
					{
						int _g12 = 0;
						while (( _g12 < vecsize )) {
							int j1 = _g12++;
							{
								int count = ((int[]) (((global::encode.histogram.Histogram) (vec[j1]) ).data_) )[i];
								double val = ( (( count == 0 )) ? (((double) (-2) )) : (global::encode.Fast_log.FastLog2(count)) );
								((double[]) (insert_cost) )[( ( i * vecsize ) + j1 )] = ( ((double) (((double[]) (insert_cost) )[j1]) ) - val );
							}
							
						}
						
					}
					
					 -- i;
				}
				
				double[] cost = global::FunctionMalloc.mallocFloat(vecsize);
				bool[] switch_signal = global::FunctionMalloc.mallocBool(( length * vecsize ));
				{
					int _g13 = 0;
					while (( _g13 < length )) {
						int byte_ix = _g13++;
						int ix = ( byte_ix * vecsize );
						int insert_cost_ix = ((int) (((uint) (( data[byte_ix] * vecsize )) )) );
						double min_cost = 1e99;
						{
							int _g3 = 0;
							while (( _g3 < vecsize )) {
								int k = _g3++;
								((double[]) (cost) )[k] = ( ((double) (((double[]) (cost) )[k]) ) + ((double) (((double[]) (insert_cost) )[( insert_cost_ix + k )]) ) );
								if (( ((double) (((double[]) (cost) )[k]) ) < min_cost )) {
									min_cost = ((double) (((double[]) (cost) )[k]) );
									((uint[]) (block_id) )[byte_ix] = ((uint) (k) );
								}
								
							}
							
						}
						
						double block_switch_cost = block_switch_bitcost;
						if (( byte_ix < 2000 )) {
							block_switch_cost = ( block_switch_bitcost * (( 0.77 + ( ( 0.07 * byte_ix ) / 2000 ) )) );
						}
						
						{
							int _g31 = 0;
							while (( _g31 < vecsize )) {
								int k1 = _g31++;
								((double[]) (cost) )[k1] = ( ((double) (((double[]) (cost) )[k1]) ) - min_cost );
								if (( ((double) (((double[]) (cost) )[k1]) ) >= block_switch_cost )) {
									((double[]) (cost) )[k1] = block_switch_cost;
									((bool[]) (switch_signal) )[( ix + k1 )] = true;
								}
								
							}
							
						}
						
					}
					
				}
				
				int byte_ix1 = ( length - 1 );
				int ix1 = ( byte_ix1 * vecsize );
				int cur_id = ((int) (((uint) (((uint[]) (block_id) )[byte_ix1]) )) );
				while (( byte_ix1 > 0 )) {
					 -- byte_ix1;
					ix1 -= vecsize;
					if (((bool) (((bool[]) (switch_signal) )[( ix1 + cur_id )]) )) {
						cur_id = ((int) (((uint) (((uint[]) (block_id) )[byte_ix1]) )) );
					}
					
					((uint[]) (block_id) )[byte_ix1] = ((uint) (cur_id) );
				}
				
			}
		}
		
		
		public static int RemapBlockIds(uint[] block_ids, int length) {
			global::haxe.ds.IntMap<int> new_id = new global::haxe.ds.IntMap<int>();
			int next_id = 0;
			{
				int _g1 = 0;
				while (( _g1 < length )) {
					int i = _g1++;
					if (( new_id.exists(((int) (((uint) (((uint[]) (block_ids) )[i]) )) )) == false )) {
						new_id.@set(((int) (((uint) (((uint[]) (block_ids) )[i]) )) ), next_id);
						 ++ next_id;
					}
					
				}
				
			}
			
			{
				int _g11 = 0;
				while (( _g11 < length )) {
					int i1 = _g11++;
					((uint[]) (block_ids) )[i1] = ((uint) ((new_id.@get(((int) (((uint) (((uint[]) (block_ids) )[i1]) )) ))).@value) );
				}
				
			}
			
			return next_id;
		}
		
		
		public static void BuildBlockHistograms(int HistogramTypeInt, global::Array<uint> data, int length, uint[] block_ids, int block_ids_off, global::Array<object> histograms) {
			int num_types = global::encode.Block_splitter.RemapBlockIds(block_ids, length);
			while (( histograms.length > 0 )) {
				histograms.pop();
			}
			
			{
				int _g1 = 0;
				while (( _g1 < num_types )) {
					 ++ _g1;
					histograms.push(new global::encode.histogram.Histogram(((int) (HistogramTypeInt) )));
				}
				
			}
			
			{
				int _g11 = 0;
				while (( _g11 < length )) {
					int i = _g11++;
					((global::encode.histogram.Histogram) (histograms[((int) (((uint) (((uint[]) (block_ids) )[i]) )) )]) ).Add1(((int) (data[i]) ));
				}
				
			}
			
		}
		
		
		public static void ClusterBlocks(int HistogramTypeInt, global::Array<uint> data, int length, uint[] block_ids) {
			unchecked {
				global::Array<object> histograms = new global::Array<object>();
				int[] block_index = global::FunctionMalloc.mallocInt(length);
				int cur_idx = 0;
				global::encode.histogram.Histogram cur_histogram = new global::encode.histogram.Histogram(((int) (HistogramTypeInt) ));
				{
					int _g1 = 0;
					while (( _g1 < length )) {
						int i = _g1++;
						bool block_boundary = ( ( ( i + 1 ) == length ) || ((bool) (( ((uint) (((uint[]) (block_ids) )[i]) ) != ((uint) (((uint[]) (block_ids) )[( i + 1 )]) ) )) ) );
						((int[]) (block_index) )[i] = cur_idx;
						cur_histogram.Add1(((int) (data[i]) ));
						if (block_boundary) {
							histograms.push(cur_histogram);
							cur_histogram = new global::encode.histogram.Histogram(((int) (HistogramTypeInt) ));
							 ++ cur_idx;
						}
						
					}
					
				}
				
				global::Array<object> clustered_histograms = new global::Array<object>();
				int[] histogram_symbols = ((int[]) (new int[histograms.length]) );
				global::encode.Cluster.ClusterHistograms(histograms, 1, histograms.length, 256, clustered_histograms, HistogramTypeInt, histogram_symbols);
				{
					int _g11 = 0;
					while (( _g11 < length )) {
						int i1 = _g11++;
						((uint[]) (block_ids) )[i1] = ((uint) (((int) (((int[]) (histogram_symbols) )[((int) (((int[]) (block_index) )[i1]) )]) )) );
					}
					
				}
				
			}
		}
		
		
		public static void BuildBlockSplit(uint[] block_ids, global::encode.metablock.BlockSplit split) {
			unchecked {
				int cur_id = ((int) (((uint) (((uint[]) (block_ids) )[0]) )) );
				int cur_length = 1;
				split.num_types = -1;
				{
					int _g1 = 1;
					int _g = ( ((uint[]) (block_ids) ) as global::System.Array ).Length;
					while (( _g1 < _g )) {
						int i = _g1++;
						if (((bool) (( ((uint) (((uint[]) (block_ids) )[i]) ) != cur_id )) )) {
							split.types.push(cur_id);
							split.lengths.push(cur_length);
							split.num_types = ((int) (global::System.Math.Max(((double) (split.num_types) ), ((double) (cur_id) ))) );
							cur_id = ((int) (((uint) (((uint[]) (block_ids) )[i]) )) );
							cur_length = 0;
						}
						
						 ++ cur_length;
					}
					
				}
				
				split.types.push(cur_id);
				split.lengths.push(cur_length);
				split.num_types = ((int) (global::System.Math.Max(((double) (split.num_types) ), ((double) (cur_id) ))) );
				 ++ split.num_types;
			}
		}
		
		
		public static void SplitByteVector(int HistogramTypeInt, global::Array<uint> data, int literals_per_histogram, int max_histograms, int sampling_stride_length, double block_switch_cost, global::encode.metablock.BlockSplit split) {
			unchecked {
				if (( data.length == 0 )) {
					split.num_types = 1;
					return;
				}
				else if (( data.length < 128 )) {
					split.num_types = 1;
					split.types.push(0);
					split.lengths.push(data.length);
					return;
				}
				
				global::Array<object> histograms = new global::Array<object>();
				global::encode.Block_splitter.InitialEntropyCodes(HistogramTypeInt, data, data.length, literals_per_histogram, max_histograms, sampling_stride_length, histograms);
				global::encode.Block_splitter.RefineEntropyCodes(HistogramTypeInt, data, data.length, sampling_stride_length, histograms);
				uint[] block_ids = global::FunctionMalloc.mallocUInt(data.length);
				{
					int _g = 0;
					while (( _g < 10 )) {
						 ++ _g;
						global::encode.Block_splitter.FindBlocks(HistogramTypeInt, data, data.length, block_switch_cost, histograms, block_ids, 0);
						global::encode.Block_splitter.BuildBlockHistograms(HistogramTypeInt, data, data.length, block_ids, 0, histograms);
					}
					
				}
				
				global::encode.Block_splitter.ClusterBlocks(HistogramTypeInt, data, data.length, block_ids);
				global::encode.Block_splitter.BuildBlockSplit(block_ids, split);
			}
		}
		
		
		public static void SplitBlock(global::Array<object> cmds, int num_commands, uint[] data, int data_off, global::encode.metablock.BlockSplit literal_split, global::encode.metablock.BlockSplit insert_and_copy_split, global::encode.metablock.BlockSplit dist_split) {
			unchecked {
				global::Array<uint> literals = new global::Array<uint>();
				global::encode.Block_splitter.CopyLiteralsToByteArray(cmds, num_commands, data, data_off, literals);
				global::Array<uint> insert_and_copy_codes = new global::Array<uint>();
				global::Array<uint> distance_prefixes = new global::Array<uint>();
				global::encode.Block_splitter.CopyCommandsToByteArray(cmds, num_commands, insert_and_copy_codes, distance_prefixes);
				global::encode.Block_splitter.SplitByteVector(global::encode.Histogram_functions.HistogramLiteralInt, literals, 544, 100, 70, 28.1, literal_split);
				global::encode.Block_splitter.SplitByteVector(global::encode.Histogram_functions.HistogramCommandInt, insert_and_copy_codes, 530, 50, 40, 13.5, insert_and_copy_split);
				global::encode.Block_splitter.SplitByteVector(global::encode.Histogram_functions.HistogramDistanceInt, distance_prefixes, 544, 50, 40, 14.6, dist_split);
			}
		}
		
		
	}
}


