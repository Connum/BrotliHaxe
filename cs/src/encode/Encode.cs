// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace encode {
	public class Encode : global::haxe.lang.HxObject {
		
		static Encode() {
			unchecked {
				global::encode.Encode.kMaxWindowBits = 24;
				global::encode.Encode.kMinWindowBits = 16;
				global::encode.Encode.kMinInputBlockBits = 16;
				global::encode.Encode.kMaxInputBlockBits = 24;
				global::encode.Encode.kMinUTF8Ratio = 0.75;
				global::encode.Encode.kMinQualityForBlockSplit = 4;
				global::encode.Encode.kMinQualityForContextModeling = 5;
				global::encode.Encode.kMinQualityForOptimizeHistograms = 4;
			}
		}
		
		
		public Encode(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Encode() {
			global::encode.Encode.__hx_ctor_encode_Encode(this);
		}
		
		
		public static void __hx_ctor_encode_Encode(global::encode.Encode __hx_this) {
		}
		
		
		public static int kMaxWindowBits;
		
		public static int kMinWindowBits;
		
		public static int kMinInputBlockBits;
		
		public static int kMaxInputBlockBits;
		
		public static double kMinUTF8Ratio;
		
		public static int kMinQualityForBlockSplit;
		
		public static int kMinQualityForContextModeling;
		
		public static int kMinQualityForOptimizeHistograms;
		
		public static int ParseAsUTF8(global::Array<int> symbol, uint[] input, int input_off, int size) {
			unchecked {
				if (((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[input_off]) ) & 128 )) )) == 0 )) )) {
					symbol[0] = ((int) (((uint) (((uint[]) (input) )[input_off]) )) );
					if (( symbol[0] > 0 )) {
						return 1;
					}
					
				}
				
				if (( ( ( size > 1 ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[input_off]) ) & 224 )) )) == 192 )) ) ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 1 )]) ) & 192 )) )) == 128 )) ) )) {
					symbol[0] = ((int) (((uint) (( ((uint) (( (((uint) (( ((uint) (((uint[]) (input) )[input_off]) ) & 31 )) )) << 6 )) ) | ((uint) (( ((uint) (((uint[]) (input) )[( input_off + 1 )]) ) & 63 )) ) )) )) );
					if (( symbol[0] > 127 )) {
						return 2;
					}
					
				}
				
				if (( ( ( ( size > 2 ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[input_off]) ) & 240 )) )) == 224 )) ) ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 1 )]) ) & 192 )) )) == 128 )) ) ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 2 )]) ) & 192 )) )) == 128 )) ) )) {
					symbol[0] = ((int) (((uint) (( ((uint) (( ((uint) (( (((uint) (( ((uint) (((uint[]) (input) )[input_off]) ) & 15 )) )) << 12 )) ) | ((uint) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 1 )]) ) & 63 )) )) << 6 )) ) )) ) | ((uint) (( ((uint) (((uint[]) (input) )[( input_off + 2 )]) ) & 63 )) ) )) )) );
					if (( symbol[0] > 2047 )) {
						return 3;
					}
					
				}
				
				if (( ( ( ( ( size > 3 ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[input_off]) ) & 248 )) )) == 240 )) ) ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 1 )]) ) & 192 )) )) == 128 )) ) ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 2 )]) ) & 192 )) )) == 128 )) ) ) && ((bool) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 3 )]) ) & 192 )) )) == 128 )) ) )) {
					symbol[0] = ((int) (((uint) (( ((uint) (( ((uint) (( ((uint) (( (((uint) (( ((uint) (((uint[]) (input) )[input_off]) ) & 7 )) )) << 18 )) ) | ((uint) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 1 )]) ) & 63 )) )) << 12 )) ) )) ) | ((uint) (( (((uint) (( ((uint) (((uint[]) (input) )[( input_off + 2 )]) ) & 63 )) )) << 6 )) ) )) ) | ((uint) (( ((uint) (((uint[]) (input) )[( input_off + 3 )]) ) & 63 )) ) )) )) );
					if (( ( symbol[0] > 65535 ) && ( symbol[0] <= 1114111 ) )) {
						return 4;
					}
					
				}
				
				symbol[0] = ((int) (((uint) (( ((uint) (((uint[]) (input) )[input_off]) ) | 1114112 )) )) );
				return 1;
			}
		}
		
		
		public static bool IsMostlyUTF8(uint[] data, int data_off, int length, double min_fraction) {
			unchecked {
				int size_utf8 = 0;
				int pos = 0;
				while (( pos < length )) {
					global::Array<int> symbol = new global::Array<int>();
					int bytes_read = global::encode.Encode.ParseAsUTF8(symbol, data, ( data_off + pos ), ( length - pos ));
					pos += bytes_read;
					if (( symbol[0] < 1114112 )) {
						size_utf8 += bytes_read;
					}
					
				}
				
				return ( size_utf8 > ( min_fraction * length ) );
			}
		}
		
		
		public static void RecomputeDistancePrefixes(global::Array<object> cmds, int num_commands, int num_direct_distance_codes, int distance_postfix_bits) {
			unchecked {
				if (( ( num_direct_distance_codes == 0 ) && ( distance_postfix_bits == 0 ) )) {
					return;
				}
				
				{
					int _g1 = 0;
					while (( _g1 < num_commands )) {
						global::encode.command.Command cmd = ((global::encode.command.Command) (cmds[_g1++]) );
						if (( ( cmd.copy_len_ > 0 ) && ((bool) (( cmd.cmd_prefix_[0] >= 128 )) ) )) {
							global::encode.Prefix.PrefixEncodeCopyDistance(cmd.DistanceCode(), num_direct_distance_codes, distance_postfix_bits, cmd.dist_prefix_, cmd.dist_extra_);
						}
						
					}
					
				}
				
			}
		}
		
		
		public static void DecideOverLiteralContextModeling(uint[] input, int start_pos, int length, int mask, int quality, global::Array<int> literal_context_mode, global::Array<int> num_literal_contexts, global::Array<object> literal_context_map) {
			unchecked {
				if (( ( quality < global::encode.Encode.kMinQualityForContextModeling ) || ( length < 64 ) )) {
					return;
				}
				
				int end_pos = ( start_pos + length );
				while (( ( start_pos + 64 ) < end_pos )) {
					int stride_end_pos = ( start_pos + 64 );
					uint prev = ((uint) (((uint[]) (input) )[( start_pos & mask )]) );
					{
						int _g1 = ( start_pos + 1 );
						while (( _g1 < stride_end_pos )) {
							uint literal = ((uint) (((uint[]) (input) )[( _g1++ & mask )]) );
							if (( ( ((bool) (( prev < 128 )) ) && ((bool) (( (((uint) (( literal & 192 )) )) == 128 )) ) ) || ( ((bool) (( prev >= 192 )) ) && ((bool) (( (((uint) (( literal & 192 )) )) != 128 )) ) ) )) {
								return;
							}
							
							prev = literal;
						}
						
					}
					
					start_pos += 4096;
				}
				
				literal_context_mode[0] = 2;
				num_literal_contexts[0] = 2;
				literal_context_map[0] = new global::Array<int>(new int[]{0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0});
			}
		}
		
		
		public static int CopyOneBlockToRingBuffer(object r, global::encode.encode.BrotliCompressor compressor) {
			int block_size = compressor.input_block_size();
			global::Array<uint> bytes_read = new global::Array<uint>(new uint[]{((uint) (0) )});
			uint[] data = ((uint[]) (((object) (global::haxe.lang.Runtime.callField(r, "Read", 914388854, new global::Array<object>(new object[]{block_size, bytes_read}))) )) );
			if (( data == null )) {
				return 0;
			}
			
			compressor.CopyInputToRingBuffer(((int) (bytes_read[0]) ), data);
			int remaining = ((int) (((uint) (( block_size - bytes_read[0] )) )) );
			while (( remaining > 0 )) {
				global::Array<uint> more_bytes_read = new global::Array<uint>(new uint[]{((uint) (0) )});
				data = ((uint[]) (((object) (global::haxe.lang.Runtime.callField(r, "Read", 914388854, new global::Array<object>(new object[]{remaining, more_bytes_read}))) )) );
				if (( data == null )) {
					break;
				}
				
				compressor.CopyInputToRingBuffer(((int) (more_bytes_read[0]) ), data);
				bytes_read[0] = ((uint) (( bytes_read[0] + more_bytes_read[0] )) );
				remaining = ((int) (((uint) (( remaining - more_bytes_read[0] )) )) );
			}
			
			return ((int) (bytes_read[0]) );
		}
		
		
		public static bool BrotliInIsFinished(object r) {
			global::Array<int> read_bytes = new global::Array<int>();
			return ( ((object) (global::haxe.lang.Runtime.callField(r, "Read", 914388854, new global::Array<object>(new object[]{0, read_bytes}))) ) == null );
		}
		
		
		public static bool BrotliCompress(global::encode.encode.BrotliParams @params, object input, object output) {
			return global::encode.Encode.BrotliCompressWithCustomDictionary(0, null, @params, input, output);
		}
		
		
		public static bool BrotliCompressWithCustomDictionary(int dictsize, uint[] dict, global::encode.encode.BrotliParams @params, object input, object output) {
			int in_bytes = 0;
			global::Array<int> out_bytes = new global::Array<int>(new int[]{0});
			global::Array<object> @out = new global::Array<object>();
			bool final_block = false;
			global::encode.encode.BrotliCompressor compressor = new global::encode.encode.BrotliCompressor(((global::encode.encode.BrotliParams) (@params) ));
			if (( dictsize != 0 )) {
				compressor.BrotliSetCustomDictionary(dictsize, dict);
			}
			
			while ( ! (final_block) ) {
				in_bytes = global::encode.Encode.CopyOneBlockToRingBuffer(input, compressor);
				if (( in_bytes != 0 )) {
					final_block = global::encode.Encode.BrotliInIsFinished(input);
				}
				else {
					final_block = true;
				}
				
				out_bytes[0] = 0;
				if ( ! (compressor.WriteBrotliData(final_block, false, out_bytes, @out)) ) {
					return false;
				}
				
				if (( ( out_bytes[0] > 0 ) && ( ! (global::haxe.lang.Runtime.toBool(((object) (global::haxe.lang.Runtime.callField(output, "Write", 1669782719, new global::Array<object>(new object[]{((uint[]) (@out[0]) ), out_bytes[0]}))) ))) ) )) {
					return false;
				}
				
			}
			
			return true;
		}
		
		
	}
}


