// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace encode {
	public class Brotli_bit_stream : global::haxe.lang.HxObject {
		
		public Brotli_bit_stream(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Brotli_bit_stream() {
			global::encode.Brotli_bit_stream.__hx_ctor_encode_Brotli_bit_stream(this);
		}
		
		
		public static void __hx_ctor_encode_Brotli_bit_stream(global::encode.Brotli_bit_stream __hx_this) {
		}
		
		
		public static bool EncodeMlen(int length, global::Array<int> bits, global::Array<int> numbits, global::Array<int> nibblesbits) {
			unchecked {
				 -- length;
				int lg = ( (( length == 0 )) ? (1) : (( global::encode.Fast_log.Log2Floor(((uint) (length) )) + 1 )) );
				if (( lg > 24 )) {
					return false;
				}
				
				int mnibbles = ( (( (( lg < 16 )) ? (16) : (( lg + 3 )) )) / 4 );
				nibblesbits[0] = ( mnibbles - 4 );
				numbits[0] = ( mnibbles * 4 );
				bits[0] = length;
				return true;
			}
		}
		
		
		public static void StoreVarLenUint8(int n, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				if (( n == 0 )) {
					global::encode.Write_bits.WriteBits(1, ((uint) (0) ), storage_ix, storage);
				}
				else {
					global::encode.Write_bits.WriteBits(1, ((uint) (1) ), storage_ix, storage);
					int nbits = global::encode.Fast_log.Log2Floor(((uint) (n) ));
					global::encode.Write_bits.WriteBits(3, ((uint) (nbits) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(nbits, ((uint) (( n - (( 1 << nbits )) )) ), storage_ix, storage);
				}
				
			}
		}
		
		
		public static bool StoreCompressedMetaBlockHeader(bool final_block, int length, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				global::encode.Write_bits.WriteBits(1, ( (final_block) ? (((uint) (1) )) : (((uint) (0) )) ), storage_ix, storage);
				if (final_block) {
					global::encode.Write_bits.WriteBits(1, ( (( length == 0 )) ? (((uint) (1) )) : (((uint) (0) )) ), storage_ix, storage);
					if (( length == 0 )) {
						return true;
					}
					
				}
				
				if (( length == 0 )) {
					return false;
				}
				
				global::Array<int> lenbits = new global::Array<int>();
				global::Array<int> nlenbits = new global::Array<int>();
				global::Array<int> nibblesbits = new global::Array<int>();
				if ( ! (global::encode.Brotli_bit_stream.EncodeMlen(length, lenbits, nlenbits, nibblesbits)) ) {
					return false;
				}
				
				global::encode.Write_bits.WriteBits(2, ((uint) (nibblesbits[0]) ), storage_ix, storage);
				global::encode.Write_bits.WriteBits(nlenbits[0], ((uint) (lenbits[0]) ), storage_ix, storage);
				if ( ! (final_block) ) {
					global::encode.Write_bits.WriteBits(1, ((uint) (0) ), storage_ix, storage);
				}
				
				return true;
			}
		}
		
		
		public static bool StoreUncompressedMetaBlockHeader(int length, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				global::encode.Write_bits.WriteBits(1, ((uint) (0) ), storage_ix, storage);
				global::Array<int> lenbits = new global::Array<int>();
				global::Array<int> nlenbits = new global::Array<int>();
				global::Array<int> nibblesbits = new global::Array<int>();
				if ( ! (global::encode.Brotli_bit_stream.EncodeMlen(length, lenbits, nlenbits, nibblesbits)) ) {
					return false;
				}
				
				global::encode.Write_bits.WriteBits(2, ((uint) (nibblesbits[0]) ), storage_ix, storage);
				global::encode.Write_bits.WriteBits(nlenbits[0], ((uint) (lenbits[0]) ), storage_ix, storage);
				global::encode.Write_bits.WriteBits(1, ((uint) (1) ), storage_ix, storage);
				return true;
			}
		}
		
		
		public static void StoreHuffmanTreeOfHuffmanTreeToBitMask(int num_codes, uint[] code_length_bitdepth, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				global::Array<uint> kStorageOrder = new global::Array<uint>(new uint[]{((uint) (1) ), ((uint) (2) ), ((uint) (3) ), ((uint) (4) ), ((uint) (0) ), ((uint) (5) ), ((uint) (17) ), ((uint) (6) ), ((uint) (16) ), ((uint) (7) ), ((uint) (8) ), ((uint) (9) ), ((uint) (10) ), ((uint) (11) ), ((uint) (12) ), ((uint) (13) ), ((uint) (14) ), ((uint) (15) )});
				global::Array<uint> kHuffmanBitLengthHuffmanCodeSymbols = new global::Array<uint>(new uint[]{((uint) (0) ), ((uint) (7) ), ((uint) (3) ), ((uint) (2) ), ((uint) (1) ), ((uint) (15) )});
				global::Array<uint> kHuffmanBitLengthHuffmanCodeBitLengths = new global::Array<uint>(new uint[]{((uint) (2) ), ((uint) (4) ), ((uint) (3) ), ((uint) (2) ), ((uint) (2) ), ((uint) (4) )});
				int codes_to_store = 18;
				if (( num_codes > 1 )) {
					while (( codes_to_store > 0 )) {
						if (((bool) (( ((uint) (((uint[]) (code_length_bitdepth) )[((int) (kStorageOrder[( codes_to_store - 1 )]) )]) ) != 0 )) )) {
							break;
						}
						
						 -- codes_to_store;
					}
					
				}
				
				int skip_some = 0;
				if (( ((bool) (( ((uint) (((uint[]) (code_length_bitdepth) )[((int) (kStorageOrder[0]) )]) ) == 0 )) ) && ((bool) (( ((uint) (((uint[]) (code_length_bitdepth) )[((int) (kStorageOrder[1]) )]) ) == 0 )) ) )) {
					skip_some = 2;
					if (((bool) (( ((uint) (((uint[]) (code_length_bitdepth) )[((int) (kStorageOrder[2]) )]) ) == 0 )) )) {
						skip_some = 3;
					}
					
				}
				
				global::encode.Write_bits.WriteBits(2, ((uint) (skip_some) ), storage_ix, storage);
				{
					int _g1 = skip_some;
					int _g = codes_to_store;
					while (( _g1 < _g )) {
						uint l = ((uint) (((uint[]) (code_length_bitdepth) )[((int) (kStorageOrder[_g1++]) )]) );
						global::encode.Write_bits.WriteBits(((int) (kHuffmanBitLengthHuffmanCodeBitLengths[((int) (l) )]) ), kHuffmanBitLengthHuffmanCodeSymbols[((int) (l) )], storage_ix, storage);
					}
					
				}
				
			}
		}
		
		
		public static void StoreHuffmanTreeToBitMask(global::Array<uint> huffman_tree, global::Array<uint> huffman_tree_extra_bits, uint[] code_length_bitdepth, int code_length_bitdepth_off, uint[] code_length_bitdepth_symbols, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				int _g1 = 0;
				int _g = huffman_tree.length;
				while (( _g1 < _g )) {
					int i = _g1++;
					int ix = ((int) (huffman_tree[i]) );
					global::encode.Write_bits.WriteBits(((int) (((uint) (((uint[]) (code_length_bitdepth) )[ix]) )) ), ((uint) (((uint[]) (code_length_bitdepth_symbols) )[ix]) ), storage_ix, storage);
					switch (ix) {
						case 16:
						{
							global::encode.Write_bits.WriteBits(2, huffman_tree_extra_bits[i], storage_ix, storage);
							break;
						}
						
						
						case 17:
						{
							global::encode.Write_bits.WriteBits(3, huffman_tree_extra_bits[i], storage_ix, storage);
							break;
						}
						
						
					}
					
				}
				
			}
		}
		
		
		public static void StoreSimpleHuffmanTree(uint[] depths, int depths_off, global::Array<int> symbols, int num_symbols, int max_bits, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				global::encode.Write_bits.WriteBits(2, ((uint) (1) ), storage_ix, storage);
				global::encode.Write_bits.WriteBits(2, ((uint) (( num_symbols - 1 )) ), storage_ix, storage);
				{
					int _g1 = 0;
					while (( _g1 < num_symbols )) {
						int i = _g1++;
						{
							int _g3 = ( i + 1 );
							while (( _g3 < num_symbols )) {
								int j = _g3++;
								if (((bool) (( ((uint) (((uint[]) (depths) )[( depths_off + symbols[j] )]) ) < ((uint) (((uint[]) (depths) )[( depths_off + symbols[i] )]) ) )) )) {
									int t = symbols[j];
									symbols[j] = symbols[i];
									symbols[i] = t;
								}
								
							}
							
						}
						
					}
					
				}
				
				if (( num_symbols == 2 )) {
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[0]) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[1]) ), storage_ix, storage);
				}
				else if (( num_symbols == 3 )) {
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[0]) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[1]) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[2]) ), storage_ix, storage);
				}
				else {
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[0]) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[1]) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[2]) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (symbols[3]) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(1, ( (((bool) (( ((uint) (((uint[]) (depths) )[( depths_off + symbols[0] )]) ) == 1 )) )) ? (((uint) (1) )) : (((uint) (0) )) ), storage_ix, storage);
				}
				
			}
		}
		
		
		public static void StoreHuffmanTree(uint[] depths, int depths_off, int num, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				global::Array<uint> huffman_tree = new global::Array<uint>();
				global::Array<uint> huffman_tree_extra_bits = new global::Array<uint>();
				global::encode.Entropy_encode.WriteHuffmanTree(depths, depths_off, ((uint) (num) ), huffman_tree, huffman_tree_extra_bits);
				int[] huffman_tree_histogram = global::FunctionMalloc.mallocInt(18);
				{
					int _g1 = 0;
					int _g = huffman_tree.length;
					while (( _g1 < _g )) {
						uint _g2 = huffman_tree[_g1++];
						((int[]) (huffman_tree_histogram) )[((int) (_g2) )] = ( ((int) (((int[]) (huffman_tree_histogram) )[((int) (_g2) )]) ) + 1 );
					}
					
				}
				
				int num_codes = 0;
				int code = 0;
				{
					int _g3 = 0;
					while (( _g3 < 18 )) {
						int i = _g3++;
						if (( ((int) (((int[]) (huffman_tree_histogram) )[i]) ) > 0 )) {
							if (( num_codes == 0 )) {
								code = i;
								num_codes = 1;
							}
							else if (( num_codes == 1 )) {
								num_codes = 2;
								break;
							}
							
						}
						
					}
					
				}
				
				uint[] code_length_bitdepth = global::FunctionMalloc.mallocUInt(18);
				uint[] code_length_bitdepth_symbols = global::FunctionMalloc.mallocUInt(18);
				global::encode.Entropy_encode.CreateHuffmanTree(huffman_tree_histogram, 0, 18, 5, code_length_bitdepth, 0);
				global::encode.Entropy_encode.ConvertBitDepthsToSymbols(code_length_bitdepth, 0, 18, code_length_bitdepth_symbols, 0);
				global::encode.Brotli_bit_stream.StoreHuffmanTreeOfHuffmanTreeToBitMask(num_codes, code_length_bitdepth, storage_ix, storage);
				if (( num_codes == 1 )) {
					((uint[]) (code_length_bitdepth) )[code] = ((uint) (0) );
				}
				
				global::encode.Brotli_bit_stream.StoreHuffmanTreeToBitMask(huffman_tree, huffman_tree_extra_bits, code_length_bitdepth, 0, code_length_bitdepth_symbols, storage_ix, storage);
			}
		}
		
		
		public static void BuildAndStoreHuffmanTree(int[] histogram, int length, uint[] depth, int depth_off, uint[] bits, int bits_off, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				int count = 0;
				global::Array<int> s4 = new global::Array<int>(new int[]{0, 0, 0, 0});
				{
					int _g1 = 0;
					while (( _g1 < length )) {
						int i = _g1++;
						if (( ((int) (((int[]) (histogram) )[i]) ) > 0 )) {
							if (( count < 4 )) {
								s4[count] = i;
							}
							else if (( count > 4 )) {
								break;
							}
							
							 ++ count;
						}
						
					}
					
				}
				
				int max_bits_counter = ( length - 1 );
				int max_bits = 0;
				while (( max_bits_counter > 0 )) {
					max_bits_counter >>= 1;
					 ++ max_bits;
				}
				
				if (( count <= 1 )) {
					global::encode.Write_bits.WriteBits(4, ((uint) (1) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(max_bits, ((uint) (s4[0]) ), storage_ix, storage);
					return;
				}
				
				global::encode.Entropy_encode.CreateHuffmanTree(histogram, 0, length, 15, depth, depth_off);
				global::encode.Entropy_encode.ConvertBitDepthsToSymbols(depth, depth_off, length, bits, bits_off);
				if (( count <= 4 )) {
					global::encode.Brotli_bit_stream.StoreSimpleHuffmanTree(depth, depth_off, s4, count, max_bits, storage_ix, storage);
				}
				else {
					global::encode.Brotli_bit_stream.StoreHuffmanTree(depth, depth_off, length, storage_ix, storage);
				}
				
			}
		}
		
		
		public static int IndexOf(int[] v, int @value) {
			unchecked {
				{
					int _g1 = 0;
					int _g = ( ((int[]) (v) ) as global::System.Array ).Length;
					while (( _g1 < _g )) {
						int i = _g1++;
						if (( ((int) (((int[]) (v) )[i]) ) == @value )) {
							return i;
						}
						
					}
					
				}
				
				return -1;
			}
		}
		
		
		public static void MoveToFront(int[] v, int index) {
			unchecked {
				int @value = ((int) (((int[]) (v) )[index]) );
				int i = index;
				while (( i > 0 )) {
					((int[]) (v) )[i] = ((int) (((int[]) (v) )[( i - 1 )]) );
					 -- i;
				}
				
				((int[]) (v) )[0] = @value;
			}
		}
		
		
		public static int[] MoveToFrontTransform(int[] v) {
			unchecked {
				if (( ( ((int[]) (v) ) as global::System.Array ).Length == 0 )) {
					return v;
				}
				
				int max_element = 0;
				{
					int _g1 = 0;
					int _g = ( ((int[]) (v) ) as global::System.Array ).Length;
					while (( _g1 < _g )) {
						int i = _g1++;
						if (( max_element < ((int) (((int[]) (v) )[i]) ) )) {
							max_element = ((int) (((int[]) (v) )[i]) );
						}
						
					}
					
				}
				
				int[] mtf = ((int[]) (new int[( max_element + 1 )]) );
				{
					int _g11 = 0;
					int _g2 = ( ((int[]) (mtf) ) as global::System.Array ).Length;
					while (( _g11 < _g2 )) {
						int i1 = _g11++;
						((int[]) (mtf) )[i1] = i1;
					}
					
				}
				
				int[] result = ((int[]) (new int[( ((int[]) (v) ) as global::System.Array ).Length]) );
				{
					int _g12 = 0;
					int _g3 = ( ((int[]) (v) ) as global::System.Array ).Length;
					while (( _g12 < _g3 )) {
						int i2 = _g12++;
						int index = global::encode.Brotli_bit_stream.IndexOf(mtf, ((int) (((int[]) (v) )[i2]) ));
						((int[]) (result) )[i2] = index;
						global::encode.Brotli_bit_stream.MoveToFront(mtf, index);
					}
					
				}
				
				return result;
			}
		}
		
		
		public static void RunLengthCodeZeros(int[] v_in, global::Array<int> max_run_length_prefix, global::Array<int> v_out, global::Array<int> extra_bits) {
			unchecked {
				int max_reps = 0;
				int i = 0;
				while (( i < ( ((int[]) (v_in) ) as global::System.Array ).Length )) {
					while (( ( i < ( ((int[]) (v_in) ) as global::System.Array ).Length ) && ( ((int) (((int[]) (v_in) )[i]) ) != 0 ) )) {
						 ++ i;
					}
					
					int reps = 0;
					while (( ( i < ( ((int[]) (v_in) ) as global::System.Array ).Length ) && ( ((int) (((int[]) (v_in) )[i]) ) == 0 ) )) {
						 ++ reps;
						 ++ i;
					}
					
					max_reps = ((int) (global::System.Math.Max(((double) (reps) ), ((double) (max_reps) ))) );
				}
				
				max_run_length_prefix[0] = ((int) (global::System.Math.Min(((double) (( (( max_reps > 0 )) ? (global::encode.Fast_log.Log2Floor(((uint) (max_reps) ))) : (0) )) ), ((double) (max_run_length_prefix[0]) ))) );
				int i1 = 0;
				while (( i1 < ( ((int[]) (v_in) ) as global::System.Array ).Length )) {
					if (( ((int) (((int[]) (v_in) )[i1]) ) != 0 )) {
						v_out.push(( ((int) (((int[]) (v_in) )[i1]) ) + max_run_length_prefix[0] ));
						extra_bits.push(0);
						 ++ i1;
					}
					else {
						int reps1 = 1;
						int k = ( i1 + 1 );
						while (( ( k < ( ((int[]) (v_in) ) as global::System.Array ).Length ) && ( ((int) (((int[]) (v_in) )[k]) ) == 0 ) )) {
							 ++ reps1;
							 ++ k;
						}
						
						i1 += reps1;
						while (( reps1 > 0 )) {
							if (( reps1 < ( 2 << max_run_length_prefix[0] ) )) {
								int run_length_prefix = global::encode.Fast_log.Log2Floor(((uint) (reps1) ));
								v_out.push(run_length_prefix);
								extra_bits.push(( reps1 - (( 1 << run_length_prefix )) ));
								break;
							}
							else {
								v_out.push(max_run_length_prefix[0]);
								extra_bits.push(( (( 1 << max_run_length_prefix[0] )) - 1 ));
								reps1 -= ( (( 2 << max_run_length_prefix[0] )) - 1 );
							}
							
						}
						
					}
					
				}
				
			}
		}
		
		
		public static void EncodeContextMap(int[] context_map, int num_clusters, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				global::encode.Brotli_bit_stream.StoreVarLenUint8(( num_clusters - 1 ), storage_ix, storage);
				if (( num_clusters == 1 )) {
					return;
				}
				
				int[] transformed_symbols = global::encode.Brotli_bit_stream.MoveToFrontTransform(context_map);
				global::Array<int> rle_symbols = new global::Array<int>();
				global::Array<int> extra_bits = new global::Array<int>();
				global::Array<int> max_run_length_prefix = new global::Array<int>(new int[]{6});
				global::encode.Brotli_bit_stream.RunLengthCodeZeros(transformed_symbols, max_run_length_prefix, rle_symbols, extra_bits);
				global::encode.histogram.Histogram symbol_histogram = global::encode.Histogram_functions.HistogramContextMap();
				{
					int _g1 = 0;
					int _g = rle_symbols.length;
					while (( _g1 < _g )) {
						symbol_histogram.Add1(rle_symbols[_g1++]);
					}
					
				}
				
				bool use_rle = ( max_run_length_prefix[0] > 0 );
				global::encode.Write_bits.WriteBits(1, ( (use_rle) ? (((uint) (1) )) : (((uint) (0) )) ), storage_ix, storage);
				if (use_rle) {
					global::encode.Write_bits.WriteBits(4, ((uint) (( max_run_length_prefix[0] - 1 )) ), storage_ix, storage);
				}
				
				global::encode.entropy_encode.EntropyCode symbol_code = global::encode.Entropy_encode.EntropyCodeContextMap();
				global::DefaultFunctions.memset_UInt(symbol_code.depth_, 0, ((uint) (0) ), ( ((uint[]) (symbol_code.depth_) ) as global::System.Array ).Length);
				global::DefaultFunctions.memset_UInt(symbol_code.bits_, 0, ((uint) (0) ), ( ((uint[]) (symbol_code.bits_) ) as global::System.Array ).Length);
				global::encode.Brotli_bit_stream.BuildAndStoreHuffmanTree(symbol_histogram.data_, ( num_clusters + max_run_length_prefix[0] ), symbol_code.depth_, 0, symbol_code.bits_, 0, storage_ix, storage);
				{
					int _g11 = 0;
					int _g2 = rle_symbols.length;
					while (( _g11 < _g2 )) {
						int i = _g11++;
						global::encode.Write_bits.WriteBits(((int) (((uint[]) (symbol_code.depth_) )[rle_symbols[i]]) ), ((uint[]) (symbol_code.bits_) )[rle_symbols[i]], storage_ix, storage);
						if (( ( rle_symbols[i] > 0 ) && ( rle_symbols[i] <= max_run_length_prefix[0] ) )) {
							global::encode.Write_bits.WriteBits(rle_symbols[i], ((uint) (extra_bits[i]) ), storage_ix, storage);
						}
						
					}
					
				}
				
				global::encode.Write_bits.WriteBits(1, ((uint) (1) ), storage_ix, storage);
			}
		}
		
		
		public static void StoreBlockSwitch(global::encode.brotli_bit_stream.BlockSplitCode code, int block_ix, global::Array<int> storage_ix, uint[] storage) {
			if (( block_ix > 0 )) {
				int typecode = ((int[]) (code.type_code) )[block_ix];
				global::encode.Write_bits.WriteBits(((int) (((uint[]) (code.type_depths) )[typecode]) ), ((uint[]) (code.type_bits) )[typecode], storage_ix, storage);
			}
			
			int lencode = ((int[]) (code.length_prefix) )[block_ix];
			global::encode.Write_bits.WriteBits(((int) (((uint[]) (code.length_depths) )[lencode]) ), ((uint[]) (code.length_bits) )[lencode], storage_ix, storage);
			global::encode.Write_bits.WriteBits(((int[]) (code.length_nextra) )[block_ix], ((uint) (((int[]) (code.length_extra) )[block_ix]) ), storage_ix, storage);
		}
		
		
		public static void BuildAndStoreBlockSplitCode(global::Array<int> types, global::Array<int> lengths, int num_types, global::encode.brotli_bit_stream.BlockSplitCode code, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				int num_blocks = types.length;
				int[] type_histo = global::FunctionMalloc.mallocInt(( num_types + 2 ));
				int[] length_histo = global::FunctionMalloc.mallocInt(26);
				int last_type = 1;
				int second_last_type = 0;
				code.type_code = global::FunctionMalloc.mallocInt(num_blocks);
				code.length_prefix = global::FunctionMalloc.mallocInt(num_blocks);
				code.length_nextra = global::FunctionMalloc.mallocInt(num_blocks);
				code.length_extra = global::FunctionMalloc.mallocInt(num_blocks);
				code.type_depths = global::FunctionMalloc.mallocUInt(( num_types + 2 ));
				code.type_bits = global::FunctionMalloc.mallocUInt(( num_types + 2 ));
				code.length_depths = global::FunctionMalloc.mallocUInt(26);
				code.length_bits = global::FunctionMalloc.mallocUInt(26);
				{
					int _g1 = 0;
					while (( _g1 < num_blocks )) {
						int i = _g1++;
						int type = types[i];
						int type_code = ( (( type == ( last_type + 1 ) )) ? (1) : (( (( type == second_last_type )) ? (0) : (( type + 2 )) )) );
						second_last_type = last_type;
						last_type = type;
						((int[]) (code.type_code) )[i] = type_code;
						if (( i > 0 )) {
							int _g2 = type_code;
							((int[]) (type_histo) )[_g2] = ( ((int) (((int[]) (type_histo) )[_g2]) ) + 1 );
						}
						
						global::encode.Prefix.GetBlockLengthPrefixCode(lengths[i], code.length_prefix, i, code.length_nextra, i, code.length_extra, i);
						{
							int _g21 = ((int[]) (code.length_prefix) )[i];
							((int[]) (length_histo) )[_g21] = ( ((int) (((int[]) (length_histo) )[_g21]) ) + 1 );
						}
						
					}
					
				}
				
				global::encode.Brotli_bit_stream.StoreVarLenUint8(( num_types - 1 ), storage_ix, storage);
				if (( num_types > 1 )) {
					global::encode.Brotli_bit_stream.BuildAndStoreHuffmanTree(type_histo, ( num_types + 2 ), code.type_depths, 0, code.type_bits, 0, storage_ix, storage);
					global::encode.Brotli_bit_stream.BuildAndStoreHuffmanTree(length_histo, 26, code.length_depths, 0, code.length_bits, 0, storage_ix, storage);
					global::encode.Brotli_bit_stream.StoreBlockSwitch(code, 0, storage_ix, storage);
				}
				
			}
		}
		
		
		public static void StoreTrivialContextMap(int num_types, int context_bits, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				global::encode.Brotli_bit_stream.StoreVarLenUint8(( num_types - 1 ), storage_ix, storage);
				if (( num_types > 1 )) {
					int repeat_code = ( context_bits - 1 );
					int repeat_bits = ( (( 1 << repeat_code )) - 1 );
					int alphabet_size = ( num_types + repeat_code );
					int[] histogram = global::FunctionMalloc.mallocInt(alphabet_size);
					uint[] depths = global::FunctionMalloc.mallocUInt(alphabet_size);
					uint[] bits = global::FunctionMalloc.mallocUInt(alphabet_size);
					global::encode.Write_bits.WriteBits(1, ((uint) (1) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(4, ((uint) (( repeat_code - 1 )) ), storage_ix, storage);
					((int[]) (histogram) )[repeat_code] = num_types;
					((int[]) (histogram) )[0] = 1;
					{
						int _g1 = context_bits;
						while (( _g1 < alphabet_size )) {
							((int[]) (histogram) )[_g1++] = 1;
						}
						
					}
					
					global::encode.Brotli_bit_stream.BuildAndStoreHuffmanTree(histogram, alphabet_size, depths, 0, bits, 0, storage_ix, storage);
					{
						int _g11 = 0;
						while (( _g11 < num_types )) {
							int i = _g11++;
							int code = ( (( i == 0 )) ? (0) : (( ( i + context_bits ) - 1 )) );
							global::encode.Write_bits.WriteBits(((int) (((uint) (((uint[]) (depths) )[code]) )) ), ((uint) (((uint[]) (bits) )[code]) ), storage_ix, storage);
							global::encode.Write_bits.WriteBits(((int) (((uint) (((uint[]) (depths) )[repeat_code]) )) ), ((uint) (((uint[]) (bits) )[repeat_code]) ), storage_ix, storage);
							global::encode.Write_bits.WriteBits(repeat_code, ((uint) (repeat_bits) ), storage_ix, storage);
						}
						
					}
					
					global::encode.Write_bits.WriteBits(1, ((uint) (1) ), storage_ix, storage);
				}
				
			}
		}
		
		
		public static void JumpToByteBoundary(global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				storage_ix[0] = ( ( storage_ix[0] + 7 ) & -8 );
				((uint[]) (storage) )[( storage_ix[0] >> 3 )] = ((uint) (0) );
			}
		}
		
		
		public static bool StoreMetaBlock(uint[] input, int start_pos, int length, int mask, uint prev_byte, uint prev_byte2, bool is_last, int num_direct_distance_codes, int distance_postfix_bits, int literal_context_mode, global::Array<object> commands, int n_commands, global::encode.metablock.MetaBlockSplit mb, global::Array<int> storage_ix, uint[] storage) {
			unchecked {
				if ( ! (global::encode.Brotli_bit_stream.StoreCompressedMetaBlockHeader(is_last, length, storage_ix, storage)) ) {
					return false;
				}
				
				if (( length == 0 )) {
					global::encode.Brotli_bit_stream.JumpToByteBoundary(storage_ix, storage);
					return true;
				}
				
				global::encode.brotli_bit_stream.BlockEncoder literal_enc = new global::encode.brotli_bit_stream.BlockEncoder(256, mb.literal_split.num_types, mb.literal_split.types, mb.literal_split.lengths);
				global::encode.brotli_bit_stream.BlockEncoder command_enc = new global::encode.brotli_bit_stream.BlockEncoder(704, mb.command_split.num_types, mb.command_split.types, mb.command_split.lengths);
				global::encode.brotli_bit_stream.BlockEncoder distance_enc = new global::encode.brotli_bit_stream.BlockEncoder(( ( 16 + num_direct_distance_codes ) + (( 48 << distance_postfix_bits )) ), mb.distance_split.num_types, mb.distance_split.types, mb.distance_split.lengths);
				literal_enc.BuildAndStoreBlockSwitchEntropyCodes(storage_ix, storage);
				command_enc.BuildAndStoreBlockSwitchEntropyCodes(storage_ix, storage);
				distance_enc.BuildAndStoreBlockSwitchEntropyCodes(storage_ix, storage);
				global::encode.Write_bits.WriteBits(2, ((uint) (distance_postfix_bits) ), storage_ix, storage);
				global::encode.Write_bits.WriteBits(4, ((uint) (( num_direct_distance_codes >> distance_postfix_bits )) ), storage_ix, storage);
				{
					int _g1 = 0;
					int _g = mb.literal_split.num_types;
					while (( _g1 < _g )) {
						 ++ _g1;
						global::encode.Write_bits.WriteBits(2, ((uint) (literal_context_mode) ), storage_ix, storage);
					}
					
				}
				
				if (( ( ((int[]) (mb.literal_context_map) ) as global::System.Array ).Length == 0 )) {
					global::encode.Brotli_bit_stream.StoreTrivialContextMap(mb.literal_histograms.length, 6, storage_ix, storage);
				}
				else {
					global::encode.Brotli_bit_stream.EncodeContextMap(mb.literal_context_map, mb.literal_histograms.length, storage_ix, storage);
				}
				
				if (( ( ((int[]) (mb.distance_context_map) ) as global::System.Array ).Length == 0 )) {
					global::encode.Brotli_bit_stream.StoreTrivialContextMap(mb.distance_histograms.length, 2, storage_ix, storage);
				}
				else {
					global::encode.Brotli_bit_stream.EncodeContextMap(mb.distance_context_map, mb.distance_histograms.length, storage_ix, storage);
				}
				
				literal_enc.BuildAndStoreEntropyCodes(mb.literal_histograms, storage_ix, storage);
				command_enc.BuildAndStoreEntropyCodes(mb.command_histograms, storage_ix, storage);
				distance_enc.BuildAndStoreEntropyCodes(mb.distance_histograms, storage_ix, storage);
				int pos = start_pos;
				{
					int _g11 = 0;
					while (( _g11 < n_commands )) {
						global::encode.command.Command cmd = ((global::encode.command.Command) (commands[_g11++]) );
						int lennumextra = ((int) (((uint) (((uint) (( ((uint) (cmd.cmd_extra_[0]) ) >> 16 )) )) )) );
						global::Array<uint> lenextra = cmd.cmd_extra_;
						command_enc.StoreSymbol(((int) (cmd.cmd_prefix_[0]) ), storage_ix, storage);
						if (( lennumextra >= 32 )) {
							global::encode.Write_bits.WriteBits(( lennumextra - 32 ), lenextra[0], storage_ix, storage);
						}
						
						global::encode.Write_bits.WriteBits(( (( lennumextra < 32 )) ? (lennumextra) : (32) ), lenextra[1], storage_ix, storage);
						if (( ( ((int[]) (mb.literal_context_map) ) as global::System.Array ).Length == 0 )) {
							int _g3 = 0;
							int _g2 = cmd.insert_len_;
							while (( _g3 < _g2 )) {
								 ++ _g3;
								literal_enc.StoreSymbol(((int) (((uint) (((uint[]) (input) )[( pos & mask )]) )) ), storage_ix, storage);
								 ++ pos;
							}
							
						}
						else {
							int _g31 = 0;
							int _g21 = cmd.insert_len_;
							while (( _g31 < _g21 )) {
								 ++ _g31;
								int literal = ((int) (((uint) (((uint[]) (input) )[( pos & mask )]) )) );
								literal_enc.StoreSymbolWithContext(6, literal, ((int) (global::encode.Context.ContextFunction(prev_byte, prev_byte2, literal_context_mode)) ), mb.literal_context_map, storage_ix, storage);
								prev_byte2 = prev_byte;
								prev_byte = ((uint) (literal) );
								 ++ pos;
							}
							
						}
						
						pos += cmd.copy_len_;
						if (( cmd.copy_len_ > 0 )) {
							prev_byte2 = ((uint) (((uint[]) (input) )[( ( pos - 2 ) & mask )]) );
							prev_byte = ((uint) (((uint[]) (input) )[( ( pos - 1 ) & mask )]) );
							if (((bool) (( cmd.cmd_prefix_[0] >= 128 )) )) {
								int dist_code = ((int) (cmd.dist_prefix_[0]) );
								int distnumextra = ((int) (((uint) (((uint) (( ((uint) (cmd.dist_extra_[0]) ) >> 24 )) )) )) );
								int distextra = ((int) (((uint) (( cmd.dist_extra_[0] & 16777215 )) )) );
								if (( ( ((int[]) (mb.distance_context_map) ) as global::System.Array ).Length == 0 )) {
									distance_enc.StoreSymbol(dist_code, storage_ix, storage);
								}
								else {
									distance_enc.StoreSymbolWithContext(2, dist_code, cmd.DistanceContext(), mb.distance_context_map, storage_ix, storage);
								}
								
								global::encode.Write_bits.WriteBits(distnumextra, ((uint) (distextra) ), storage_ix, storage);
							}
							
						}
						
					}
					
				}
				
				if (is_last) {
					global::encode.Brotli_bit_stream.JumpToByteBoundary(storage_ix, storage);
				}
				
				return true;
			}
		}
		
		
		public static bool StoreMetaBlockTrivial(uint[] input, int start_pos, int length, int mask, bool is_last, global::Array<object> commands, int n_commands, global::Array<int> storage_ix, uint[] storage, int storage_off) {
			unchecked {
				if ( ! (global::encode.Brotli_bit_stream.StoreCompressedMetaBlockHeader(is_last, length, storage_ix, storage)) ) {
					return false;
				}
				
				if (( length == 0 )) {
					global::encode.Brotli_bit_stream.JumpToByteBoundary(storage_ix, storage);
					return true;
				}
				
				global::encode.histogram.Histogram lit_histo = global::encode.Histogram_functions.HistogramLiteral();
				global::encode.histogram.Histogram cmd_histo = global::encode.Histogram_functions.HistogramCommand();
				global::encode.histogram.Histogram dist_histo = global::encode.Histogram_functions.HistogramDistance();
				int pos = start_pos;
				{
					int _g1 = 0;
					while (( _g1 < n_commands )) {
						global::encode.command.Command cmd = ((global::encode.command.Command) (commands[_g1++]) );
						cmd_histo.Add1(((int) (cmd.cmd_prefix_[0]) ));
						{
							int _g3 = 0;
							int _g2 = cmd.insert_len_;
							while (( _g3 < _g2 )) {
								 ++ _g3;
								lit_histo.Add1(((int) (((uint) (((uint[]) (input) )[( pos & mask )]) )) ));
								 ++ pos;
							}
							
						}
						
						pos += cmd.copy_len_;
						if (( ( cmd.copy_len_ > 0 ) && ((bool) (( cmd.cmd_prefix_[0] >= 128 )) ) )) {
							dist_histo.Add1(((int) (cmd.dist_prefix_[0]) ));
						}
						
					}
					
				}
				
				global::encode.Write_bits.WriteBits(13, ((uint) (0) ), storage_ix, storage);
				uint[] lit_depth = global::FunctionMalloc.mallocUInt(256);
				uint[] lit_bits = global::FunctionMalloc.mallocUInt(256);
				uint[] cmd_depth = global::FunctionMalloc.mallocUInt(704);
				uint[] cmd_bits = global::FunctionMalloc.mallocUInt(704);
				uint[] dist_depth = global::FunctionMalloc.mallocUInt(64);
				uint[] dist_bits = global::FunctionMalloc.mallocUInt(64);
				global::encode.Brotli_bit_stream.BuildAndStoreHuffmanTree(lit_histo.data_, 256, lit_depth, 0, lit_bits, 0, storage_ix, storage);
				global::encode.Brotli_bit_stream.BuildAndStoreHuffmanTree(cmd_histo.data_, 704, cmd_depth, 0, cmd_bits, 0, storage_ix, storage);
				global::encode.Brotli_bit_stream.BuildAndStoreHuffmanTree(dist_histo.data_, 64, dist_depth, 0, dist_bits, 0, storage_ix, storage);
				pos = start_pos;
				{
					int _g11 = 0;
					while (( _g11 < n_commands )) {
						global::encode.command.Command cmd1 = ((global::encode.command.Command) (commands[_g11++]) );
						int cmd_code = ((int) (cmd1.cmd_prefix_[0]) );
						int lennumextra = ((int) (((uint) (((uint) (( ((uint) (cmd1.cmd_extra_[0]) ) >> 16 )) )) )) );
						global::Array<uint> lenextra = cmd1.cmd_extra_;
						global::encode.Write_bits.WriteBits(((int) (((uint) (((uint[]) (cmd_depth) )[cmd_code]) )) ), ((uint) (((uint[]) (cmd_bits) )[cmd_code]) ), storage_ix, storage);
						if (( lennumextra >= 32 )) {
							global::encode.Write_bits.WriteBits(( lennumextra - 32 ), lenextra[0], storage_ix, storage);
						}
						
						global::encode.Write_bits.WriteBits(( (( lennumextra < 32 )) ? (lennumextra) : (32) ), lenextra[1], storage_ix, storage);
						{
							int _g31 = 0;
							int _g21 = cmd1.insert_len_;
							while (( _g31 < _g21 )) {
								 ++ _g31;
								uint literal = ((uint) (((uint[]) (input) )[( pos & mask )]) );
								global::encode.Write_bits.WriteBits(((int) (((uint) (((uint[]) (lit_depth) )[((int) (literal) )]) )) ), ((uint) (((uint[]) (lit_bits) )[((int) (literal) )]) ), storage_ix, storage);
								 ++ pos;
							}
							
						}
						
						pos += cmd1.copy_len_;
						if (( ( cmd1.copy_len_ > 0 ) && ((bool) (( cmd1.cmd_prefix_[0] >= 128 )) ) )) {
							int dist_code = ((int) (cmd1.dist_prefix_[0]) );
							int distnumextra = ((int) (((uint) (((uint) (( ((uint) (cmd1.dist_extra_[0]) ) >> 24 )) )) )) );
							int distextra = ((int) (((uint) (( cmd1.dist_extra_[0] & 16777215 )) )) );
							global::encode.Write_bits.WriteBits(((int) (((uint) (((uint[]) (dist_depth) )[dist_code]) )) ), ((uint) (((uint[]) (dist_bits) )[dist_code]) ), storage_ix, storage);
							global::encode.Write_bits.WriteBits(distnumextra, ((uint) (distextra) ), storage_ix, storage);
						}
						
					}
					
				}
				
				if (is_last) {
					global::encode.Brotli_bit_stream.JumpToByteBoundary(storage_ix, storage);
				}
				
				return true;
			}
		}
		
		
		public static bool StoreUncompressedMetaBlock(bool final_block, uint[] input, int position, int mask, int len, global::Array<int> storage_ix, uint[] storage, int storage_off) {
			unchecked {
				if ( ! (global::encode.Brotli_bit_stream.StoreUncompressedMetaBlockHeader(len, storage_ix, storage)) ) {
					return false;
				}
				
				global::encode.Brotli_bit_stream.JumpToByteBoundary(storage_ix, storage);
				int masked_pos = ( position & mask );
				if (( ( masked_pos + len ) > ( mask + 1 ) )) {
					int len1 = ( ( mask + 1 ) - masked_pos );
					global::DefaultFunctions.memcpy_UInt(storage, ( storage_ix[0] >> 3 ), input, masked_pos, len1);
					storage_ix[0] += ( len1 << 3 );
					len -= len1;
					masked_pos = 0;
				}
				
				global::DefaultFunctions.memcpy_UInt(storage, ( storage_ix[0] >> 3 ), input, masked_pos, len);
				global::encode.Write_bits.WriteBitsPrepareStorage(storage_ix[0] += ( len << 3 ), storage);
				if (final_block) {
					global::encode.Write_bits.WriteBits(1, ((uint) (1) ), storage_ix, storage);
					global::encode.Write_bits.WriteBits(1, ((uint) (1) ), storage_ix, storage);
					global::encode.Brotli_bit_stream.JumpToByteBoundary(storage_ix, storage);
				}
				
				return true;
			}
		}
		
		
	}
}


