// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace encode {
	public class Bit_cost : global::haxe.lang.HxObject {
		
		public Bit_cost(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Bit_cost() {
			global::encode.Bit_cost.__hx_ctor_encode_Bit_cost(this);
		}
		
		
		public static void __hx_ctor_encode_Bit_cost(global::encode.Bit_cost __hx_this) {
		}
		
		
		public static double BitsEntropy(int[] population, int population_off, int size) {
			unchecked {
				int sum = 0;
				double retval = ((double) (0) );
				int population_end_off = ( population_off + size );
				int p = default(int);
				if (( (( size & 1 )) > 0 )) {
					p = ((int[]) (population) )[population_off++];
					sum = p;
					retval -= ( p * global::encode.Fast_log.FastLog2(p) );
				}
				
				while (( population_off < population_end_off )) {
					p = ((int[]) (population) )[population_off++];
					sum += p;
					retval -= ( p * global::encode.Fast_log.FastLog2(p) );
					p = ((int[]) (population) )[population_off++];
					sum += p;
					retval -= ( p * global::encode.Fast_log.FastLog2(p) );
				}
				
				if (( sum > 0 )) {
					retval += ( sum * global::encode.Fast_log.FastLog2(sum) );
				}
				
				if (( retval < sum )) {
					retval = ((double) (sum) );
				}
				
				return retval;
			}
		}
		
		
		public static double PopulationCost(global::encode.histogram.Histogram histogram) {
			unchecked {
				int kSize = ( ((int[]) (histogram.data_) ) as global::System.Array ).Length;
				if (( histogram.total_count_ == 0 )) {
					return ((double) (12) );
				}
				
				int count = 0;
				{
					int _g1 = 0;
					while (( _g1 < kSize )) {
						if (( ((int[]) (histogram.data_) )[_g1++] > 0 )) {
							 ++ count;
						}
						
					}
					
				}
				
				if (( count == 1 )) {
					return ((double) (12) );
				}
				
				if (( count == 2 )) {
					return ((double) (( 20 + histogram.total_count_ )) );
				}
				
				double bits = ((double) (0) );
				uint[] depth = global::FunctionMalloc.mallocUInt(kSize);
				if (( count <= 4 )) {
					global::encode.Entropy_encode.CreateHuffmanTree(histogram.data_, 0, kSize, 15, depth, 0);
					{
						int _g11 = 0;
						while (( _g11 < kSize )) {
							int i = _g11++;
							bits = ((double) (( ((uint) (( ((uint) (((uint[]) (depth) )[i]) ) * ((int[]) (histogram.data_) )[i] )) ) + bits )) );
						}
						
					}
					
					if (( count == 3 )) {
						return ( bits + 28 );
					}
					else {
						return ( bits + 37 );
					}
					
				}
				
				int max_depth = 1;
				int[] depth_histo = global::FunctionMalloc.mallocInt(18);
				double log2total = global::encode.Fast_log.FastLog2(histogram.total_count_);
				int i1 = 0;
				while (( i1 < kSize )) {
					if (( ((int[]) (histogram.data_) )[i1] > 0 )) {
						double log2p = ( log2total - global::encode.Fast_log.FastLog2(((int[]) (histogram.data_) )[i1]) );
						int depth1 = ((int) (( log2p + 0.5 )) );
						bits += ( ((int[]) (histogram.data_) )[i1] * log2p );
						if (( depth1 > 15 )) {
							depth1 = 15;
						}
						
						if (( depth1 > max_depth )) {
							max_depth = depth1;
						}
						
						{
							int _g = depth1;
							((int[]) (depth_histo) )[_g] = ( ((int) (((int[]) (depth_histo) )[_g]) ) + 1 );
						}
						
						 ++ i1;
					}
					else {
						int reps = 1;
						int k = ( i1 + 1 );
						while (( ( k < kSize ) && ( ((int[]) (histogram.data_) )[k] == 0 ) )) {
							 ++ reps;
							 ++ k;
						}
						
						i1 += reps;
						if (( i1 == kSize )) {
							break;
						}
						
						if (( reps < 3 )) {
							((int[]) (depth_histo) )[0] = ( ((int) (((int[]) (depth_histo) )[0]) ) + reps );
						}
						else {
							reps -= 2;
							while (( reps > 0 )) {
								((int[]) (depth_histo) )[17] = ( ((int) (((int[]) (depth_histo) )[17]) ) + 1 );
								bits += ((double) (3) );
								reps >>= 3;
							}
							
						}
						
					}
					
				}
				
				bits += ((double) (( 18 + ( 2 * max_depth ) )) );
				bits += global::encode.Bit_cost.BitsEntropy(depth_histo, 0, 18);
				return bits;
			}
		}
		
		
	}
}


