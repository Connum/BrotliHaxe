// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace encode {
	public class Cluster : global::haxe.lang.HxObject {
		
		public Cluster(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Cluster() {
			global::encode.Cluster.__hx_ctor_encode_Cluster(this);
		}
		
		
		public static void __hx_ctor_encode_Cluster(global::encode.Cluster __hx_this) {
		}
		
		
		public static int HistogramPairComparator(global::encode.cluster.HistogramPair p1, global::encode.cluster.HistogramPair p2) {
			unchecked {
				if (( p1.cost_diff != p2.cost_diff )) {
					if (( p1.cost_diff > p2.cost_diff )) {
						return 1;
					}
					else {
						return -1;
					}
					
				}
				
				if (( global::System.Math.Abs(((double) (( p1.idx1 - p1.idx2 )) )) > global::System.Math.Abs(((double) (( p2.idx1 - p2.idx2 )) )) )) {
					return 1;
				}
				else {
					return -1;
				}
				
			}
		}
		
		
		public static double ClusterCostDiff(int size_a, int size_b) {
			int size_c = ( size_a + size_b );
			return ( ( ( size_a * global::encode.Fast_log.FastLog2(size_a) ) + ( size_b * global::encode.Fast_log.FastLog2(size_b) ) ) - ( size_c * global::encode.Fast_log.FastLog2(size_c) ) );
		}
		
		
		public static void CompareAndPushToHeap(global::Array<object> @out, int[] cluster_size, int idx1, int idx2, global::encode.BinaryHeap<object> pairs) {
			if (( idx1 == idx2 )) {
				return;
			}
			
			if (( idx2 < idx1 )) {
				int t = idx2;
				idx2 = idx1;
				idx1 = t;
			}
			
			bool store_pair = false;
			global::encode.cluster.HistogramPair p = new global::encode.cluster.HistogramPair();
			p.idx1 = idx1;
			p.idx2 = idx2;
			p.valid = true;
			p.cost_diff = ( 0.5 * global::encode.Cluster.ClusterCostDiff(((int) (((int[]) (cluster_size) )[idx1]) ), ((int) (((int[]) (cluster_size) )[idx2]) )) );
			p.cost_diff = ( (p.cost_diff -= ((global::encode.histogram.Histogram) (@out[idx1]) ).bit_cost_) - ((global::encode.histogram.Histogram) (@out[idx2]) ).bit_cost_ );
			if (( ((global::encode.histogram.Histogram) (@out[idx1]) ).total_count_ == 0 )) {
				p.cost_combo = ((global::encode.histogram.Histogram) (@out[idx2]) ).bit_cost_;
				store_pair = true;
			}
			else if (( ((global::encode.histogram.Histogram) (@out[idx2]) ).total_count_ == 0 )) {
				p.cost_combo = ((global::encode.histogram.Histogram) (@out[idx1]) ).bit_cost_;
				store_pair = true;
			}
			else {
				double threshold = ( (( pairs.size() == 0 )) ? (1e99) : (global::System.Math.Max(((double) (0.0) ), ((double) (global::haxe.lang.Runtime.toDouble(global::haxe.lang.Runtime.getField(pairs.arr[0], "cost_diff", 1698677367, true))) ))) );
				global::encode.histogram.Histogram combo = new global::encode.histogram.Histogram(((int) (( ((int[]) (((global::encode.histogram.Histogram) (@out[idx1]) ).data_) ) as global::System.Array ).Length) ));
				combo.bit_cost_ = ((global::encode.histogram.Histogram) (@out[idx1]) ).bit_cost_;
				{
					int _g1 = 0;
					int _g = ( ((int[]) (((global::encode.histogram.Histogram) (@out[idx1]) ).data_) ) as global::System.Array ).Length;
					while (( _g1 < _g )) {
						int a = _g1++;
						((int[]) (combo.data_) )[a] = ((int[]) (((global::encode.histogram.Histogram) (@out[idx1]) ).data_) )[a];
					}
					
				}
				
				combo.kDataSize = ((global::encode.histogram.Histogram) (@out[idx1]) ).kDataSize;
				combo.total_count_ = ((global::encode.histogram.Histogram) (@out[idx1]) ).total_count_;
				combo.AddHistogram(((global::encode.histogram.Histogram) (@out[idx2]) ));
				double cost_combo = global::encode.Bit_cost.PopulationCost(combo);
				if (( cost_combo < ( threshold - p.cost_diff ) )) {
					p.cost_combo = cost_combo;
					store_pair = true;
				}
				
			}
			
			if (store_pair) {
				p.cost_diff += p.cost_combo;
				pairs.push(p);
			}
			
		}
		
		
		public static void HistogramCombine(global::Array<object> @out, int[] cluster_size, int[] symbols, int symbols_off, int symbols_size, int max_clusters) {
			unchecked {
				double cost_diff_threshold = 0.0;
				int min_cluster_size = 1;
				global::Array<int> all_symbols = new global::Array<int>();
				global::Array<int> clusters = new global::Array<int>();
				{
					int _g1 = 0;
					while (( _g1 < symbols_size )) {
						int i = _g1++;
						if (( all_symbols.indexOf(((int) (((int[]) (symbols) )[( symbols_off + i )]) ), default(global::haxe.lang.Null<int>)) == -1 )) {
							if (( all_symbols.indexOf(((int) (((int[]) (symbols) )[( symbols_off + i )]) ), default(global::haxe.lang.Null<int>)) == -1 )) {
								all_symbols.push(((int) (((int[]) (symbols) )[( symbols_off + i )]) ));
							}
							
							clusters.push(((int) (((int[]) (symbols) )[( symbols_off + i )]) ));
						}
						
					}
					
				}
				
				global::encode.BinaryHeap<object> pairs = new global::encode.BinaryHeap<object>();
				{
					int _g11 = 0;
					int _g = clusters.length;
					while (( _g11 < _g )) {
						int idx1 = _g11++;
						{
							int _g3 = ( idx1 + 1 );
							int _g2 = clusters.length;
							while (( _g3 < _g2 )) {
								global::encode.Cluster.CompareAndPushToHeap(@out, cluster_size, clusters[idx1], clusters[_g3++], pairs);
							}
							
						}
						
					}
					
				}
				
				while (( clusters.length > min_cluster_size )) {
					if (( global::haxe.lang.Runtime.compare(global::haxe.lang.Runtime.getField(pairs.arr[0], "cost_diff", 1698677367, true), cost_diff_threshold) >= 0 )) {
						cost_diff_threshold = 1e99;
						min_cluster_size = max_clusters;
						continue;
					}
					
					int best_idx1 = ((int) (global::haxe.lang.Runtime.toInt(global::haxe.lang.Runtime.getField(pairs.arr[0], "idx1", 1169404244, true))) );
					int best_idx2 = ((int) (global::haxe.lang.Runtime.toInt(global::haxe.lang.Runtime.getField(pairs.arr[0], "idx2", 1169404245, true))) );
					((global::encode.histogram.Histogram) (@out[best_idx1]) ).AddHistogram(((global::encode.histogram.Histogram) (@out[best_idx2]) ));
					((global::encode.histogram.Histogram) (@out[best_idx1]) ).bit_cost_ = ((double) (global::haxe.lang.Runtime.toDouble(global::haxe.lang.Runtime.getField(pairs.arr[0], "cost_combo", 589325724, true))) );
					((int[]) (cluster_size) )[best_idx1] = ( ((int) (((int[]) (cluster_size) )[best_idx1]) ) + ((int) (((int[]) (cluster_size) )[best_idx2]) ) );
					{
						int _g12 = 0;
						while (( _g12 < symbols_size )) {
							int i1 = _g12++;
							if (( ((int) (((int[]) (symbols) )[( symbols_off + i1 )]) ) == best_idx2 )) {
								((int[]) (symbols) )[( symbols_off + i1 )] = best_idx1;
							}
							
						}
						
					}
					
					{
						int _g13 = 0;
						int _g4 = clusters.length;
						while (( _g13 < _g4 )) {
							int i2 = _g13++;
							if (( clusters[i2] >= best_idx2 )) {
								clusters[i2] = clusters[( i2 + 1 )];
							}
							
						}
						
					}
					
					clusters.pop();
					{
						int _g14 = 0;
						int _g5 = pairs.size();
						while (( _g14 < _g5 )) {
							global::encode.cluster.HistogramPair p = ((global::encode.cluster.HistogramPair) (pairs.arr[_g14++]) );
							if (( ( ( ( p.idx1 == best_idx1 ) || ( p.idx2 == best_idx1 ) ) || ( p.idx1 == best_idx2 ) ) || ( p.idx2 == best_idx2 ) )) {
								p.valid = false;
							}
							
						}
						
					}
					
					while (( ( pairs.size() != 0 ) && ( ! (global::haxe.lang.Runtime.toBool(global::haxe.lang.Runtime.getField(pairs.arr[0], "valid", 834172156, true))) ) )) {
						pairs.pop();
					}
					
					{
						int _g15 = 0;
						int _g6 = clusters.length;
						while (( _g15 < _g6 )) {
							global::encode.Cluster.CompareAndPushToHeap(@out, cluster_size, best_idx1, clusters[_g15++], pairs);
						}
						
					}
					
				}
				
			}
		}
		
		
		public static double HistogramBitCostDistance(global::encode.histogram.Histogram histogram, global::encode.histogram.Histogram candidate) {
			if (( histogram.total_count_ == 0 )) {
				return 0.0;
			}
			
			global::encode.histogram.Histogram tmp = new global::encode.histogram.Histogram(((int) (( ((int[]) (histogram.data_) ) as global::System.Array ).Length) ));
			tmp.bit_cost_ = histogram.bit_cost_;
			{
				int _g1 = 0;
				int _g = ( ((int[]) (histogram.data_) ) as global::System.Array ).Length;
				while (( _g1 < _g )) {
					int a = _g1++;
					((int[]) (tmp.data_) )[a] = ((int[]) (histogram.data_) )[a];
				}
				
			}
			
			tmp.kDataSize = histogram.kDataSize;
			tmp.total_count_ = histogram.total_count_;
			tmp.AddHistogram(candidate);
			return ( global::encode.Bit_cost.PopulationCost(tmp) - candidate.bit_cost_ );
		}
		
		
		public static void HistogramRemap(global::Array<object> input, int in_size, global::Array<object> output, int[] symbols) {
			unchecked {
				global::Array<int> all_symbols = new global::Array<int>();
				{
					int _g1 = 0;
					while (( _g1 < in_size )) {
						int i = _g1++;
						if (( all_symbols.indexOf(((int) (((int[]) (symbols) )[i]) ), default(global::haxe.lang.Null<int>)) == -1 )) {
							all_symbols.push(((int) (((int[]) (symbols) )[i]) ));
						}
						
					}
					
				}
				
				{
					int _g11 = 0;
					while (( _g11 < in_size )) {
						int i1 = _g11++;
						int best_out = ( (( i1 == 0 )) ? (((int) (((int[]) (symbols) )[0]) )) : (((int) (((int[]) (symbols) )[( i1 - 1 )]) )) );
						double best_bits = global::encode.Cluster.HistogramBitCostDistance(((global::encode.histogram.Histogram) (input[i1]) ), ((global::encode.histogram.Histogram) (output[best_out]) ));
						{
							int _g3 = 0;
							int _g2 = all_symbols.length;
							while (( _g3 < _g2 )) {
								int k = _g3++;
								double cur_bits = global::encode.Cluster.HistogramBitCostDistance(((global::encode.histogram.Histogram) (input[i1]) ), ((global::encode.histogram.Histogram) (output[all_symbols[k]]) ));
								if (( cur_bits < best_bits )) {
									best_bits = cur_bits;
									best_out = all_symbols[k];
								}
								
							}
							
						}
						
						((int[]) (symbols) )[i1] = best_out;
					}
					
				}
				
				{
					int _g12 = 0;
					int _g = all_symbols.length;
					while (( _g12 < _g )) {
						((global::encode.histogram.Histogram) (output[all_symbols[_g12++]]) ).Clear();
					}
					
				}
				
				{
					int _g13 = 0;
					while (( _g13 < in_size )) {
						int i2 = _g13++;
						((global::encode.histogram.Histogram) (output[((int) (((int[]) (symbols) )[i2]) )]) ).AddHistogram(((global::encode.histogram.Histogram) (input[i2]) ));
					}
					
				}
				
			}
		}
		
		
		public static void HistogramReindex(global::Array<object> @out, int[] symbols) {
			global::Array<object> tmp = new global::Array<object>();
			{
				int _g1 = 0;
				int _g = @out.length;
				while (( _g1 < _g )) {
					int i = _g1++;
					tmp[i] = new global::encode.histogram.Histogram(((int) (( ((int[]) (((global::encode.histogram.Histogram) (@out[i]) ).data_) ) as global::System.Array ).Length) ));
					((global::encode.histogram.Histogram) (tmp[i]) ).bit_cost_ = ((global::encode.histogram.Histogram) (@out[i]) ).bit_cost_;
					{
						int _g3 = 0;
						int _g2 = ( ((int[]) (((global::encode.histogram.Histogram) (@out[i]) ).data_) ) as global::System.Array ).Length;
						while (( _g3 < _g2 )) {
							int a = _g3++;
							((int[]) (((global::encode.histogram.Histogram) (tmp[i]) ).data_) )[a] = ((int[]) (((global::encode.histogram.Histogram) (@out[i]) ).data_) )[a];
						}
						
					}
					
					((global::encode.histogram.Histogram) (tmp[i]) ).kDataSize = ((global::encode.histogram.Histogram) (@out[i]) ).kDataSize;
					((global::encode.histogram.Histogram) (tmp[i]) ).total_count_ = ((global::encode.histogram.Histogram) (@out[i]) ).total_count_;
				}
				
			}
			
			global::haxe.ds.IntMap<int> new_index = new global::haxe.ds.IntMap<int>();
			int next_index = 0;
			{
				int _g11 = 0;
				int _g4 = ( ((int[]) (symbols) ) as global::System.Array ).Length;
				while (( _g11 < _g4 )) {
					int i1 = _g11++;
					if (( new_index.exists(((int) (((int[]) (symbols) )[i1]) )) == false )) {
						new_index.@set(((int) (((int[]) (symbols) )[i1]) ), next_index);
						((global::encode.histogram.Histogram) (@out[next_index]) ).bit_cost_ = ((global::encode.histogram.Histogram) (tmp[((int) (((int[]) (symbols) )[i1]) )]) ).bit_cost_;
						{
							int _g31 = 0;
							int _g21 = ( ((int[]) (((global::encode.histogram.Histogram) (tmp[((int) (((int[]) (symbols) )[i1]) )]) ).data_) ) as global::System.Array ).Length;
							while (( _g31 < _g21 )) {
								int a1 = _g31++;
								((int[]) (((global::encode.histogram.Histogram) (@out[next_index]) ).data_) )[a1] = ((int[]) (((global::encode.histogram.Histogram) (tmp[((int) (((int[]) (symbols) )[i1]) )]) ).data_) )[a1];
							}
							
						}
						
						((global::encode.histogram.Histogram) (@out[next_index]) ).kDataSize = ((global::encode.histogram.Histogram) (tmp[((int) (((int[]) (symbols) )[i1]) )]) ).kDataSize;
						((global::encode.histogram.Histogram) (@out[next_index]) ).total_count_ = ((global::encode.histogram.Histogram) (tmp[((int) (((int[]) (symbols) )[i1]) )]) ).total_count_;
						 ++ next_index;
					}
					
				}
				
			}
			
			while (( @out.length > next_index )) {
				@out.pop();
			}
			
			{
				int _g12 = 0;
				int _g5 = ( ((int[]) (symbols) ) as global::System.Array ).Length;
				while (( _g12 < _g5 )) {
					int i2 = _g12++;
					((int[]) (symbols) )[i2] = (new_index.@get(((int) (((int[]) (symbols) )[i2]) ))).@value;
				}
				
			}
			
		}
		
		
		public static void ClusterHistograms(global::Array<object> input, int num_contexts, int num_blocks, int max_histograms, global::Array<object> output, int outputInt, int[] histogram_symbols) {
			unchecked {
				int in_size = ( num_contexts * num_blocks );
				int[] cluster_size = ((int[]) (new int[in_size]) );
				global::DefaultFunctions.memset_Int(cluster_size, 0, 1, in_size);
				while (( output.length > in_size )) {
					output.pop();
				}
				
				{
					int _g1 = 0;
					while (( _g1 < in_size )) {
						output[_g1++] = new global::encode.histogram.Histogram(((int) (outputInt) ));
					}
					
				}
				
				{
					int _g11 = 0;
					while (( _g11 < in_size )) {
						int i = _g11++;
						{
							int _g3 = 0;
							int _g2 = ( ((int[]) (((global::encode.histogram.Histogram) (input[i]) ).data_) ) as global::System.Array ).Length;
							while (( _g3 < _g2 )) {
								int a = _g3++;
								((int[]) (((global::encode.histogram.Histogram) (output[i]) ).data_) )[a] = ((int[]) (((global::encode.histogram.Histogram) (input[i]) ).data_) )[a];
							}
							
						}
						
						((global::encode.histogram.Histogram) (output[i]) ).kDataSize = ((global::encode.histogram.Histogram) (input[i]) ).kDataSize;
						((global::encode.histogram.Histogram) (output[i]) ).total_count_ = ((global::encode.histogram.Histogram) (input[i]) ).total_count_;
						((global::encode.histogram.Histogram) (output[i]) ).bit_cost_ = global::encode.Bit_cost.PopulationCost(((global::encode.histogram.Histogram) (input[i]) ));
						((int[]) (histogram_symbols) )[i] = i;
					}
					
				}
				
				int i1 = 0;
				while (( i1 < in_size )) {
					global::encode.Cluster.HistogramCombine(output, cluster_size, histogram_symbols, i1, ((int) (global::System.Math.Min(((double) (( in_size - i1 )) ), ((double) (64) ))) ), max_histograms);
					i1 += 64;
				}
				
				global::encode.Cluster.HistogramCombine(output, cluster_size, histogram_symbols, 0, in_size, max_histograms);
				global::encode.Cluster.HistogramRemap(input, in_size, output, histogram_symbols);
				global::encode.Cluster.HistogramReindex(output, histogram_symbols);
			}
		}
		
		
	}
}


