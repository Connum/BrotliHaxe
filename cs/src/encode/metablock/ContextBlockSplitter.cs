// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace encode.metablock {
	public class ContextBlockSplitter : global::haxe.lang.HxObject {
		
		static ContextBlockSplitter() {
			unchecked {
				global::encode.metablock.ContextBlockSplitter.kMaxBlockTypes = 256;
			}
		}
		
		
		public ContextBlockSplitter(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public ContextBlockSplitter(int HistogramTypeInt, int alphabet_size, int num_contexts, int min_block_size, double split_threshold, int num_symbols, global::encode.metablock.BlockSplit split, global::Array<object> histograms) {
			global::encode.metablock.ContextBlockSplitter.__hx_ctor_encode_metablock_ContextBlockSplitter(this, HistogramTypeInt, alphabet_size, num_contexts, min_block_size, split_threshold, num_symbols, split, histograms);
		}
		
		
		public static void __hx_ctor_encode_metablock_ContextBlockSplitter(global::encode.metablock.ContextBlockSplitter __hx_this, int HistogramTypeInt, int alphabet_size, int num_contexts, int min_block_size, double split_threshold, int num_symbols, global::encode.metablock.BlockSplit split, global::Array<object> histograms) {
			unchecked {
				{
					int[] this1 = null;
					this1 = new int[2];
					__hx_this.last_histogram_ix_ = ((int[]) (this1) );
				}
				
				__hx_this.HistogramTypeInt = HistogramTypeInt;
				__hx_this.alphabet_size_ = alphabet_size;
				__hx_this.num_contexts_ = num_contexts;
				__hx_this.max_block_types_ = ( global::encode.metablock.ContextBlockSplitter.kMaxBlockTypes / num_contexts );
				__hx_this.min_block_size_ = min_block_size;
				__hx_this.split_threshold_ = split_threshold;
				__hx_this.num_blocks_ = 0;
				__hx_this.split_ = split;
				__hx_this.histograms_ = histograms;
				__hx_this.target_block_size_ = min_block_size;
				__hx_this.block_size_ = 0;
				__hx_this.curr_histogram_ix_ = 0;
				__hx_this.last_entropy_ = global::FunctionMalloc.mallocFloat(( 2 * num_contexts ));
				__hx_this.merge_last_count_ = 0;
				int max_num_types = ((int) (global::System.Math.Min(((double) (( ( num_symbols / min_block_size ) + 1 )) ), ((double) (( __hx_this.max_block_types_ + 1 )) ))) );
				__hx_this.split_.lengths = new global::Array<int>();
				__hx_this.split_.types = new global::Array<int>();
				{
					int _g1 = 0;
					int _g = ( max_num_types * num_contexts );
					while (( _g1 < _g )) {
						 ++ _g1;
						__hx_this.histograms_.push(new global::encode.histogram.Histogram(((int) (HistogramTypeInt) )));
					}
					
				}
				
				{
					((int[]) (__hx_this.last_histogram_ix_) )[1] = 0;
					((int[]) (__hx_this.last_histogram_ix_) )[0] = 0;
				}
				
			}
		}
		
		
		public static int kMaxBlockTypes;
		
		public virtual void AddSymbol(int symbol, int context) {
			((global::encode.histogram.Histogram) (this.histograms_[( this.curr_histogram_ix_ + context )]) ).Add1(symbol);
			 ++ this.block_size_;
			if (( this.block_size_ == this.target_block_size_ )) {
				this.FinishBlock(false);
			}
			
		}
		
		
		public virtual void FinishBlock(bool is_final) {
			unchecked {
				if (( this.block_size_ < this.min_block_size_ )) {
					this.block_size_ = this.min_block_size_;
				}
				
				if (( this.num_blocks_ == 0 )) {
					this.split_.lengths[0] = this.block_size_;
					this.split_.types[0] = 0;
					{
						int _g1 = 0;
						int _g = this.num_contexts_;
						while (( _g1 < _g )) {
							int i = _g1++;
							((double[]) (this.last_entropy_) )[i] = global::encode.Bit_cost.BitsEntropy(((global::encode.histogram.Histogram) (this.histograms_[i]) ).data_, 0, this.alphabet_size_);
							((double[]) (this.last_entropy_) )[( this.num_contexts_ + i )] = ((double[]) (this.last_entropy_) )[i];
						}
						
					}
					
					 ++ this.num_blocks_;
					 ++ this.split_.num_types;
					this.curr_histogram_ix_ += this.num_contexts_;
					this.block_size_ = 0;
				}
				else if (( this.block_size_ > 0 )) {
					double[] entropy = ((double[]) (new double[this.num_contexts_]) );
					global::encode.histogram.Histogram[] combined_histo = ((global::encode.histogram.Histogram[]) (new global::encode.histogram.Histogram[( 2 * this.num_contexts_ )]) );
					{
						int _g11 = 0;
						int _g2 = ( 2 * this.num_contexts_ );
						while (( _g11 < _g2 )) {
							((global::encode.histogram.Histogram[]) (combined_histo) )[_g11++] = new global::encode.histogram.Histogram(((int) (this.HistogramTypeInt) ));
						}
						
					}
					
					double[] combined_entropy = ((double[]) (new double[( 2 * this.num_contexts_ )]) );
					global::Array<double> diff = new global::Array<double>(new double[]{0.0, 0.0});
					{
						int _g12 = 0;
						int _g3 = this.num_contexts_;
						while (( _g12 < _g3 )) {
							int i1 = _g12++;
							int curr_histo_ix = ( this.curr_histogram_ix_ + i1 );
							((double[]) (entropy) )[i1] = global::encode.Bit_cost.BitsEntropy(((global::encode.histogram.Histogram) (this.histograms_[curr_histo_ix]) ).data_, 0, this.alphabet_size_);
							{
								int _g21 = 0;
								while (( _g21 < 2 )) {
									int j = _g21++;
									int jx = ( ( j * this.num_contexts_ ) + i1 );
									int last_histogram_ix = ( ((int[]) (this.last_histogram_ix_) )[j] + i1 );
									((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[jx]) ).bit_cost_ = ((global::encode.histogram.Histogram) (this.histograms_[curr_histo_ix]) ).bit_cost_;
									{
										int _g4 = 0;
										int _g31 = ( ((int[]) (((global::encode.histogram.Histogram) (this.histograms_[curr_histo_ix]) ).data_) ) as global::System.Array ).Length;
										while (( _g4 < _g31 )) {
											int a = _g4++;
											((int[]) (((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[jx]) ).data_) )[a] = ((int[]) (((global::encode.histogram.Histogram) (this.histograms_[curr_histo_ix]) ).data_) )[a];
										}
										
									}
									
									((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[jx]) ).kDataSize = ((global::encode.histogram.Histogram) (this.histograms_[curr_histo_ix]) ).kDataSize;
									((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[jx]) ).total_count_ = ((global::encode.histogram.Histogram) (this.histograms_[curr_histo_ix]) ).total_count_;
									((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[jx]) ).AddHistogram(((global::encode.histogram.Histogram) (this.histograms_[last_histogram_ix]) ));
									((double[]) (combined_entropy) )[jx] = global::encode.Bit_cost.BitsEntropy(((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[jx]) ).data_, 0, this.alphabet_size_);
									diff[j] += ( ( ((double) (((double[]) (combined_entropy) )[jx]) ) - ((double) (((double[]) (entropy) )[i1]) ) ) - ((double[]) (this.last_entropy_) )[jx] );
								}
								
							}
							
						}
						
					}
					
					if (( ( ( this.split_.num_types < this.max_block_types_ ) && ( diff[0] > this.split_threshold_ ) ) && ( diff[1] > this.split_threshold_ ) )) {
						this.split_.lengths[this.num_blocks_] = this.block_size_;
						this.split_.types[this.num_blocks_] = this.split_.num_types;
						((int[]) (this.last_histogram_ix_) )[1] = ((int[]) (this.last_histogram_ix_) )[0];
						((int[]) (this.last_histogram_ix_) )[0] = ( this.split_.num_types * this.num_contexts_ );
						{
							int _g13 = 0;
							int _g5 = this.num_contexts_;
							while (( _g13 < _g5 )) {
								int i2 = _g13++;
								((double[]) (this.last_entropy_) )[( this.num_contexts_ + i2 )] = ((double[]) (this.last_entropy_) )[i2];
								((double[]) (this.last_entropy_) )[i2] = ((double) (((double[]) (entropy) )[i2]) );
							}
							
						}
						
						 ++ this.num_blocks_;
						 ++ this.split_.num_types;
						this.curr_histogram_ix_ += this.num_contexts_;
						this.block_size_ = 0;
						this.merge_last_count_ = 0;
						this.target_block_size_ = this.min_block_size_;
					}
					else if (( diff[1] < ( diff[0] - 20.0 ) )) {
						this.split_.lengths[this.num_blocks_] = this.block_size_;
						this.split_.types[this.num_blocks_] = this.split_.types[( this.num_blocks_ - 2 )];
						int t = ((int[]) (this.last_histogram_ix_) )[0];
						((int[]) (this.last_histogram_ix_) )[0] = ((int[]) (this.last_histogram_ix_) )[1];
						((int[]) (this.last_histogram_ix_) )[1] = t;
						{
							int _g14 = 0;
							int _g6 = this.num_contexts_;
							while (( _g14 < _g6 )) {
								int i3 = _g14++;
								((global::encode.histogram.Histogram) (this.histograms_[( ((int[]) (this.last_histogram_ix_) )[0] + i3 )]) ).bit_cost_ = ((global::encode.histogram.Histogram[]) (combined_histo) )[( this.num_contexts_ + i3 )].bit_cost_;
								{
									int _g32 = 0;
									int _g22 = ( ((int[]) (((global::encode.histogram.Histogram[]) (combined_histo) )[( this.num_contexts_ + i3 )].data_) ) as global::System.Array ).Length;
									while (( _g32 < _g22 )) {
										int a1 = _g32++;
										((int[]) (((global::encode.histogram.Histogram) (this.histograms_[( ((int[]) (this.last_histogram_ix_) )[0] + i3 )]) ).data_) )[a1] = ((int[]) (((global::encode.histogram.Histogram[]) (combined_histo) )[( this.num_contexts_ + i3 )].data_) )[a1];
									}
									
								}
								
								((global::encode.histogram.Histogram) (this.histograms_[( ((int[]) (this.last_histogram_ix_) )[0] + i3 )]) ).kDataSize = ((global::encode.histogram.Histogram[]) (combined_histo) )[( this.num_contexts_ + i3 )].kDataSize;
								((global::encode.histogram.Histogram) (this.histograms_[( ((int[]) (this.last_histogram_ix_) )[0] + i3 )]) ).total_count_ = ((global::encode.histogram.Histogram[]) (combined_histo) )[( this.num_contexts_ + i3 )].total_count_;
								((double[]) (this.last_entropy_) )[( this.num_contexts_ + i3 )] = ((double[]) (this.last_entropy_) )[i3];
								((double[]) (this.last_entropy_) )[i3] = ((double[]) (combined_entropy) )[( this.num_contexts_ + i3 )];
								((global::encode.histogram.Histogram) (this.histograms_[( this.curr_histogram_ix_ + i3 )]) ).Clear();
							}
							
						}
						
						 ++ this.num_blocks_;
						this.block_size_ = 0;
						this.merge_last_count_ = 0;
						this.target_block_size_ = this.min_block_size_;
					}
					else {
						this.split_.lengths[( this.num_blocks_ - 1 )] += this.block_size_;
						{
							int _g15 = 0;
							int _g7 = this.num_contexts_;
							while (( _g15 < _g7 )) {
								int i4 = _g15++;
								((global::encode.histogram.Histogram) (this.histograms_[( ((int[]) (this.last_histogram_ix_) )[0] + i4 )]) ).bit_cost_ = ((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[i4]) ).bit_cost_;
								{
									int _g33 = 0;
									int _g23 = ( ((int[]) (((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[i4]) ).data_) ) as global::System.Array ).Length;
									while (( _g33 < _g23 )) {
										int a2 = _g33++;
										((int[]) (((global::encode.histogram.Histogram) (this.histograms_[( ((int[]) (this.last_histogram_ix_) )[0] + i4 )]) ).data_) )[a2] = ((int[]) (((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[i4]) ).data_) )[a2];
									}
									
								}
								
								((global::encode.histogram.Histogram) (this.histograms_[( ((int[]) (this.last_histogram_ix_) )[0] + i4 )]) ).kDataSize = ((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[i4]) ).kDataSize;
								((global::encode.histogram.Histogram) (this.histograms_[( ((int[]) (this.last_histogram_ix_) )[0] + i4 )]) ).total_count_ = ((global::encode.histogram.Histogram) (((global::encode.histogram.Histogram[]) (combined_histo) )[i4]) ).total_count_;
								((double[]) (this.last_entropy_) )[i4] = ((double) (((double[]) (combined_entropy) )[i4]) );
								if (( this.split_.num_types == 1 )) {
									((double[]) (this.last_entropy_) )[( this.num_contexts_ + i4 )] = ((double[]) (this.last_entropy_) )[i4];
								}
								
								((global::encode.histogram.Histogram) (this.histograms_[( this.curr_histogram_ix_ + i4 )]) ).Clear();
							}
							
						}
						
						this.block_size_ = 0;
						if ((  ++ this.merge_last_count_ > 1 )) {
							this.target_block_size_ += this.min_block_size_;
						}
						
					}
					
				}
				
				if (is_final) {
					while (( this.histograms_.length > ( this.split_.num_types * this.num_contexts_ ) )) {
						this.histograms_.pop();
					}
					
					while (( this.split_.types.length > this.num_blocks_ )) {
						this.split_.types.pop();
					}
					
					while (( this.split_.lengths.length > this.num_blocks_ )) {
						this.split_.lengths.pop();
					}
					
				}
				
			}
		}
		
		
		public int HistogramTypeInt;
		
		public int alphabet_size_;
		
		public int num_contexts_;
		
		public int max_block_types_;
		
		public int min_block_size_;
		
		public double split_threshold_;
		
		public int num_blocks_;
		
		public global::encode.metablock.BlockSplit split_;
		
		public global::Array<object> histograms_;
		
		public int target_block_size_;
		
		public int block_size_;
		
		public int curr_histogram_ix_;
		
		public int[] last_histogram_ix_;
		
		public double[] last_entropy_;
		
		public int merge_last_count_;
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 283120498:
					{
						this.merge_last_count_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1546852840:
					{
						this.curr_histogram_ix_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1677147340:
					{
						this.block_size_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1274418078:
					{
						this.target_block_size_ = ((int) (@value) );
						return @value;
					}
					
					
					case 287012064:
					{
						this.num_blocks_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1572466393:
					{
						this.split_threshold_ = ((double) (@value) );
						return @value;
					}
					
					
					case 183570271:
					{
						this.min_block_size_ = ((int) (@value) );
						return @value;
					}
					
					
					case 286079859:
					{
						this.max_block_types_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1451606466:
					{
						this.num_contexts_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1291834546:
					{
						this.alphabet_size_ = ((int) (@value) );
						return @value;
					}
					
					
					case 981779505:
					{
						this.HistogramTypeInt = ((int) (@value) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 283120498:
					{
						this.merge_last_count_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1642336535:
					{
						this.last_entropy_ = ((double[]) (@value) );
						return @value;
					}
					
					
					case 936476748:
					{
						this.last_histogram_ix_ = ((int[]) (@value) );
						return @value;
					}
					
					
					case 1546852840:
					{
						this.curr_histogram_ix_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1677147340:
					{
						this.block_size_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1274418078:
					{
						this.target_block_size_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 14955568:
					{
						this.histograms_ = ((global::Array<object>) (global::Array<object>.__hx_cast<object>(((global::Array) (@value) ))) );
						return @value;
					}
					
					
					case 1067357253:
					{
						this.split_ = ((global::encode.metablock.BlockSplit) (@value) );
						return @value;
					}
					
					
					case 287012064:
					{
						this.num_blocks_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1572466393:
					{
						this.split_threshold_ = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 183570271:
					{
						this.min_block_size_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 286079859:
					{
						this.max_block_types_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1451606466:
					{
						this.num_contexts_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1291834546:
					{
						this.alphabet_size_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 981779505:
					{
						this.HistogramTypeInt = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 283120498:
					{
						return this.merge_last_count_;
					}
					
					
					case 1642336535:
					{
						return this.last_entropy_;
					}
					
					
					case 936476748:
					{
						return this.last_histogram_ix_;
					}
					
					
					case 1546852840:
					{
						return this.curr_histogram_ix_;
					}
					
					
					case 1677147340:
					{
						return this.block_size_;
					}
					
					
					case 1274418078:
					{
						return this.target_block_size_;
					}
					
					
					case 14955568:
					{
						return this.histograms_;
					}
					
					
					case 1067357253:
					{
						return this.split_;
					}
					
					
					case 287012064:
					{
						return this.num_blocks_;
					}
					
					
					case 1572466393:
					{
						return this.split_threshold_;
					}
					
					
					case 183570271:
					{
						return this.min_block_size_;
					}
					
					
					case 286079859:
					{
						return this.max_block_types_;
					}
					
					
					case 1451606466:
					{
						return this.num_contexts_;
					}
					
					
					case 1291834546:
					{
						return this.alphabet_size_;
					}
					
					
					case 981779505:
					{
						return this.HistogramTypeInt;
					}
					
					
					case 1077161946:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "FinishBlock", 1077161946)) );
					}
					
					
					case 1221903417:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "AddSymbol", 1221903417)) );
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 283120498:
					{
						return ((double) (this.merge_last_count_) );
					}
					
					
					case 1546852840:
					{
						return ((double) (this.curr_histogram_ix_) );
					}
					
					
					case 1677147340:
					{
						return ((double) (this.block_size_) );
					}
					
					
					case 1274418078:
					{
						return ((double) (this.target_block_size_) );
					}
					
					
					case 287012064:
					{
						return ((double) (this.num_blocks_) );
					}
					
					
					case 1572466393:
					{
						return this.split_threshold_;
					}
					
					
					case 183570271:
					{
						return ((double) (this.min_block_size_) );
					}
					
					
					case 286079859:
					{
						return ((double) (this.max_block_types_) );
					}
					
					
					case 1451606466:
					{
						return ((double) (this.num_contexts_) );
					}
					
					
					case 1291834546:
					{
						return ((double) (this.alphabet_size_) );
					}
					
					
					case 981779505:
					{
						return ((double) (this.HistogramTypeInt) );
					}
					
					
					default:
					{
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, global::Array dynargs) {
			unchecked {
				switch (hash) {
					case 1077161946:
					{
						this.FinishBlock(global::haxe.lang.Runtime.toBool(dynargs[0]));
						break;
					}
					
					
					case 1221903417:
					{
						this.AddSymbol(((int) (global::haxe.lang.Runtime.toInt(dynargs[0])) ), ((int) (global::haxe.lang.Runtime.toInt(dynargs[1])) ));
						break;
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				return null;
			}
		}
		
		
		public override void __hx_getFields(global::Array<object> baseArr) {
			baseArr.push("merge_last_count_");
			baseArr.push("last_entropy_");
			baseArr.push("last_histogram_ix_");
			baseArr.push("curr_histogram_ix_");
			baseArr.push("block_size_");
			baseArr.push("target_block_size_");
			baseArr.push("histograms_");
			baseArr.push("split_");
			baseArr.push("num_blocks_");
			baseArr.push("split_threshold_");
			baseArr.push("min_block_size_");
			baseArr.push("max_block_types_");
			baseArr.push("num_contexts_");
			baseArr.push("alphabet_size_");
			baseArr.push("HistogramTypeInt");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}


