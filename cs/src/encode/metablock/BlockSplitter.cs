// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace encode.metablock {
	public class BlockSplitter : global::haxe.lang.HxObject {
		
		static BlockSplitter() {
			unchecked {
				global::encode.metablock.BlockSplitter.kMaxBlockTypes = 256;
			}
		}
		
		
		public BlockSplitter(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public BlockSplitter(int HistogramTypeInt, int alphabet_size, int min_block_size, double split_threshold, int num_symbols, global::encode.metablock.BlockSplit split, global::Array<object> histograms) {
			global::encode.metablock.BlockSplitter.__hx_ctor_encode_metablock_BlockSplitter(this, HistogramTypeInt, alphabet_size, min_block_size, split_threshold, num_symbols, split, histograms);
		}
		
		
		public static void __hx_ctor_encode_metablock_BlockSplitter(global::encode.metablock.BlockSplitter __hx_this, int HistogramTypeInt, int alphabet_size, int min_block_size, double split_threshold, int num_symbols, global::encode.metablock.BlockSplit split, global::Array<object> histograms) {
			unchecked {
				__hx_this.last_entropy_ = new global::Array<double>();
				__hx_this.last_histogram_ix_ = new global::Array<int>();
				__hx_this.HistogramTypeInt = HistogramTypeInt;
				__hx_this.alphabet_size_ = alphabet_size;
				__hx_this.min_block_size_ = min_block_size;
				__hx_this.split_threshold_ = split_threshold;
				__hx_this.num_blocks_ = 0;
				__hx_this.split_ = split;
				__hx_this.histograms_ = histograms;
				__hx_this.target_block_size_ = min_block_size;
				__hx_this.block_size_ = 0;
				__hx_this.curr_histogram_ix_ = 0;
				__hx_this.merge_last_count_ = 0;
				int max_num_types = ((int) (global::System.Math.Min(((double) (( ( num_symbols / min_block_size ) + 1 )) ), ((double) (( global::encode.metablock.BlockSplitter.kMaxBlockTypes + 1 )) ))) );
				__hx_this.split_.lengths = new global::Array<int>();
				__hx_this.split_.types = new global::Array<int>();
				{
					int _g1 = 0;
					while (( _g1 < max_num_types )) {
						 ++ _g1;
						__hx_this.histograms_.push(new global::encode.histogram.Histogram(((int) (HistogramTypeInt) )));
					}
					
				}
				
				__hx_this.last_histogram_ix_[1] = 0;
				__hx_this.last_histogram_ix_[0] = 0;
			}
		}
		
		
		public static int kMaxBlockTypes;
		
		public virtual void AddSymbol(int symbol) {
			((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).Add1(symbol);
			 ++ this.block_size_;
			if (( this.block_size_ == this.target_block_size_ )) {
				this.FinishBlock(false);
			}
			
		}
		
		
		public virtual void FinishBlock(bool is_final) {
			unchecked {
				if (( this.block_size_ < this.min_block_size_ )) {
					this.block_size_ = this.min_block_size_;
				}
				
				if (( this.num_blocks_ == 0 )) {
					this.split_.lengths[0] = this.block_size_;
					this.split_.types[0] = 0;
					this.last_entropy_[0] = global::encode.Bit_cost.BitsEntropy(((global::encode.histogram.Histogram) (this.histograms_[0]) ).data_, 0, this.alphabet_size_);
					this.last_entropy_[1] = this.last_entropy_[0];
					 ++ this.num_blocks_;
					 ++ this.split_.num_types;
					 ++ this.curr_histogram_ix_;
					this.block_size_ = 0;
				}
				else if (( this.block_size_ > 0 )) {
					double entropy = global::encode.Bit_cost.BitsEntropy(((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).data_, 0, this.alphabet_size_);
					global::Array<object> combined_histo = new global::Array<object>(new object[]{new global::encode.histogram.Histogram(((int) (this.HistogramTypeInt) )), new global::encode.histogram.Histogram(((int) (this.HistogramTypeInt) ))});
					double[] combined_entropy = global::FunctionMalloc.mallocFloat(2);
					double[] diff = global::FunctionMalloc.mallocFloat(2);
					{
						int _g = 0;
						while (( _g < 2 )) {
							int j = _g++;
							int last_histogram_ix = this.last_histogram_ix_[j];
							((global::encode.histogram.Histogram) (combined_histo[j]) ).bit_cost_ = ((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).bit_cost_;
							{
								int _g2 = 0;
								int _g1 = ( ((int[]) (((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).data_) ) as global::System.Array ).Length;
								while (( _g2 < _g1 )) {
									int a = _g2++;
									((int[]) (((global::encode.histogram.Histogram) (combined_histo[j]) ).data_) )[a] = ((int[]) (((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).data_) )[a];
								}
								
							}
							
							((global::encode.histogram.Histogram) (combined_histo[j]) ).kDataSize = ((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).kDataSize;
							((global::encode.histogram.Histogram) (combined_histo[j]) ).total_count_ = ((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).total_count_;
							((global::encode.histogram.Histogram) (combined_histo[j]) ).AddHistogram(((global::encode.histogram.Histogram) (this.histograms_[last_histogram_ix]) ));
							((double[]) (combined_entropy) )[j] = global::encode.Bit_cost.BitsEntropy(((global::encode.histogram.Histogram) (combined_histo[j]) ).data_, 0, this.alphabet_size_);
							((double[]) (diff) )[j] = ( ( ((double) (((double[]) (combined_entropy) )[j]) ) - entropy ) - this.last_entropy_[j] );
						}
						
					}
					
					if (( ( ( this.split_.num_types < global::encode.metablock.BlockSplitter.kMaxBlockTypes ) && ( ((double) (((double[]) (diff) )[0]) ) > this.split_threshold_ ) ) && ( ((double) (((double[]) (diff) )[1]) ) > this.split_threshold_ ) )) {
						this.split_.lengths[this.num_blocks_] = this.block_size_;
						this.split_.types[this.num_blocks_] = this.split_.num_types;
						this.last_histogram_ix_[1] = this.last_histogram_ix_[0];
						this.last_histogram_ix_[0] = this.split_.num_types;
						this.last_entropy_[1] = this.last_entropy_[0];
						this.last_entropy_[0] = entropy;
						 ++ this.num_blocks_;
						 ++ this.split_.num_types;
						 ++ this.curr_histogram_ix_;
						this.block_size_ = 0;
						this.merge_last_count_ = 0;
						this.target_block_size_ = this.min_block_size_;
					}
					else if (( ((double) (((double[]) (diff) )[1]) ) < ( ((double) (((double[]) (diff) )[0]) ) - 20.0 ) )) {
						this.split_.lengths[this.num_blocks_] = this.block_size_;
						this.split_.types[this.num_blocks_] = this.split_.types[( this.num_blocks_ - 2 )];
						int t = this.last_histogram_ix_[0];
						this.last_histogram_ix_[0] = this.last_histogram_ix_[1];
						this.last_histogram_ix_[1] = t;
						((global::encode.histogram.Histogram) (this.histograms_[this.last_histogram_ix_[0]]) ).bit_cost_ = ((global::encode.histogram.Histogram) (combined_histo[1]) ).bit_cost_;
						{
							int _g11 = 0;
							int _g3 = ( ((int[]) (((global::encode.histogram.Histogram) (combined_histo[1]) ).data_) ) as global::System.Array ).Length;
							while (( _g11 < _g3 )) {
								int a1 = _g11++;
								((int[]) (((global::encode.histogram.Histogram) (this.histograms_[this.last_histogram_ix_[0]]) ).data_) )[a1] = ((int[]) (((global::encode.histogram.Histogram) (combined_histo[1]) ).data_) )[a1];
							}
							
						}
						
						((global::encode.histogram.Histogram) (this.histograms_[this.last_histogram_ix_[0]]) ).kDataSize = ((global::encode.histogram.Histogram) (combined_histo[1]) ).kDataSize;
						((global::encode.histogram.Histogram) (this.histograms_[this.last_histogram_ix_[0]]) ).total_count_ = ((global::encode.histogram.Histogram) (combined_histo[1]) ).total_count_;
						this.last_entropy_[1] = this.last_entropy_[0];
						this.last_entropy_[0] = ((double) (((double[]) (combined_entropy) )[1]) );
						 ++ this.num_blocks_;
						this.block_size_ = 0;
						((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).Clear();
						this.merge_last_count_ = 0;
						this.target_block_size_ = this.min_block_size_;
					}
					else {
						this.split_.lengths[( this.num_blocks_ - 1 )] += this.block_size_;
						((global::encode.histogram.Histogram) (this.histograms_[this.last_histogram_ix_[0]]) ).bit_cost_ = ((global::encode.histogram.Histogram) (combined_histo[0]) ).bit_cost_;
						{
							int _g12 = 0;
							int _g4 = ( ((int[]) (((global::encode.histogram.Histogram) (combined_histo[0]) ).data_) ) as global::System.Array ).Length;
							while (( _g12 < _g4 )) {
								int a2 = _g12++;
								((int[]) (((global::encode.histogram.Histogram) (this.histograms_[this.last_histogram_ix_[0]]) ).data_) )[a2] = ((int[]) (((global::encode.histogram.Histogram) (combined_histo[0]) ).data_) )[a2];
							}
							
						}
						
						((global::encode.histogram.Histogram) (this.histograms_[this.last_histogram_ix_[0]]) ).kDataSize = ((global::encode.histogram.Histogram) (combined_histo[0]) ).kDataSize;
						((global::encode.histogram.Histogram) (this.histograms_[this.last_histogram_ix_[0]]) ).total_count_ = ((global::encode.histogram.Histogram) (combined_histo[0]) ).total_count_;
						this.last_entropy_[0] = ((double) (((double[]) (combined_entropy) )[0]) );
						if (( this.split_.num_types == 1 )) {
							this.last_entropy_[1] = this.last_entropy_[0];
						}
						
						this.block_size_ = 0;
						((global::encode.histogram.Histogram) (this.histograms_[this.curr_histogram_ix_]) ).Clear();
						if ((  ++ this.merge_last_count_ > 1 )) {
							this.target_block_size_ += this.min_block_size_;
						}
						
					}
					
				}
				
				if (is_final) {
					while (( this.histograms_.length > this.split_.num_types )) {
						this.histograms_.pop();
					}
					
					while (( this.split_.types.length > this.num_blocks_ )) {
						this.split_.types.pop();
					}
					
					while (( this.split_.lengths.length > this.num_blocks_ )) {
						this.split_.lengths.pop();
					}
					
				}
				
			}
		}
		
		
		public int HistogramTypeInt;
		
		public int alphabet_size_;
		
		public int min_block_size_;
		
		public double split_threshold_;
		
		public int num_blocks_;
		
		public global::encode.metablock.BlockSplit split_;
		
		public global::Array<object> histograms_;
		
		public int target_block_size_;
		
		public int block_size_;
		
		public int curr_histogram_ix_;
		
		public global::Array<int> last_histogram_ix_;
		
		public global::Array<double> last_entropy_;
		
		public int merge_last_count_;
		
		public override double __hx_setField_f(string field, int hash, double @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 283120498:
					{
						this.merge_last_count_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1546852840:
					{
						this.curr_histogram_ix_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1677147340:
					{
						this.block_size_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1274418078:
					{
						this.target_block_size_ = ((int) (@value) );
						return @value;
					}
					
					
					case 287012064:
					{
						this.num_blocks_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1572466393:
					{
						this.split_threshold_ = ((double) (@value) );
						return @value;
					}
					
					
					case 183570271:
					{
						this.min_block_size_ = ((int) (@value) );
						return @value;
					}
					
					
					case 1291834546:
					{
						this.alphabet_size_ = ((int) (@value) );
						return @value;
					}
					
					
					case 981779505:
					{
						this.HistogramTypeInt = ((int) (@value) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField_f(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_setField(string field, int hash, object @value, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 283120498:
					{
						this.merge_last_count_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1642336535:
					{
						this.last_entropy_ = ((global::Array<double>) (global::Array<object>.__hx_cast<double>(((global::Array) (@value) ))) );
						return @value;
					}
					
					
					case 936476748:
					{
						this.last_histogram_ix_ = ((global::Array<int>) (global::Array<object>.__hx_cast<int>(((global::Array) (@value) ))) );
						return @value;
					}
					
					
					case 1546852840:
					{
						this.curr_histogram_ix_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1677147340:
					{
						this.block_size_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1274418078:
					{
						this.target_block_size_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 14955568:
					{
						this.histograms_ = ((global::Array<object>) (global::Array<object>.__hx_cast<object>(((global::Array) (@value) ))) );
						return @value;
					}
					
					
					case 1067357253:
					{
						this.split_ = ((global::encode.metablock.BlockSplit) (@value) );
						return @value;
					}
					
					
					case 287012064:
					{
						this.num_blocks_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1572466393:
					{
						this.split_threshold_ = ((double) (global::haxe.lang.Runtime.toDouble(@value)) );
						return @value;
					}
					
					
					case 183570271:
					{
						this.min_block_size_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 1291834546:
					{
						this.alphabet_size_ = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					case 981779505:
					{
						this.HistogramTypeInt = ((int) (global::haxe.lang.Runtime.toInt(@value)) );
						return @value;
					}
					
					
					default:
					{
						return base.__hx_setField(field, hash, @value, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 283120498:
					{
						return this.merge_last_count_;
					}
					
					
					case 1642336535:
					{
						return this.last_entropy_;
					}
					
					
					case 936476748:
					{
						return this.last_histogram_ix_;
					}
					
					
					case 1546852840:
					{
						return this.curr_histogram_ix_;
					}
					
					
					case 1677147340:
					{
						return this.block_size_;
					}
					
					
					case 1274418078:
					{
						return this.target_block_size_;
					}
					
					
					case 14955568:
					{
						return this.histograms_;
					}
					
					
					case 1067357253:
					{
						return this.split_;
					}
					
					
					case 287012064:
					{
						return this.num_blocks_;
					}
					
					
					case 1572466393:
					{
						return this.split_threshold_;
					}
					
					
					case 183570271:
					{
						return this.min_block_size_;
					}
					
					
					case 1291834546:
					{
						return this.alphabet_size_;
					}
					
					
					case 981779505:
					{
						return this.HistogramTypeInt;
					}
					
					
					case 1077161946:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "FinishBlock", 1077161946)) );
					}
					
					
					case 1221903417:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "AddSymbol", 1221903417)) );
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override double __hx_getField_f(string field, int hash, bool throwErrors, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 283120498:
					{
						return ((double) (this.merge_last_count_) );
					}
					
					
					case 1546852840:
					{
						return ((double) (this.curr_histogram_ix_) );
					}
					
					
					case 1677147340:
					{
						return ((double) (this.block_size_) );
					}
					
					
					case 1274418078:
					{
						return ((double) (this.target_block_size_) );
					}
					
					
					case 287012064:
					{
						return ((double) (this.num_blocks_) );
					}
					
					
					case 1572466393:
					{
						return this.split_threshold_;
					}
					
					
					case 183570271:
					{
						return ((double) (this.min_block_size_) );
					}
					
					
					case 1291834546:
					{
						return ((double) (this.alphabet_size_) );
					}
					
					
					case 981779505:
					{
						return ((double) (this.HistogramTypeInt) );
					}
					
					
					default:
					{
						return base.__hx_getField_f(field, hash, throwErrors, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, global::Array dynargs) {
			unchecked {
				switch (hash) {
					case 1077161946:
					{
						this.FinishBlock(global::haxe.lang.Runtime.toBool(dynargs[0]));
						break;
					}
					
					
					case 1221903417:
					{
						this.AddSymbol(((int) (global::haxe.lang.Runtime.toInt(dynargs[0])) ));
						break;
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				return null;
			}
		}
		
		
		public override void __hx_getFields(global::Array<object> baseArr) {
			baseArr.push("merge_last_count_");
			baseArr.push("last_entropy_");
			baseArr.push("last_histogram_ix_");
			baseArr.push("curr_histogram_ix_");
			baseArr.push("block_size_");
			baseArr.push("target_block_size_");
			baseArr.push("histograms_");
			baseArr.push("split_");
			baseArr.push("num_blocks_");
			baseArr.push("split_threshold_");
			baseArr.push("min_block_size_");
			baseArr.push("alphabet_size_");
			baseArr.push("HistogramTypeInt");
			base.__hx_getFields(baseArr);
		}
		
		
	}
}


