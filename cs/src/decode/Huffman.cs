// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace decode {
	public class Huffman : global::haxe.lang.HxObject {
		
		static Huffman() {
			unchecked {
				global::decode.Huffman.BROTLI_HUFFMAN_MAX_TABLE_SIZE = 1080;
				global::decode.Huffman.MAX_LENGTH = 15;
				global::decode.Huffman.MAX_CODE_LENGTHS_SIZE = 704;
			}
		}
		
		
		public Huffman(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Huffman() {
			global::decode.Huffman.__hx_ctor_decode_Huffman(this);
		}
		
		
		public static void __hx_ctor_decode_Huffman(global::decode.Huffman __hx_this) {
		}
		
		
		public static int BROTLI_HUFFMAN_MAX_TABLE_SIZE;
		
		public static int MAX_LENGTH;
		
		public static int MAX_CODE_LENGTHS_SIZE;
		
		public static int GetNextKey(int key, int len) {
			unchecked {
				int step = ( 1 << ( len - 1 ) );
				while (( (( key & step )) > 0 )) {
					step >>= 1;
				}
				
				return ( (( key & ( step - 1 ) )) + step );
			}
		}
		
		
		public static void ReplicateValue(global::decode.huffman.HuffmanCode[] table, int table_off, int step, int end, global::decode.huffman.HuffmanCode code) {
			while (true) {
				end -= step;
				((global::decode.huffman.HuffmanCode[]) (table) )[( table_off + end )] = new global::decode.huffman.HuffmanCode(code.bits, code.@value);
				if ( ! ((( end > 0 ))) ) {
					break;
				}
				
			}
			
		}
		
		
		public static int NextTableBitSize(int[] count, int len, int root_bits) {
			unchecked {
				int left = ( 1 << ( len - root_bits ) );
				while (( len < 15 )) {
					left -= ((int) (((int[]) (count) )[len]) );
					if (( left <= 0 )) {
						break;
					}
					
					 ++ len;
					left <<= 1;
				}
				
				return ( len - root_bits );
			}
		}
		
		
		public static int BrotliBuildHuffmanTable(global::decode.huffman.HuffmanCode[] root_table, int root_table_off, int root_bits, uint[] code_lengths, int code_lengths_size) {
			unchecked {
				global::decode.huffman.HuffmanCode code = new global::decode.huffman.HuffmanCode(((uint) (0) ), ((uint) (0) ));
				int table_off = default(int);
				int symbol = default(int);
				int key = default(int);
				int step = default(int);
				int low = default(int);
				int mask = default(int);
				int table_bits = default(int);
				int table_size = default(int);
				int total_size = default(int);
				int[] sorted = global::FunctionMalloc.mallocInt(704);
				int[] count = global::FunctionMalloc.mallocInt(16);
				int[] offset = global::FunctionMalloc.mallocInt(16);
				if (( code_lengths_size > 704 )) {
					return 0;
				}
				
				{
					int _g1 = 0;
					while (( _g1 < code_lengths_size )) {
						uint _g2 = ((uint) (((uint[]) (code_lengths) )[_g1++]) );
						((int[]) (count) )[((int) (_g2) )] = ( ((int) (((int[]) (count) )[((int) (_g2) )]) ) + 1 );
					}
					
				}
				
				((int[]) (offset) )[1] = 0;
				{
					int _g = 1;
					while (( _g < 15 )) {
						int len = _g++;
						((int[]) (offset) )[( len + 1 )] = ( ((int) (((int[]) (offset) )[len]) ) + ((int) (((int[]) (count) )[len]) ) );
					}
					
				}
				
				{
					int _g11 = 0;
					while (( _g11 < code_lengths_size )) {
						int symbol1 = _g11++;
						if (((bool) (( ((uint) (((uint[]) (code_lengths) )[symbol1]) ) != 0 )) )) {
							((int[]) (sorted) )[((int) (((int[]) (offset) )[((int) (((uint) (((uint[]) (code_lengths) )[symbol1]) )) )]) )] = symbol1;
							{
								uint _g21 = ((uint) (((uint[]) (code_lengths) )[symbol1]) );
								((int[]) (offset) )[((int) (_g21) )] = ( ((int) (((int[]) (offset) )[((int) (_g21) )]) ) + 1 );
							}
							
						}
						
					}
					
				}
				
				table_off = root_table_off;
				table_bits = root_bits;
				table_size = ( 1 << root_bits );
				total_size = table_size;
				if (( ((int) (((int[]) (offset) )[15]) ) == 1 )) {
					code.bits = ((uint) (0) );
					code.@value = ((uint) (((int) (((int[]) (sorted) )[0]) )) );
					{
						int _g12 = 0;
						int _g3 = total_size;
						while (( _g12 < _g3 )) {
							((global::decode.huffman.HuffmanCode[]) (root_table) )[( root_table_off + _g12++ )] = code;
						}
						
					}
					
					return total_size;
				}
				
				key = 0;
				symbol = 0;
				step = 2;
				{
					int _g13 = 1;
					int _g4 = ( root_bits + 1 );
					while (( _g13 < _g4 )) {
						int len1 = _g13++;
						while (( ((int) (((int[]) (count) )[len1]) ) > 0 )) {
							code.bits = ((uint) (len1) );
							code.@value = ((uint) (((int[]) (sorted) )[symbol++]) );
							global::decode.Huffman.ReplicateValue(root_table, ( root_table_off + key ), step, table_size, code);
							key = global::decode.Huffman.GetNextKey(key, len1);
							((int[]) (count) )[len1] = ( ((int) (((int[]) (count) )[len1]) ) - 1 );
						}
						
						step <<= 1;
					}
					
				}
				
				mask = ( total_size - 1 );
				low = -1;
				step = 2;
				{
					int _g14 = ( root_bits + 1 );
					while (( _g14 < 16 )) {
						int len2 = _g14++;
						while (( ((int) (((int[]) (count) )[len2]) ) > 0 )) {
							if (( (( key & mask )) != low )) {
								table_off += table_size;
								table_bits = global::decode.Huffman.NextTableBitSize(count, len2, root_bits);
								table_size = ( 1 << table_bits );
								total_size += table_size;
								low = ( key & mask );
								((global::decode.huffman.HuffmanCode) (((global::decode.huffman.HuffmanCode[]) (root_table) )[( root_table_off + low )]) ).bits = ((uint) (( table_bits + root_bits )) );
								((global::decode.huffman.HuffmanCode) (((global::decode.huffman.HuffmanCode[]) (root_table) )[( root_table_off + low )]) ).@value = ((uint) (( ( table_off - root_table_off ) - low )) );
							}
							
							code.bits = ((uint) (( len2 - root_bits )) );
							code.@value = ((uint) (((int[]) (sorted) )[symbol++]) );
							global::decode.Huffman.ReplicateValue(root_table, ( table_off + (( key >> root_bits )) ), step, table_size, code);
							key = global::decode.Huffman.GetNextKey(key, len2);
							((int[]) (count) )[len2] = ( ((int) (((int[]) (count) )[len2]) ) - 1 );
						}
						
						step <<= 1;
					}
					
				}
				
				return total_size;
			}
		}
		
		
		public static void BrotliHuffmanTreeGroupInit(global::decode.huffman.HuffmanTreeGroup @group, int alphabet_size, int ntrees) {
			unchecked {
				@group.alphabet_size = alphabet_size;
				@group.num_htrees = ntrees;
				@group.codes = global::FunctionMalloc.malloc2_decode_huffman_HuffmanCode(typeof(global::decode.huffman.HuffmanCode), ( ntrees * 1080 ));
				@group.htrees = new global::Array<object>();
				@group.htrees_off = new global::Array<int>();
			}
		}
		
		
		public static void BrotliHuffmanTreeGroupRelease(global::decode.huffman.HuffmanTreeGroup @group) {
		}
		
		
	}
}


