<?php

// Generated by Haxe 3.4.0
class decode_BitReader {
	public function __construct() {}
	static $BROTLI_MAX_NUM_BIT_READ = 25;
	static $BROTLI_READ_SIZE = 4096;
	static $BROTLI_IBUF_SIZE = 8320;
	static $BROTLI_IBUF_MASK = 8191;
	static $kBitMask;
	static function BitMask($n) {
		return decode_BitReader::$kBitMask[$n];
	}
	static function ShiftBytes32($br) {
		while(true) {
			$a = $br->bit_pos_;
			$aNeg = $a < 0;
			$tmp = null;
			if($aNeg !== false) {
				$tmp = $aNeg;
			} else {
				$tmp = $a >= 8;
			}
			if(!$tmp) {
				break;
			}
			$br->val_ = _hx_shift_right($br->val_, 8);
			$a1 = $br->val_;
			$a2 = $br->buf_[$br->pos_ & 8191];
			$br->val_ = $a1 | $a2 * Std::int(Math::pow(2, 24));
			++$br->pos_;
			$br->bit_pos_ = $br->bit_pos_ - 8;
			$br->bit_end_pos_ = $br->bit_end_pos_ - 8;
			unset($tmp,$aNeg,$a2,$a1,$a);
		}
	}
	static function BrotliReadMoreInput($br) {
		$a = $br->bit_end_pos_;
		$aNeg = $a < 0;
		$x = null;
		if($aNeg !== false) {
			$x = $aNeg;
		} else {
			$x = $a > 256;
		}
		if($x) {
			return true;
		} else {
			if($br->eos_ > 0) {
				$a1 = $br->bit_pos_;
				$b = $br->bit_end_pos_;
				$aNeg1 = $b < 0;
				if($aNeg1 !== $a1 < 0) {
					return $aNeg1;
				} else {
					return $b >= $a1;
				}
			} else {
				$dst = $br->buf_ptr_;
				$dst_off = $br->buf_ptr_off;
				$bytes_read = decode_Streams::BrotliRead($br->input_, $dst, $dst_off + $br->tmp_bytes_read_, 4096 - $br->tmp_bytes_read_);
				if($bytes_read < 0) {
					return false;
				}
				$bytes_read = $bytes_read + $br->tmp_bytes_read_;
				$br->tmp_bytes_read_ = 0;
				if($bytes_read < 4096) {
					if($br->finish_ <= 0) {
						$br->tmp_bytes_read_ = $bytes_read;
						return false;
					}
					$br->eos_ = 1;
					DefaultFunctions::memset_UInt($dst, $dst_off + $bytes_read, 0, 32);
				}
				if($dst_off === $br->buf_off) {
					DefaultFunctions::memcpy_UInt($br->buf_, $br->buf_off + 8192, $br->buf_, $br->buf_off, 32);
					$br->buf_ptr_ = $br->buf_;
					$br->buf_ptr_off = $br->buf_off + 4096;
				} else {
					$br->buf_ptr_ = $br->buf_;
					$br->buf_ptr_off = $br->buf_off;
				}
				$br->bit_end_pos_ = $br->bit_end_pos_ + ($bytes_read << 3);
				return true;
			}
		}
	}
	static function BrotliReadInputAmount($br, $num) {
		$a = $br->bit_end_pos_;
		$b = $num << 3;
		$aNeg = $a < 0;
		$x = null;
		if($aNeg !== $b < 0) {
			$x = $aNeg;
		} else {
			$x = $a > $b;
		}
		if($x) {
			return true;
		} else {
			if($br->eos_ > 0) {
				$a1 = $br->bit_pos_;
				$b1 = $br->bit_end_pos_;
				$aNeg1 = $b1 < 0;
				if($aNeg1 !== $a1 < 0) {
					return $aNeg1;
				} else {
					return $b1 >= $a1;
				}
			} else {
				$dst = $br->buf_ptr_;
				$dst_off = $br->buf_ptr_off;
				$bytes_read = decode_Streams::BrotliRead($br->input_, $dst, $dst_off + $br->tmp_bytes_read_, 4096 - $br->tmp_bytes_read_);
				if($bytes_read < 0) {
					return false;
				}
				$bytes_read = $bytes_read + $br->tmp_bytes_read_;
				$br->tmp_bytes_read_ = 0;
				if($bytes_read < 4096) {
					if($br->finish_ <= 0) {
						$br->tmp_bytes_read_ = $bytes_read;
						return false;
					}
					$br->eos_ = 1;
					DefaultFunctions::memset_UInt($dst, $dst_off + $bytes_read, 0, $num);
				}
				if($dst_off === $br->buf_off) {
					DefaultFunctions::memcpy_UInt($br->buf_, $br->buf_off + 8192, $br->buf_, $br->buf_off, $num);
					$br->buf_ptr_ = $br->buf_;
					$br->buf_ptr_off = $br->buf_off + 4096;
				} else {
					$br->buf_ptr_ = $br->buf_;
					$br->buf_ptr_off = $br->buf_off;
				}
				$br->bit_end_pos_ = $br->bit_end_pos_ + ($bytes_read << 3);
				return true;
			}
		}
	}
	static function BrotliFillBitWindow($br) {
		decode_BitReader::ShiftBytes32($br);
	}
	static function BrotliInitBitReader($br, $input, $finish) {
		$br->finish_ = $finish;
		$br->tmp_bytes_read_ = 0;
		$br->buf_ptr_ = $br->buf_;
		$br->buf_ptr_off = $br->buf_off;
		$br->input_ = $input;
		$br->val_ = 0;
		$br->pos_ = 0;
		$br->bit_pos_ = 0;
		$br->bit_end_pos_ = 0;
		$br->eos_ = 0;
	}
	static function BrotliWarmupBitReader($br) {
		if(!decode_BitReader::BrotliReadMoreInput($br)) {
			return false;
		}
		{
			$_g = 0;
			while($_g < 4) {
				$_g = $_g + 1;
				$br->val_ = $br->val_ | $br->buf_[$br->pos_] << 8 * ($_g - 1);
				++$br->pos_;
			}
		}
		$a = $br->bit_end_pos_;
		$aNeg = $a < 0;
		if($aNeg !== false) {
			return $aNeg;
		} else {
			return $a > 0;
		}
	}
	static function BrotliReadBits($br, $n_bits) {
		$val = null;
		$a = 32 - $br->bit_pos_;
		$aNeg = $n_bits < 0;
		$tmp = null;
		if($aNeg !== $a < 0) {
			$tmp = $aNeg;
		} else {
			$tmp = $n_bits > $a;
		}
		if($tmp) {
			decode_BitReader::BrotliFillBitWindow($br);
		}
		$val = _hx_shift_right($br->val_, $br->bit_pos_) & decode_BitReader::BitMask($n_bits);
		$br->bit_pos_ = $br->bit_pos_ + $n_bits;
		return $val;
	}
	function __toString() { return 'decode.BitReader'; }
}
decode_BitReader::$kBitMask = (new _hx_array(array(0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215)));
