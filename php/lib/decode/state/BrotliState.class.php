<?php

// Generated by Haxe 3.4.0
class decode_state_BrotliState {
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$this1 = (new _hx_array(array()));
		$this1->length = 18;
		$this->code_length_code_lengths = $this1;
		$this11 = (new _hx_array(array()));
		$this11->length = 32;
		$this->table = $this11;
		$this12 = (new _hx_array(array()));
		$this12->length = 3;
		$this->block_type_rb_index = $this12;
		$this13 = (new _hx_array(array()));
		$this13->length = 6;
		$this->block_type_rb = $this13;
		$this14 = (new _hx_array(array()));
		$this14->length = 3;
		$this->num_block_types = $this14;
		$this15 = (new _hx_array(array()));
		$this15->length = 3;
		$this->block_type = $this15;
		$this16 = (new _hx_array(array()));
		$this16->length = 3;
		$this->block_length = $this16;
		$this->br = new decode_bit_reader_BrotliBitReader();
		$this->hgroup = FunctionMalloc::malloc_decode_huffman_HuffmanTreeGroup(_hx_qtype("decode.huffman.HuffmanTreeGroup"), 3);
		$this17 = (new _hx_array(array()));
		$this17->length = 4;
		$this->dist_rb = $this17;
		$this18 = (new _hx_array(array()));
		$this18->length = 2;
		$this->sub_state = $this18;
	}}
	public $state;
	public $sub_state;
	public $pos;
	public $input_end;
	public $window_bits;
	public $max_backward_distance;
	public $max_distance;
	public $ringbuffer_size;
	public $ringbuffer_mask;
	public $ringbuffer;
	public $ringbuffer_off;
	public $ringbuffer_end;
	public $ringbuffer_end_off;
	public $dist_rb;
	public $dist_rb_idx;
	public $prev_byte1;
	public $prev_byte2;
	public $hgroup;
	public $block_type_trees;
	public $block_len_trees;
	public $br;
	public $loop_counter;
	public $trivial_literal_context;
	public $meta_block_remaining_len;
	public $is_metadata;
	public $is_uncompressed;
	public $block_length;
	public $block_type;
	public $num_block_types;
	public $block_type_rb;
	public $block_type_rb_index;
	public $distance_postfix_bits;
	public $num_direct_distance_codes;
	public $distance_postfix_mask;
	public $num_distance_codes;
	public $context_map;
	public $context_map_off;
	public $context_modes;
	public $context_modes_off;
	public $num_literal_htrees;
	public $dist_context_map;
	public $dist_context_map_off;
	public $num_dist_htrees;
	public $context_offset;
	public $context_map_slice;
	public $context_map_slice_off;
	public $literal_htree_index;
	public $dist_context_offset;
	public $dist_context_map_slice;
	public $dist_context_map_slice_off;
	public $dist_htree_index;
	public $context_lookup_offset1;
	public $context_lookup_offset2;
	public $context_mode;
	public $htree_command;
	public $htree_command_off;
	public $cmd_code;
	public $range_idx;
	public $insert_code;
	public $copy_code;
	public $insert_length;
	public $copy_length;
	public $distance_code;
	public $distance;
	public $copy_src;
	public $copy_src_off;
	public $copy_dst;
	public $copy_dst_off;
	public $nbytes;
	public $partially_written;
	public $htrees_decoded;
	public $symbol;
	public $prev_code_len;
	public $repeat;
	public $repeat_code_len;
	public $space;
	public $table;
	public $code_length_code_lengths;
	public $simple_code_or_skip;
	public $code_lengths;
	public $code_lengths_off;
	public $htree_index;
	public $next;
	public $next_off;
	public $context_index;
	public $max_run_length_prefix;
	public $context_map_table;
	public $custom_dict;
	public $custom_dict_off;
	public $custom_dict_size;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'decode.state.BrotliState'; }
}
