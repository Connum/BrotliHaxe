<?php

// Generated by Haxe 3.4.0
class decode_Huffman {
	public function __construct() {}
	static $BROTLI_HUFFMAN_MAX_TABLE_SIZE = 1080;
	static $MAX_LENGTH = 15;
	static $MAX_CODE_LENGTHS_SIZE = 704;
	static function GetNextKey($key, $len) {
		$step = 1 << $len - 1;
		while(($key & $step) > 0) {
			$step = $step >> 1;
		}
		return ($key & $step - 1) + $step;
	}
	static function ReplicateValue($table, $table_off, $step, $end, $code) {
		while(true) {
			$end = $end - $step;
			{
				$val = new decode_huffman_HuffmanCode($code->bits, $code->value);
				$table[$table_off + $end] = $val;
				unset($val);
			}
			if(!($end > 0)) {
				break;
			}
		}
	}
	static function NextTableBitSize($count, $len, $root_bits) {
		$left = 1 << $len - $root_bits;
		while($len < 15) {
			$left = $left - $count[$len];
			if($left <= 0) {
				break;
			}
			$len = $len + 1;
			$left = $left << 1;
		}
		return $len - $root_bits;
	}
	static function BrotliBuildHuffmanTable($root_table, $root_table_off, $root_bits, $code_lengths, $code_lengths_size) {
		$code = new decode_huffman_HuffmanCode(0, 0);
		$table_off = null;
		$symbol = null;
		$key = null;
		$step = null;
		$low = null;
		$mask = null;
		$table_bits = null;
		$table_size = null;
		$total_size = null;
		$sorted = FunctionMalloc::mallocInt(704);
		$count = FunctionMalloc::mallocInt(16);
		$offset = FunctionMalloc::mallocInt(16);
		if($code_lengths_size > 704) {
			return 0;
		}
		{
			$_g1 = 0;
			while($_g1 < $code_lengths_size) {
				$_g1 = $_g1 + 1;
				{
					$_g2 = $code_lengths[$_g1 - 1];
					$count[$_g2] = $count[$_g2] + 1;
					unset($_g2);
				}
			}
		}
		$offset[1] = 0;
		{
			$_g = 1;
			while($_g < 15) {
				$_g = $_g + 1;
				$len = $_g - 1;
				$offset[$len + 1] = $offset[$len] + $count[$len];
				unset($len);
			}
		}
		{
			$_g11 = 0;
			while($_g11 < $code_lengths_size) {
				$_g11 = $_g11 + 1;
				$symbol1 = $_g11 - 1;
				if($code_lengths[$symbol1] !== 0) {
					$sorted[$offset[$code_lengths[$symbol1]]] = $symbol1;
					{
						$_g21 = $code_lengths[$symbol1];
						$offset[$_g21] = $offset[$_g21] + 1;
						unset($_g21);
					}
				}
				unset($symbol1);
			}
		}
		$table_off = $root_table_off;
		$table_bits = $root_bits;
		$table_size = 1 << $root_bits;
		$total_size = $table_size;
		if($offset[15] === 1) {
			$code->bits = 0;
			$code->value = $sorted[0];
			{
				$_g12 = 0;
				$_g3 = $total_size;
				while($_g12 < $_g3) {
					$_g12 = $_g12 + 1;
					$root_table[$root_table_off + ($_g12 - 1)] = $code;
				}
			}
			return $total_size;
		}
		$key = 0;
		$symbol = 0;
		$step = 2;
		{
			$_g13 = 1;
			$_g4 = $root_bits + 1;
			while($_g13 < $_g4) {
				$_g13 = $_g13 + 1;
				$len1 = $_g13 - 1;
				while($count[$len1] > 0) {
					$code->bits = $len1;
					$symbol = $symbol + 1;
					$code->value = $sorted[$symbol - 1];
					decode_Huffman::ReplicateValue($root_table, $root_table_off + $key, $step, $table_size, $code);
					$key = decode_Huffman::GetNextKey($key, $len1);
					$count[$len1] = $count[$len1] - 1;
				}
				$step = $step << 1;
				unset($len1);
			}
		}
		$mask = $total_size - 1;
		$low = -1;
		$step = 2;
		{
			$_g14 = $root_bits + 1;
			while($_g14 < 16) {
				$_g14 = $_g14 + 1;
				$len2 = $_g14 - 1;
				while($count[$len2] > 0) {
					if(($key & $mask) !== $low) {
						$table_off = $table_off + $table_size;
						$table_bits = decode_Huffman::NextTableBitSize($count, $len2, $root_bits);
						$table_size = 1 << $table_bits;
						$total_size = $total_size + $table_size;
						$low = $key & $mask;
						$root_table[$root_table_off + $low]->bits = $table_bits + $root_bits;
						$root_table[$root_table_off + $low]->value = $table_off - $root_table_off - $low;
					}
					$code->bits = $len2 - $root_bits;
					$symbol = $symbol + 1;
					$code->value = $sorted[$symbol - 1];
					decode_Huffman::ReplicateValue($root_table, $table_off + ($key >> $root_bits), $step, $table_size, $code);
					$key = decode_Huffman::GetNextKey($key, $len2);
					$count[$len2] = $count[$len2] - 1;
				}
				$step = $step << 1;
				unset($len2);
			}
		}
		return $total_size;
	}
	static function BrotliHuffmanTreeGroupInit($group, $alphabet_size, $ntrees) {
		$group->alphabet_size = $alphabet_size;
		$group->num_htrees = $ntrees;
		$group->codes = FunctionMalloc::malloc2_decode_huffman_HuffmanCode(_hx_qtype("decode.huffman.HuffmanCode"), $ntrees * 1080);
		$group->htrees = new _hx_array(array());
		$group->htrees_off = new _hx_array(array());
	}
	static function BrotliHuffmanTreeGroupRelease($group) {}
	function __toString() { return 'decode.Huffman'; }
}
