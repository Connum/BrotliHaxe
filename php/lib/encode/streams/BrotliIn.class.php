<?php

// Generated by Haxe 3.4.0
class encode_streams_BrotliIn {
	public function __construct($f, $max_read_size) {
		if(!php_Boot::$skip_constructor) {
		$this->f_ = $f;
		$this->buffer_ = FunctionMalloc::mallocUInt($max_read_size);
		$this->buffer_size_ = $max_read_size;
	}}
	public $f_;
	public $buffer_;
	public $buffer_size_;
	public function Read($n, $bytes_read) {
		if($this->buffer_ === null) {
			$bytes_read[0] = 0;
			return null;
		}
		if($n > $this->buffer_size_) {
			$n = $this->buffer_size_;
		} else {
			if($n === 0) {
				if($this->f_->eof()) {
					return null;
				} else {
					return $this->buffer_;
				}
			}
		}
		if($this->f_->eof()) {
			return null;
		}
		$bytes = haxe_io_Bytes::alloc($n);
		try {
			$size = $this->f_->readBytes($bytes, 0, $n);
			{
				$_g1 = 0;
				$_g = $size;
				while($_g1 < $_g) {
					$_g1 = $_g1 + 1;
					$i = $_g1 - 1;
					{
						$this1 = $bytes->b;
						$this->buffer_[$i] = ord($this1->s[$i]);
						unset($this1);
					}
					unset($i);
				}
			}
			$bytes_read[0] = $size;
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			if(($e = $_ex_) instanceof haxe_io_Eof){} else throw $__hx__e;;
		}
		if($bytes_read[0] === 0) {
			return null;
		} else {
			return $this->buffer_;
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'encode.streams.BrotliIn'; }
}
