<?php

// Generated by Haxe 3.4.0
class encode_hash_HashLongestMatch {
	public function __construct($kBucketBits, $kBlockBits, $kNumLastDistancesToCheck) {
		if(!php_Boot::$skip_constructor) {
		$this->kBucketBits = $kBucketBits;
		$this->kBlockBits = $kBlockBits;
		$this->kNumLastDistancesToCheck = $kNumLastDistancesToCheck;
		$this->kBucketSize = 1 << $kBucketBits;
		$this->kBlockSize = 1 << $kBlockBits;
		$this->kBlockMask = (1 << $kBlockBits) - 1;
		$this1 = (new _hx_array(array()));
		$this1->length = $this->kBucketSize;
		$this->num_ = $this1;
		$this2 = (new _hx_array(array()));
		$this2->length = $this->kBucketSize;
		$this->buckets_ = $this2;
		{
			$_g1 = 0;
			$_g = $this->kBucketSize;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				{
					$this3 = (new _hx_array(array()));
					$this3->length = $this->kBlockSize;
					$this->buckets_[$_g1 - 1] = $this3;
					unset($this3);
				}
			}
		}
		$this->Reset();
	}}
	public function Reset() {
		DefaultFunctions::memset_UInt($this->num_, 0, 0, $this->num_->length);
		$this->num_dict_lookups_ = 0;
		$this->num_dict_matches_ = 0;
	}
	public function Store($data, $data_off, $ix) {
		$key = encode_Hash::Hash_($this->kBucketBits, $data, $data_off);
		$minor_ix = $this->num_[$key] & $this->kBlockMask;
		if($this->buckets_[$key] === null) {
			$this1 = (new _hx_array(array()));
			$this1->length = $this->kBlockSize;
			$this->buckets_[$key] = $this1;
		}
		$this->buckets_[$key][$minor_ix] = $ix;
		$this->num_[$key] = $this->num_[$key] + 1;
	}
	public function FindLongestMatch($data, $ring_buffer_mask, $distance_cache, $cur_ix, $max_length, $max_backward, $best_len_out, $best_len_code_out, $best_distance_out, $best_score_out) {
		$best_len_code_out[0] = 0;
		$cur_ix_masked = $cur_ix & $ring_buffer_mask;
		$match_found = false;
		$best_score = $best_score_out[0];
		$best_len = $best_len_out[0];
		$best_len_out[0] = 0;
		{
			$_g1 = 0;
			$_g = $this->kNumLastDistancesToCheck;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$backward = $distance_cache[encode_Hash::$kDistanceCacheIndex[$i]] + encode_Hash::$kDistanceCacheOffset[$i];
				$prev_ix = $cur_ix - $backward;
				$aNeg = $prev_ix < 0;
				$tmp = null;
				if($aNeg !== $cur_ix < 0) {
					$tmp = $aNeg;
				} else {
					$tmp = $prev_ix >= $cur_ix;
				}
				if($tmp) {
					continue;
				}
				$aNeg1 = $backward < 0;
				$tmp1 = null;
				if($aNeg1 !== $max_backward < 0) {
					$tmp1 = $aNeg1;
				} else {
					$tmp1 = $backward > $max_backward;
				}
				if($tmp1) {
					continue;
				}
				$prev_ix = $prev_ix & $ring_buffer_mask;
				$tmp2 = null;
				$tmp3 = null;
				if($cur_ix_masked + $best_len <= $ring_buffer_mask) {
					$a = $prev_ix + $best_len;
					$aNeg2 = $a < 0;
					if($aNeg2 !== $ring_buffer_mask < 0) {
						$tmp3 = $aNeg2;
					} else {
						$tmp3 = $a > $ring_buffer_mask;
					}
					unset($aNeg2,$a);
				} else {
					$tmp3 = true;
				}
				if(!$tmp3) {
					$tmp2 = $data[$cur_ix_masked + $best_len] !== $data[$prev_ix + $best_len];
				} else {
					$tmp2 = true;
				}
				if($tmp2) {
					continue;
				}
				$len = encode_Find_match_length::FindMatchLengthWithLimit($data, $prev_ix, $data, $cur_ix_masked, $max_length);
				$tmp4 = null;
				if($len < 3) {
					if($len === 2) {
						$tmp4 = $i < 2;
					} else {
						$tmp4 = false;
					}
				} else {
					$tmp4 = true;
				}
				if($tmp4) {
					$score = encode_Hash::BackwardReferenceScoreUsingLastDistance($len, $i);
					if($best_score < $score) {
						$best_score = $score;
						$best_len = $len;
						$best_len_out[0] = $len;
						$best_len_code_out[0] = $len;
						$best_distance_out[0] = $backward;
						$best_score_out[0] = $score;
						$match_found = true;
					}
					unset($score);
				}
				unset($tmp4,$tmp3,$tmp2,$tmp1,$tmp,$prev_ix,$len,$i,$backward,$aNeg1,$aNeg);
			}
		}
		$key = encode_Hash::Hash_($this->kBucketBits, $data, $cur_ix_masked);
		$bucket = $this->buckets_[$key];
		$down = null;
		$a1 = $this->num_[$key];
		$b = $this->kBlockSize;
		$aNeg3 = $a1 < 0;
		$down1 = null;
		if($aNeg3 !== $b < 0) {
			$down1 = $aNeg3;
		} else {
			$down1 = $a1 > $b;
		}
		if($down1) {
			$down = $this->num_[$key] - $this->kBlockSize;
		} else {
			$down = 0;
		}
		$i1 = $this->num_[$key] - 1;
		while($i1 >= $down) {
			$prev_ix1 = $bucket[$i1 & $this->kBlockMask];
			$tmp5 = null;
			if($prev_ix1 !== -1) {
				$tmp5 = $prev_ix1 >= 0;
			} else {
				$tmp5 = false;
			}
			if($tmp5) {
				$backward1 = $cur_ix - $prev_ix1;
				$aNeg4 = $backward1 < 0;
				$tmp6 = null;
				if($aNeg4 !== $max_backward < 0) {
					$tmp6 = $aNeg4;
				} else {
					$tmp6 = $backward1 > $max_backward;
				}
				if($tmp6) {
					break;
				}
				$prev_ix1 = $prev_ix1 & $ring_buffer_mask;
				$tmp7 = null;
				$tmp8 = null;
				if($cur_ix_masked + $best_len <= $ring_buffer_mask) {
					$tmp8 = $prev_ix1 + $best_len > $ring_buffer_mask;
				} else {
					$tmp8 = true;
				}
				if(!$tmp8) {
					$tmp7 = $data[$cur_ix_masked + $best_len] !== $data[$prev_ix1 + $best_len];
				} else {
					$tmp7 = true;
				}
				if($tmp7) {
					$i1 = $i1 - 1;
					continue;
				}
				$len1 = encode_Find_match_length::FindMatchLengthWithLimit($data, $prev_ix1, $data, $cur_ix_masked, $max_length);
				if($len1 >= 4) {
					$score1 = encode_Hash::BackwardReferenceScore($len1, $backward1);
					if($best_score < $score1) {
						$best_score = $score1;
						$best_len = $len1;
						$best_len_out[0] = $len1;
						$best_len_code_out[0] = $len1;
						$best_distance_out[0] = $backward1;
						$best_score_out[0] = $score1;
						$match_found = true;
					}
					unset($score1);
				}
				unset($tmp8,$tmp7,$tmp6,$len1,$backward1,$aNeg4);
			}
			$i1 = $i1 - 1;
			unset($tmp5,$prev_ix1);
		}
		$tmp9 = null;
		if(!$match_found) {
			$tmp9 = $this->num_dict_matches_ >= $this->num_dict_lookups_ >> 7;
		} else {
			$tmp9 = false;
		}
		if($tmp9) {
			$key1 = encode_Hash::Hash_(14, $data, $cur_ix_masked) << 1;
			{
				$_g2 = 0;
				while($_g2 < 2) {
					$_g2 = $_g2 + 1;
					++$this->num_dict_lookups_;
					$v = encode_Dictionary_hash::$kStaticDictionaryHash[$key1];
					$aNeg5 = $v < 0;
					$tmp10 = null;
					if($aNeg5 !== false) {
						$tmp10 = $aNeg5;
					} else {
						$tmp10 = $v > 0;
					}
					if($tmp10) {
						$len2 = $v & 31;
						$dist = _hx_shift_right($v, 5);
						$aNeg6 = $max_length < 0;
						$tmp11 = null;
						if($aNeg6 !== $len2 < 0) {
							$tmp11 = $aNeg6;
						} else {
							$tmp11 = $max_length >= $len2;
						}
						if($tmp11) {
							if(encode_Find_match_length::FindMatchLengthWithLimit($data, $cur_ix_masked, encode_Dictionary::$kBrotliDictionary, encode_Dictionary::$kBrotliDictionaryOffsetsByLength->a[$len2] + $len2 * $dist, $len2) === $len2) {
								$backward2 = $max_backward + $dist + 1;
								$score2 = encode_Hash::BackwardReferenceScore($len2, $backward2);
								if($best_score < $score2) {
									++$this->num_dict_matches_;
									$best_len_out[0] = $len2;
									$best_len_code_out[0] = $len2;
									$best_distance_out[0] = $backward2;
									$best_score_out[0] = $score2;
									$match_found = true;
									break;
								}
								unset($score2,$backward2);
							}
						}
						unset($tmp11,$len2,$dist,$aNeg6);
					}
					$key1 = $key1 + 1;
					unset($v,$tmp10,$aNeg5);
				}
			}
		}
		return $match_found;
	}
	public function FindAllMatches($data, $ring_buffer_mask, $cur_ix, $max_length, $max_backward, $num_matches, $num_matches_off, $matches, $matches_off) {
		$orig_matches = $matches;
		$orig_matches_off = $matches_off;
		$cur_ix_masked = $cur_ix & $ring_buffer_mask;
		$best_len = 1;
		$stop = $cur_ix - 64;
		if($stop < 0) {
			$stop = 0;
		}
		$i = $cur_ix - 1;
		while(true) {
			$tmp = null;
			if($i > $stop) {
				$tmp = $best_len <= 2;
			} else {
				$tmp = false;
			}
			if(!$tmp) {
				break;
			}
			$prev_ix = $i;
			$backward = $cur_ix - $prev_ix;
			$aNeg = $backward < 0;
			$tmp1 = null;
			if($aNeg !== $max_backward < 0) {
				$tmp1 = $aNeg;
			} else {
				$tmp1 = $backward > $max_backward;
			}
			if($tmp1) {
				break;
			}
			$prev_ix = $prev_ix & $ring_buffer_mask;
			$tmp2 = null;
			if($data[$cur_ix_masked] === $data[$prev_ix]) {
				$tmp2 = $data[$cur_ix_masked + 1] !== $data[$prev_ix + 1];
			} else {
				$tmp2 = true;
			}
			if($tmp2) {
				$i = $i - 1;
				continue;
			}
			$len = encode_Find_match_length::FindMatchLengthWithLimit($data, $prev_ix, $data, $cur_ix_masked, $max_length);
			if($len > $best_len) {
				$best_len = $len;
				if($len > 325) {
					$matches = $orig_matches;
				}
				$match = new encode_hash_BackwardMatch();
				$match->BackwardMatch2($backward, $len);
				$matches_off = $matches_off + 1;
				$matches[$matches_off - 1] = $match;
				unset($match);
			}
			$i = $i - 1;
			unset($tmp2,$tmp1,$tmp,$prev_ix,$len,$backward,$aNeg);
		}
		$key = encode_Hash::Hash_($this->kBucketBits, $data, $cur_ix_masked);
		$bucket = $this->buckets_[$key];
		$down = null;
		$a = $this->num_[$key];
		$b = $this->kBlockSize;
		$aNeg1 = $a < 0;
		$down1 = null;
		if($aNeg1 !== $b < 0) {
			$down1 = $aNeg1;
		} else {
			$down1 = $a > $b;
		}
		if($down1) {
			$down = $this->num_[$key] - $this->kBlockSize;
		} else {
			$down = 0;
		}
		$i1 = $this->num_[$key] - 1;
		while($i1 >= $down) {
			$prev_ix1 = $bucket[$i1 & $this->kBlockMask];
			if($prev_ix1 >= 0) {
				$backward1 = $cur_ix - $prev_ix1;
				$aNeg2 = $backward1 < 0;
				$tmp3 = null;
				if($aNeg2 !== $max_backward < 0) {
					$tmp3 = $aNeg2;
				} else {
					$tmp3 = $backward1 > $max_backward;
				}
				if($tmp3) {
					break;
				}
				$prev_ix1 = $prev_ix1 & $ring_buffer_mask;
				$tmp4 = null;
				$tmp5 = null;
				if($cur_ix_masked + $best_len <= $ring_buffer_mask) {
					$tmp5 = $prev_ix1 + $best_len > $ring_buffer_mask;
				} else {
					$tmp5 = true;
				}
				if(!$tmp5) {
					$tmp4 = $data[$cur_ix_masked + $best_len] !== $data[$prev_ix1 + $best_len];
				} else {
					$tmp4 = true;
				}
				if($tmp4) {
					$i1 = $i1 - 1;
					continue;
				}
				$len1 = encode_Find_match_length::FindMatchLengthWithLimit($data, $prev_ix1, $data, $cur_ix_masked, $max_length);
				if($len1 > $best_len) {
					$best_len = $len1;
					if($len1 > 325) {
						$matches_off = $orig_matches_off;
					}
					$match1 = new encode_hash_BackwardMatch();
					$match1->BackwardMatch2($backward1, $len1);
					$matches_off = $matches_off + 1;
					$matches[$matches_off - 1] = $match1;
					unset($match1);
				}
				unset($tmp5,$tmp4,$tmp3,$len1,$backward1,$aNeg2);
			}
			$i1 = $i1 - 1;
			unset($prev_ix1);
		}
		$dict_matches = FunctionMalloc::mallocInt(38);
		DefaultFunctions::memset_Int($dict_matches, 0, 268435455, $dict_matches->length);
		$minlen = Std::int(Math::max(4, $best_len + 1));
		if(encode_Static_dict::FindAllStaticDictionaryMatches($data, $cur_ix_masked, $minlen, $dict_matches, 0)) {
			$int = $max_length;
			$maxlen = null;
			if($int < 0) {
				$maxlen = 4294967296.0 + $int;
			} else {
				$maxlen = $int + 0.0;
			}
			$maxlen1 = Std::int(Math::min(37, $maxlen));
			{
				$_g1 = $minlen;
				while($_g1 < $maxlen1) {
					$_g1 = $_g1 + 1;
					$l = $_g1 - 1;
					$dict_id = $dict_matches[$l];
					if($dict_id < 268435455) {
						$match2 = new encode_hash_BackwardMatch();
						$match2->BackwardMatch3($max_backward + ($dict_id >> 5) + 1, $l, $dict_id & 31);
						$matches_off = $matches_off + 1;
						$matches[$matches_off - 1] = $match2;
						unset($match2);
					}
					unset($l,$dict_id);
				}
			}
		}
		$num_matches[$num_matches_off] = $num_matches[$num_matches_off] + ($matches_off - $orig_matches_off);
	}
	public $kBucketBits;
	public $kBlockBits;
	public $kNumLastDistancesToCheck;
	public $kBucketSize;
	public $kBlockSize;
	public $kBlockMask;
	public $num_;
	public $buckets_;
	public $num_dict_lookups_;
	public $num_dict_matches_;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'encode.hash.HashLongestMatch'; }
}
