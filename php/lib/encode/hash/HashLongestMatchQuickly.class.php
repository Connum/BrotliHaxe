<?php

// Generated by Haxe 3.4.0
class encode_hash_HashLongestMatchQuickly {
	public function __construct($kBucketBits, $kBucketSweep, $kUseDictionary) {
		if(!php_Boot::$skip_constructor) {
		$this->kBucketBits = $kBucketBits;
		$this->kBucketSweep = $kBucketSweep;
		$this->kUseDictionary = $kUseDictionary;
		$this->kBucketSize = 1 << $kBucketBits;
		$this1 = (new _hx_array(array()));
		$this1->length = $this->kBucketSize + $kBucketSweep;
		$this->buckets_ = $this1;
		$this->Reset();
	}}
	public function Reset() {
		DefaultFunctions::memset_UInt($this->buckets_, 0, 0, $this->buckets_->length);
		$this->num_dict_lookups_ = 0;
		$this->num_dict_matches_ = 0;
	}
	public function Store($data, $data_off, $ix) {
		$this->buckets_[encode_Hash::Hash_($this->kBucketBits, $data, $data_off) + _hx_mod(($ix >> 3), $this->kBucketSweep)] = $ix;
	}
	public function FindLongestMatch($ring_buffer, $ring_buffer_mask, $distance_cache, $cur_ix, $max_length, $max_backward, $best_len_out, $best_len_code_out, $best_distance_out, $best_score_out) {
		$best_len_in = $best_len_out[0];
		$cur_ix_masked = $cur_ix & $ring_buffer_mask;
		$compare_char = $ring_buffer[$cur_ix_masked + $best_len_in];
		$best_score = $best_score_out[0];
		$best_len = $best_len_in;
		$backward = $distance_cache[0];
		$prev_ix = $cur_ix - $backward;
		$match_found = false;
		$aNeg = $cur_ix < 0;
		$tmp = null;
		if($aNeg !== $prev_ix < 0) {
			$tmp = $aNeg;
		} else {
			$tmp = $cur_ix > $prev_ix;
		}
		if($tmp) {
			$prev_ix = $prev_ix & $ring_buffer_mask;
			if($compare_char === $ring_buffer[$prev_ix + $best_len_in]) {
				$len = encode_Find_match_length::FindMatchLengthWithLimit($ring_buffer, $prev_ix, $ring_buffer, $cur_ix_masked, $max_length);
				if($len >= 4) {
					$best_score = encode_Hash::BackwardReferenceScoreUsingLastDistance($len, 0);
					$best_len = $len;
					$best_len_out[0] = $len;
					$best_len_code_out[0] = $len;
					$best_distance_out[0] = $backward;
					$best_score_out[0] = $best_score;
					$compare_char = $ring_buffer[$cur_ix_masked + $len];
					if($this->kBucketSweep === 1) {
						return true;
					} else {
						$match_found = true;
					}
				}
			}
		}
		$key = encode_Hash::Hash_($this->kBucketBits, $ring_buffer, $cur_ix_masked);
		if($this->kBucketSweep === 1) {
			$prev_ix = $this->buckets_[$key];
			$backward = $cur_ix - $prev_ix;
			$prev_ix = $prev_ix & $ring_buffer_mask;
			if($compare_char !== $ring_buffer[$prev_ix + $best_len_in]) {
				return false;
			}
			$tmp1 = null;
			if($backward !== 0) {
				$tmp1 = $backward > $max_backward;
			} else {
				$tmp1 = true;
			}
			if($tmp1) {
				return false;
			}
			$len1 = encode_Find_match_length::FindMatchLengthWithLimit($ring_buffer, $prev_ix, $ring_buffer, $cur_ix_masked, $max_length);
			if($len1 >= 4) {
				$best_len_out[0] = $len1;
				$best_len_code_out[0] = $len1;
				$best_distance_out[0] = $backward;
				$best_score_out[0] = encode_Hash::BackwardReferenceScore($len1, $backward);
				return true;
			}
		} else {
			$bucket = $this->buckets_;
			$bucket_off = 0 + $key;
			{
				$_g1 = 0;
				$_g = $this->kBucketSweep;
				while($_g1 < $_g) {
					$_g1 = $_g1 + 1;
					$bucket_off = $bucket_off + 1;
					$prev_ix = $bucket[$bucket_off - 1];
					$backward1 = $cur_ix - $prev_ix;
					$prev_ix = $prev_ix & $ring_buffer_mask;
					if($compare_char !== $ring_buffer[$prev_ix + $best_len]) {
						continue;
					}
					$tmp2 = null;
					if($backward1 !== 0) {
						$tmp2 = $backward1 > $max_backward;
					} else {
						$tmp2 = true;
					}
					if($tmp2) {
						continue;
					}
					$len2 = encode_Find_match_length::FindMatchLengthWithLimit($ring_buffer, $prev_ix, $ring_buffer, $cur_ix_masked, $max_length);
					if($len2 >= 4) {
						$score = encode_Hash::BackwardReferenceScore($len2, $backward1);
						if($best_score < $score) {
							$best_score = $score;
							$best_len = $len2;
							$best_len_out[0] = $len2;
							$best_len_code_out[0] = $len2;
							$best_distance_out[0] = $backward1;
							$best_score_out[0] = $score;
							$compare_char = $ring_buffer[$cur_ix_masked + $len2];
							$match_found = true;
						}
						unset($score);
					}
					unset($tmp2,$len2,$backward1);
				}
			}
		}
		$tmp3 = null;
		$tmp4 = null;
		if($this->kUseDictionary) {
			$tmp4 = !$match_found;
		} else {
			$tmp4 = false;
		}
		if($tmp4) {
			$tmp3 = $this->num_dict_matches_ >= $this->num_dict_lookups_ >> 7;
		} else {
			$tmp3 = false;
		}
		if($tmp3) {
			++$this->num_dict_lookups_;
			$v = encode_Dictionary_hash::$kStaticDictionaryHash[encode_Hash::Hash_(14, $ring_buffer, $cur_ix_masked) << 1];
			$aNeg1 = $v < 0;
			$tmp5 = null;
			if($aNeg1 !== false) {
				$tmp5 = $aNeg1;
			} else {
				$tmp5 = $v > 0;
			}
			if($tmp5) {
				$len3 = $v & 31;
				$dist = _hx_shift_right($v, 5);
				if($len3 <= $max_length) {
					if(encode_Find_match_length::FindMatchLengthWithLimit($ring_buffer, $cur_ix_masked, encode_Dictionary::$kBrotliDictionary, encode_Dictionary::$kBrotliDictionaryOffsetsByLength->a[$len3] + $len3 * $dist, $len3) === $len3) {
						$backward2 = $max_backward + $dist + 1;
						$score1 = encode_Hash::BackwardReferenceScore($len3, $backward2);
						if($best_score < $score1) {
							++$this->num_dict_matches_;
							$best_len_out[0] = $len3;
							$best_len_code_out[0] = $len3;
							$best_distance_out[0] = $backward2;
							$best_score_out[0] = $score1;
							return true;
						}
					}
				}
			}
		}
		return $match_found;
	}
	public $kBucketBits;
	public $kBucketSweep;
	public $kUseDictionary;
	public $kBucketSize;
	public $buckets_;
	public $num_dict_lookups_;
	public $num_dict_matches_;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'encode.hash.HashLongestMatchQuickly'; }
}
