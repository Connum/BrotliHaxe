<?php

// Generated by Haxe 3.4.0
class encode_encode_BrotliCompressor {
	public function __construct($params) {
		if(!php_Boot::$skip_constructor) {
		$this1 = (new _hx_array(array()));
		$this1->length = 4;
		$this->saved_dist_cache_ = $this1;
		$this11 = (new _hx_array(array()));
		$this11->length = 4;
		$this->dist_cache_ = $this11;
		$this->params_ = $params;
		$this->hashers_ = new encode_hash_Hashers();
		$this->input_pos_ = 0;
		$this->num_commands_ = 0;
		$this->num_literals_ = 0;
		$this->last_insert_len_ = 0;
		$this->last_flush_pos_ = 0;
		$this->last_processed_pos_ = 0;
		$this->prev_byte_ = 0;
		$this->prev_byte2_ = 0;
		$this->storage_size_ = 0;
		$tmp = Math::max(1, $this->params_->quality);
		$this->params_->quality = Std::int($tmp);
		if($this->params_->lgwin < encode_Encode::$kMinWindowBits) {
			$this->params_->lgwin = encode_Encode::$kMinWindowBits;
		} else {
			if($this->params_->lgwin > encode_Encode::$kMaxWindowBits) {
				$this->params_->lgwin = encode_Encode::$kMaxWindowBits;
			}
		}
		if($this->params_->lgblock === 0) {
			$tmp1 = null;
			if($this->params_->quality < encode_Encode::$kMinQualityForBlockSplit) {
				$tmp1 = 14;
			} else {
				$tmp1 = 16;
			}
			$this->params_->lgblock = $tmp1;
			$tmp2 = null;
			if($this->params_->quality >= 9) {
				$tmp2 = $this->params_->lgwin > $this->params_->lgblock;
			} else {
				$tmp2 = false;
			}
			if($tmp2) {
				$tmp3 = Math::min(21, $this->params_->lgwin);
				$this->params_->lgblock = Std::int($tmp3);
			}
		} else {
			$tmp4 = encode_Encode::$kMaxInputBlockBits;
			$tmp5 = Math::min($tmp4, Math::max(encode_Encode::$kMinInputBlockBits, $this->params_->lgblock));
			$this->params_->lgblock = Std::int($tmp5);
		}
		$this->max_backward_distance_ = (1 << $this->params_->lgwin) - 16;
		$ringbuffer_bits = Std::int(Math::max($this->params_->lgwin + 1, $this->params_->lgblock + 1));
		$this->ringbuffer_ = new encode_RingBuffer($ringbuffer_bits, $this->params_->lgblock);
		if($this->params_->quality > 9) {
			$this->literal_cost_mask_ = (1 << $this->params_->lgblock) - 1;
			$this->literal_cost_ = FunctionMalloc::mallocFloat($this->literal_cost_mask_ + 1);
		}
		$this->cmd_buffer_size_ = Std::int(Math::max(262144, 1 << $this->params_->lgblock));
		$this->commands_ = new _hx_array(array());
		if($this->params_->lgwin === 16) {
			$this->last_byte_ = 0;
			$this->last_byte_bits_ = 1;
		} else {
			if($this->params_->lgwin === 17) {
				$this->last_byte_ = 1;
				$this->last_byte_bits_ = 7;
			} else {
				$this->last_byte_ = $this->params_->lgwin - 17 << 1 | 1;
				$this->last_byte_bits_ = 4;
			}
		}
		$this->dist_cache_[0] = 4;
		$this->dist_cache_[1] = 11;
		$this->dist_cache_[2] = 15;
		$this->dist_cache_[3] = 16;
		DefaultFunctions::memcpy_Int($this->saved_dist_cache_, 0, $this->dist_cache_, 0, $this->dist_cache_->length);
		$this->hash_type_ = Std::int(Math::min(9, $this->params_->quality));
		$this->hashers_->Init($this->hash_type_);
	}}
	public function GetBrotliStorage($size) {
		if($this->storage_size_ < $size) {
			$this->storage_ = FunctionMalloc::mallocUInt($size);
			$this->storage_size_ = $size;
		}
		return $this->storage_;
	}
	public function input_block_size() {
		return 1 << $this->params_->lgblock;
	}
	public $params_;
	public $max_backward_distance_;
	public $hashers_;
	public $hash_type_;
	public $input_pos_;
	public $ringbuffer_;
	public $literal_cost_;
	public $literal_cost_mask_;
	public $cmd_buffer_size_;
	public $commands_;
	public $num_commands_;
	public $num_literals_;
	public $last_insert_len_;
	public $last_flush_pos_;
	public $last_processed_pos_;
	public $dist_cache_;
	public $saved_dist_cache_;
	public $last_byte_;
	public $last_byte_bits_;
	public $prev_byte_;
	public $prev_byte2_;
	public $storage_size_;
	public $storage_;
	public function CopyInputToRingBuffer($input_size, $input_buffer) {
		$this->ringbuffer_->Write($input_buffer, $input_size);
		$tmp = $this;
		$tmp->input_pos_ = $tmp->input_pos_ + $input_size;
		$pos = $this->ringbuffer_->position();
		if($pos <= $this->ringbuffer_->mask()) {
			DefaultFunctions::memset_UInt($this->ringbuffer_->start(), $pos, 0, 3);
		}
	}
	public function BrotliSetCustomDictionary($size, $dict) {
		$this->CopyInputToRingBuffer($size, $dict);
		$this->last_flush_pos_ = $size;
		$this->last_processed_pos_ = $size;
		if($size > 0) {
			$this->prev_byte_ = $dict[$size - 1];
		}
		if($size > 1) {
			$this->prev_byte2_ = $dict[$size - 2];
		}
		$this->hashers_->PrependCustomDictionary($this->hash_type_, $size, $dict);
	}
	public function WriteBrotliData($is_last, $force_flush, $out_size, $output) {
		$bytes = $this->input_pos_ - $this->last_processed_pos_;
		$data = $this->ringbuffer_->start();
		$mask = $this->ringbuffer_->mask();
		if($bytes > $this->input_block_size()) {
			return false;
		}
		$utf8_mode = null;
		if($this->params_->quality >= 9) {
			$utf8_mode = encode_Encode::IsMostlyUTF8($data, $this->last_processed_pos_ & $mask, $bytes, encode_Encode::$kMinUTF8Ratio);
		} else {
			$utf8_mode = false;
		}
		if($this->literal_cost_ !== null) {
			if($utf8_mode) {
				encode_Literal_cost::EstimateBitCostsForLiteralsUTF8($this->last_processed_pos_, $bytes, $mask, $this->literal_cost_mask_, $data, $this->literal_cost_);
			} else {
				encode_Literal_cost::EstimateBitCostsForLiterals($this->last_processed_pos_, $bytes, $mask, $this->literal_cost_mask_, $data, $this->literal_cost_);
			}
		}
		$last_insert_len = (new _hx_array(array($this->last_insert_len_)));
		$num_commands = (new _hx_array(array($this->num_commands_)));
		$num_literals = (new _hx_array(array($this->num_literals_)));
		encode_Backward_references::CreateBackwardReferences($bytes, $this->last_processed_pos_, $data, $mask, $this->literal_cost_, $this->literal_cost_mask_, $this->max_backward_distance_, $this->params_->quality, $this->hashers_, $this->hash_type_, $this->dist_cache_, $last_insert_len, $this->commands_, $num_commands[0], $num_commands, $num_literals);
		$this->last_insert_len_ = $last_insert_len[0];
		$this->num_commands_ = $num_commands[0];
		$this->num_literals_ = $num_literals[0];
		$max_length = Std::int(Math::min($mask + 1, 1 << encode_Encode::$kMaxInputBlockBits));
		$tmp = null;
		$tmp1 = null;
		$tmp2 = null;
		$tmp3 = null;
		if(!$is_last) {
			$tmp3 = !$force_flush;
		} else {
			$tmp3 = false;
		}
		if($tmp3) {
			if($this->params_->quality < encode_Encode::$kMinQualityForBlockSplit) {
				$tmp2 = $this->num_literals_ + $this->num_commands_ < 12287;
			} else {
				$tmp2 = true;
			}
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			$tmp1 = $this->num_commands_ + ($this->input_block_size() >> 1) < $this->cmd_buffer_size_;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			$tmp = $this->input_pos_ + $this->input_block_size() <= $this->last_flush_pos_ + $max_length;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$this->last_processed_pos_ = $this->input_pos_;
			$out_size[0] = 0;
			return true;
		}
		if($this->last_insert_len_ > 0) {
			$command = new encode_command_Command();
			$command->Command1($this->last_insert_len_);
			$this->commands_[$this->num_commands_++] = $command;
			$tmp4 = $this;
			$tmp4->num_literals_ = $tmp4->num_literals_ + $this->last_insert_len_;
			$this->last_insert_len_ = 0;
		}
		return $this->WriteMetaBlockInternal($is_last, $utf8_mode, $out_size, $output);
	}
	public function WriteMetaBlockInternal($is_last, $utf8_mode, $out_size, $output) {
		$bytes = $this->input_pos_ - $this->last_flush_pos_;
		$data = $this->ringbuffer_->start();
		$mask = $this->ringbuffer_->mask();
		$storage = $this->GetBrotliStorage(2 * $bytes + 500);
		$storage[0] = $this->last_byte_;
		$storage_ix = (new _hx_array(array($this->last_byte_bits_)));
		$uncompressed = false;
		if($this->num_commands_ < ($bytes >> 8) + 2) {
			if($this->num_literals_ > 0.99 * $bytes) {
				$literal_histo = FunctionMalloc::mallocInt(256);
				$kBitCostThreshold = $bytes * 7.92 / 13;
				$i = $this->last_flush_pos_;
				while($i < $this->input_pos_) {
					{
						$_g = $data[$i & $mask];
						$literal_histo[$_g] = $literal_histo[$_g] + 1;
						unset($_g);
					}
					$i = $i + 13;
				}
				if(encode_Bit_cost::BitsEntropy($literal_histo, 0, 256) > $kBitCostThreshold) {
					$uncompressed = true;
				}
			}
		}
		if($bytes === 0) {
			if(!encode_Brotli_bit_stream::StoreCompressedMetaBlockHeader($is_last, 0, $storage_ix, $storage)) {
				return false;
			}
			$storage_ix[0] = $storage_ix->a[0] + 7 & -8;
		} else {
			if($uncompressed) {
				DefaultFunctions::memcpy_Int($this->dist_cache_, 0, $this->saved_dist_cache_, 0, $this->dist_cache_->length);
				if(!encode_Brotli_bit_stream::StoreUncompressedMetaBlock($is_last, $data, $this->last_flush_pos_, $mask, $bytes, $storage_ix, $storage, 0)) {
					return false;
				}
			} else {
				$num_direct_distance_codes = 0;
				$distance_postfix_bits = 0;
				$tmp = null;
				if($this->params_->quality > 9) {
					$tmp = $this->params_->mode === 2;
				} else {
					$tmp = false;
				}
				if($tmp) {
					$num_direct_distance_codes = 12;
					$distance_postfix_bits = 1;
					encode_Encode::RecomputeDistancePrefixes($this->commands_, $this->num_commands_, 12, 1);
				}
				if($this->params_->quality < encode_Encode::$kMinQualityForBlockSplit) {
					if(!encode_Brotli_bit_stream::StoreMetaBlockTrivial($data, $this->last_flush_pos_, $bytes, $mask, $is_last, $this->commands_, $this->num_commands_, $storage_ix, $storage, 0)) {
						return false;
					}
				} else {
					$mb = new encode_metablock_MetaBlockSplit();
					$literal_context_mode = null;
					if($utf8_mode) {
						$literal_context_mode = 2;
					} else {
						$literal_context_mode = 3;
					}
					$literal_context_mode1 = (new _hx_array(array($literal_context_mode)));
					if($this->params_->quality <= 9) {
						$num_literal_contexts = (new _hx_array(array(1)));
						$literal_context_map = (new _hx_array(array((new _hx_array(array(-1))))));
						encode_Encode::DecideOverLiteralContextModeling($data, $this->last_flush_pos_, $bytes, $mask, $this->params_->quality, $literal_context_mode1, $num_literal_contexts, $literal_context_map);
						if($literal_context_map[0][0] === -1) {
							encode_Metablock::BuildMetaBlockGreedy($data, $this->last_flush_pos_, $mask, $this->commands_, $this->num_commands_, $mb);
						} else {
							encode_Metablock::BuildMetaBlockGreedyWithContexts($data, $this->last_flush_pos_, $mask, $this->prev_byte_, $this->prev_byte2_, $literal_context_mode1[0], $num_literal_contexts[0], $literal_context_map[0], $this->commands_, $this->num_commands_, $mb);
						}
					} else {
						encode_Metablock::BuildMetaBlock($data, $this->last_flush_pos_, $mask, $this->prev_byte_, $this->prev_byte2_, $this->commands_, $this->num_commands_, $literal_context_mode1[0], $mb);
					}
					if($this->params_->quality >= encode_Encode::$kMinQualityForOptimizeHistograms) {
						encode_Metablock::OptimizeHistograms($num_direct_distance_codes, $distance_postfix_bits, $mb);
					}
					if(!encode_Brotli_bit_stream::StoreMetaBlock($data, $this->last_flush_pos_, $bytes, $mask, $this->prev_byte_, $this->prev_byte2_, $is_last, $num_direct_distance_codes, $distance_postfix_bits, $literal_context_mode1[0], $this->commands_, $this->num_commands_, $mb, $storage_ix, $storage)) {
						return false;
					}
				}
				if($bytes + 4 < $storage_ix->a[0] >> 3) {
					DefaultFunctions::memcpy_Int($this->dist_cache_, 0, $this->saved_dist_cache_, 0, $this->dist_cache_->length);
					$storage[0] = $this->last_byte_;
					$storage_ix[0] = $this->last_byte_bits_;
					if(!encode_Brotli_bit_stream::StoreUncompressedMetaBlock($is_last, $data, $this->last_flush_pos_, $mask, $bytes, $storage_ix, $storage, 0)) {
						return false;
					}
				}
			}
		}
		$this->last_byte_ = $storage[$storage_ix->a[0] >> 3];
		$this->last_byte_bits_ = $storage_ix->a[0] & 7;
		$this->last_flush_pos_ = $this->input_pos_;
		$this->last_processed_pos_ = $this->input_pos_;
		$this->prev_byte_ = $data[$this->last_flush_pos_ - 1 & $mask];
		$this->prev_byte2_ = $data[$this->last_flush_pos_ - 2 & $mask];
		$this->num_commands_ = 0;
		$this->num_literals_ = 0;
		DefaultFunctions::memcpy_Int($this->saved_dist_cache_, 0, $this->dist_cache_, 0, $this->dist_cache_->length);
		$output[0] = $storage;
		$out_size[0] = $storage_ix->a[0] >> 3;
		return true;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'encode.encode.BrotliCompressor'; }
}
