<?php

// Generated by Haxe 3.4.0
class encode_Bit_cost {
	public function __construct() {}
	static function BitsEntropy($population, $population_off, $size) {
		$sum = 0;
		$retval = 0;
		$population_end_off = $population_off + $size;
		$p = null;
		if(($size & 1) > 0) {
			$population_off = $population_off + 1;
			$p = $population[$population_off - 1];
			$sum = $p;
			$retval = $retval - $p * encode_Fast_log::FastLog2($p);
		}
		while($population_off < $population_end_off) {
			$population_off = $population_off + 1;
			$p = $population[$population_off - 1];
			$sum = $sum + $p;
			$retval = $retval - $p * encode_Fast_log::FastLog2($p);
			$population_off = $population_off + 1;
			$p = $population[$population_off - 1];
			$sum = $sum + $p;
			$retval = $retval - $p * encode_Fast_log::FastLog2($p);
		}
		if($sum > 0) {
			$retval = $retval + $sum * encode_Fast_log::FastLog2($sum);
		}
		if($retval < $sum) {
			$retval = $sum;
		}
		return $retval;
	}
	static function PopulationCost($histogram) {
		$kSize = $histogram->data_->length;
		if($histogram->total_count_ === 0) {
			return 12;
		}
		$count = 0;
		{
			$_g1 = 0;
			while($_g1 < $kSize) {
				$_g1 = $_g1 + 1;
				if($histogram->data_->a[$_g1 - 1] > 0) {
					$count = $count + 1;
				}
			}
		}
		if($count === 1) {
			return 12;
		}
		if($count === 2) {
			return 20 + $histogram->total_count_;
		}
		$bits = 0;
		$depth = FunctionMalloc::mallocUInt($kSize);
		if($count <= 4) {
			encode_Entropy_encode::CreateHuffmanTree($histogram->data_, 0, $kSize, 15, $depth, 0);
			{
				$_g11 = 0;
				while($_g11 < $kSize) {
					$_g11 = $_g11 + 1;
					$i = $_g11 - 1;
					$int = $histogram->data_[$i] * $depth[$i];
					$bits1 = null;
					if($int < 0) {
						$bits1 = 4294967296.0 + $int;
					} else {
						$bits1 = $int + 0.0;
					}
					$bits = $bits1 + $bits;
					unset($int,$i,$bits1);
				}
			}
			if($count === 3) {
				return $bits + 28;
			} else {
				return $bits + 37;
			}
		}
		$max_depth = 1;
		$depth_histo = FunctionMalloc::mallocInt(18);
		$log2total = encode_Fast_log::FastLog2($histogram->total_count_);
		$i1 = 0;
		while($i1 < $kSize) {
			if($histogram->data_->a[$i1] > 0) {
				$log2p = $log2total - encode_Fast_log::FastLog2($histogram->data_[$i1]);
				$depth1 = Std::int($log2p + 0.5);
				$bits = $bits + $histogram->data_->a[$i1] * $log2p;
				if($depth1 > 15) {
					$depth1 = 15;
				}
				if($depth1 > $max_depth) {
					$max_depth = $depth1;
				}
				{
					$_g = $depth1;
					$depth_histo[$_g] = $depth_histo[$_g] + 1;
					unset($_g);
				}
				$i1 = $i1 + 1;
				unset($log2p,$depth1);
			} else {
				$reps = 1;
				$k = $i1 + 1;
				while(true) {
					$tmp = null;
					if($k < $kSize) {
						$tmp = $histogram->data_[$k] === 0;
					} else {
						$tmp = false;
					}
					if(!$tmp) {
						break;
					}
					$reps = $reps + 1;
					$k = $k + 1;
					unset($tmp);
				}
				$i1 = $i1 + $reps;
				if($i1 === $kSize) {
					break;
				}
				if($reps < 3) {
					$depth_histo[0] = $depth_histo[0] + $reps;
				} else {
					$reps = $reps - 2;
					while($reps > 0) {
						$depth_histo[17] = $depth_histo[17] + 1;
						$bits = $bits + 3;
						$reps = $reps >> 3;
					}
				}
				unset($reps,$k);
			}
		}
		$bits = $bits + (18 + 2 * $max_depth);
		$bits = $bits + encode_Bit_cost::BitsEntropy($depth_histo, 0, 18);
		return $bits;
	}
	function __toString() { return 'encode.Bit_cost'; }
}
