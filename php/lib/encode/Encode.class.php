<?php

// Generated by Haxe 3.4.0
class encode_Encode {
	public function __construct() {}
	static $kMaxWindowBits = 24;
	static $kMinWindowBits = 16;
	static $kMinInputBlockBits = 16;
	static $kMaxInputBlockBits = 24;
	static $kMinUTF8Ratio = 0.75;
	static $kMinQualityForBlockSplit = 4;
	static $kMinQualityForContextModeling = 5;
	static $kMinQualityForOptimizeHistograms = 4;
	static function ParseAsUTF8($symbol, $input, $input_off, $size) {
		if(($input[$input_off] & 128) === 0) {
			$symbol[0] = $input[$input_off];
			if($symbol->a[0] > 0) {
				return 1;
			}
		}
		$tmp = null;
		$tmp1 = null;
		if($size > 1) {
			$tmp1 = ($input[$input_off] & 224) === 192;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			$tmp = ($input[$input_off + 1] & 192) === 128;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$symbol[0] = ($input[$input_off] & 31) << 6 | $input[$input_off + 1] & 63;
			if($symbol->a[0] > 127) {
				return 2;
			}
		}
		$tmp2 = null;
		$tmp3 = null;
		$tmp4 = null;
		if($size > 2) {
			$tmp4 = ($input[$input_off] & 240) === 224;
		} else {
			$tmp4 = false;
		}
		if($tmp4) {
			$tmp3 = ($input[$input_off + 1] & 192) === 128;
		} else {
			$tmp3 = false;
		}
		if($tmp3) {
			$tmp2 = ($input[$input_off + 2] & 192) === 128;
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			$symbol[0] = ($input[$input_off] & 15) << 12 | ($input[$input_off + 1] & 63) << 6 | $input[$input_off + 2] & 63;
			if($symbol->a[0] > 2047) {
				return 3;
			}
		}
		$tmp5 = null;
		$tmp6 = null;
		$tmp7 = null;
		$tmp8 = null;
		if($size > 3) {
			$tmp8 = ($input[$input_off] & 248) === 240;
		} else {
			$tmp8 = false;
		}
		if($tmp8) {
			$tmp7 = ($input[$input_off + 1] & 192) === 128;
		} else {
			$tmp7 = false;
		}
		if($tmp7) {
			$tmp6 = ($input[$input_off + 2] & 192) === 128;
		} else {
			$tmp6 = false;
		}
		if($tmp6) {
			$tmp5 = ($input[$input_off + 3] & 192) === 128;
		} else {
			$tmp5 = false;
		}
		if($tmp5) {
			$symbol[0] = ($input[$input_off] & 7) << 18 | ($input[$input_off + 1] & 63) << 12 | ($input[$input_off + 2] & 63) << 6 | $input[$input_off + 3] & 63;
			$tmp9 = null;
			if($symbol->a[0] > 65535) {
				$tmp9 = $symbol->a[0] <= 1114111;
			} else {
				$tmp9 = false;
			}
			if($tmp9) {
				return 4;
			}
		}
		$symbol[0] = 1114112 | $input[$input_off];
		return 1;
	}
	static function IsMostlyUTF8($data, $data_off, $length, $min_fraction) {
		$size_utf8 = 0;
		$pos = 0;
		while($pos < $length) {
			$symbol = new _hx_array(array());
			$bytes_read = encode_Encode::ParseAsUTF8($symbol, $data, $data_off + $pos, $length - $pos);
			$pos = $pos + $bytes_read;
			if($symbol->a[0] < 1114112) {
				$size_utf8 = $size_utf8 + $bytes_read;
			}
			unset($symbol,$bytes_read);
		}
		return $size_utf8 > $min_fraction * $length;
	}
	static function RecomputeDistancePrefixes($cmds, $num_commands, $num_direct_distance_codes, $distance_postfix_bits) {
		$tmp = null;
		if($num_direct_distance_codes === 0) {
			$tmp = $distance_postfix_bits === 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return;
		}
		{
			$_g1 = 0;
			while($_g1 < $num_commands) {
				$_g1 = $_g1 + 1;
				$cmd = $cmds[$_g1 - 1];
				$tmp1 = null;
				if($cmd->copy_len_ > 0) {
					$a = $cmd->cmd_prefix_[0];
					$aNeg = $a < 0;
					if($aNeg !== false) {
						$tmp1 = $aNeg;
					} else {
						$tmp1 = $a >= 128;
					}
					unset($aNeg,$a);
				} else {
					$tmp1 = false;
				}
				if($tmp1) {
					encode_Prefix::PrefixEncodeCopyDistance($cmd->DistanceCode(), $num_direct_distance_codes, $distance_postfix_bits, $cmd->dist_prefix_, $cmd->dist_extra_);
				}
				unset($tmp1,$cmd);
			}
		}
	}
	static function DecideOverLiteralContextModeling($input, $start_pos, $length, $mask, $quality, $literal_context_mode, $num_literal_contexts, $literal_context_map) {
		$tmp = null;
		if($quality >= encode_Encode::$kMinQualityForContextModeling) {
			$tmp = $length < 64;
		} else {
			$tmp = true;
		}
		if($tmp) {
			return;
		}
		$end_pos = $start_pos + $length;
		while($start_pos + 64 < $end_pos) {
			$stride_end_pos = $start_pos + 64;
			$prev = $input[$start_pos & $mask];
			{
				$_g1 = $start_pos + 1;
				while($_g1 < $stride_end_pos) {
					$_g1 = $_g1 + 1;
					$literal = $input[$_g1 - 1 & $mask];
					$tmp1 = null;
					$tmp2 = null;
					$tmp3 = null;
					if(false !== $prev < 0) {
						$tmp3 = false;
					} else {
						$tmp3 = 128 > $prev;
					}
					if($tmp3) {
						$tmp2 = ($literal & 192) === 128;
					} else {
						$tmp2 = false;
					}
					if(!$tmp2) {
						$aNeg = $prev < 0;
						$tmp4 = null;
						if($aNeg !== false) {
							$tmp4 = $aNeg;
						} else {
							$tmp4 = $prev >= 192;
						}
						if($tmp4) {
							$tmp1 = ($literal & 192) !== 128;
						} else {
							$tmp1 = false;
						}
						unset($tmp4,$aNeg);
					} else {
						$tmp1 = true;
					}
					if($tmp1) {
						return;
					}
					$prev = $literal;
					unset($tmp3,$tmp2,$tmp1,$literal);
				}
				unset($_g1);
			}
			$start_pos = $start_pos + 4096;
			unset($stride_end_pos,$prev);
		}
		$literal_context_mode[0] = 2;
		$num_literal_contexts[0] = 2;
		$literal_context_map[0] = (new _hx_array(array(0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));
	}
	static function CopyOneBlockToRingBuffer($r, $compressor) {
		$block_size = $compressor->input_block_size();
		$bytes_read = (new _hx_array(array(0)));
		$data = $r->Read($block_size, $bytes_read);
		if($data === null) {
			return 0;
		}
		$compressor->CopyInputToRingBuffer($bytes_read[0], $data);
		$remaining = $block_size - $bytes_read[0];
		while($remaining > 0) {
			$more_bytes_read = (new _hx_array(array(0)));
			$data = $r->Read($remaining, $more_bytes_read);
			if($data === null) {
				break;
			}
			$compressor->CopyInputToRingBuffer($more_bytes_read[0], $data);
			$bytes_read[0] = $bytes_read[0] + $more_bytes_read[0];
			$remaining = $remaining - $more_bytes_read[0];
			unset($more_bytes_read);
		}
		return $bytes_read[0];
	}
	static function BrotliInIsFinished($r) {
		$read_bytes = new _hx_array(array());
		return $r->Read(0, $read_bytes) === null;
	}
	static function BrotliCompress($params, $input, $output) {
		return encode_Encode::BrotliCompressWithCustomDictionary(0, null, $params, $input, $output);
	}
	static function BrotliCompressWithCustomDictionary($dictsize, $dict, $params, $input, $output) {
		$in_bytes = 0;
		$out_bytes = (new _hx_array(array(0)));
		$out = new _hx_array(array());
		$final_block = false;
		$compressor = new encode_encode_BrotliCompressor($params);
		if($dictsize !== 0) {
			$compressor->BrotliSetCustomDictionary($dictsize, $dict);
		}
		while(!$final_block) {
			$in_bytes = encode_Encode::CopyOneBlockToRingBuffer($input, $compressor);
			if($in_bytes !== 0) {
				$final_block = encode_Encode::BrotliInIsFinished($input);
			} else {
				$final_block = true;
			}
			$out_bytes[0] = 0;
			if(!$compressor->WriteBrotliData($final_block, false, $out_bytes, $out)) {
				return false;
			}
			$tmp = null;
			if($out_bytes->a[0] > 0) {
				$tmp = !$output->Write($out[0], $out_bytes[0]);
			} else {
				$tmp = false;
			}
			if($tmp) {
				return false;
			}
			unset($tmp);
		}
		return true;
	}
	function __toString() { return 'encode.Encode'; }
}
