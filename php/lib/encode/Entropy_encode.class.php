<?php

// Generated by Haxe 3.4.0
class encode_Entropy_encode {
	public function __construct() {}
	static $kCodeLengthCodes = 18;
	static function EntropyCodeLiteral() {
		return new encode_entropy_encode_EntropyCode(256);
	}
	static function EntropyCodeCommand() {
		return new encode_entropy_encode_EntropyCode(704);
	}
	static function EntropyCodeDistance() {
		return new encode_entropy_encode_EntropyCode(520);
	}
	static function EntropyCodeBlockLength() {
		return new encode_entropy_encode_EntropyCode(26);
	}
	static function EntropyCodeContextMap() {
		return new encode_entropy_encode_EntropyCode(272);
	}
	static function EntropyCodeBlockType() {
		return new encode_entropy_encode_EntropyCode(258);
	}
	static function SortHuffmanTree($v0, $v1) {
		if($v0->total_count_ === $v1->total_count_) {
			return $v1->index_right_or_value_ - $v0->index_right_or_value_;
		}
		if($v0->total_count_ < $v1->total_count_) {
			return -1;
		}
		return 1;
	}
	static function SetDepth($p, $pool, $pool_off, $depth, $depth_off, $level) {
		if($p->index_left_ >= 0) {
			$level = $level + 1;
			encode_Entropy_encode::SetDepth($pool[$pool_off + $p->index_left_], $pool, $pool_off, $depth, $depth_off, $level);
			encode_Entropy_encode::SetDepth($pool[$pool_off + $p->index_right_or_value_], $pool, $pool_off, $depth, $depth_off, $level);
		} else {
			$depth[$depth_off + $p->index_right_or_value_] = $level;
		}
	}
	static function CreateHuffmanTree($data, $data_off, $length, $tree_limit, $depth, $depth_off) {
		$count_limit = 1;
		while(true) {
			$tree = new _hx_array(array());
			$tree_off = 0;
			$i = $length - 1;
			while($i >= 0) {
				if($data[$i] > 0) {
					$count = Std::int(Math::max($data[$i], $count_limit));
					$huffmantree = new encode_entropy_encode_HuffmanTree();
					$huffmantree->HuffmanTree3($count, -1, $i);
					$tree_off = $tree_off + 1;
					$tree[$tree_off - 1] = $huffmantree;
					unset($huffmantree,$count);
				}
				$i = $i - 1;
			}
			$n = $tree->length;
			if($n === 1) {
				$depth[$depth_off + _hx_array_get($tree, 0)->index_right_or_value_] = 1;
				break;
			}
			$tree->sort((property_exists("encode_Entropy_encode", "SortHuffmanTree") ? encode_Entropy_encode::$SortHuffmanTree: array("encode_Entropy_encode", "SortHuffmanTree")));
			$huffmantree1 = new encode_entropy_encode_HuffmanTree();
			$huffmantree1->HuffmanTree3(2147483647, -1, -1);
			$tree_off = $tree_off + 1;
			$tree[$tree_off - 1] = $huffmantree1;
			$huffmantree2 = new encode_entropy_encode_HuffmanTree();
			$huffmantree2->HuffmanTree3(2147483647, -1, -1);
			$tree_off = $tree_off + 1;
			$tree[$tree_off - 1] = $huffmantree2;
			$i1 = 0;
			$j = $n + 1;
			$k = $n - 1;
			while($k > 0) {
				$left = null;
				$right = null;
				if(_hx_array_get($tree, $i1)->total_count_ <= _hx_array_get($tree, $j)->total_count_) {
					$left = $i1;
					$i1 = $i1 + 1;
				} else {
					$left = $j;
					$j = $j + 1;
				}
				if(_hx_array_get($tree, $i1)->total_count_ <= _hx_array_get($tree, $j)->total_count_) {
					$right = $i1;
					$i1 = $i1 + 1;
				} else {
					$right = $j;
					$j = $j + 1;
				}
				$j_end = $tree->length - 1;
				_hx_array_get($tree, $j_end)->total_count_ = _hx_array_get($tree, $left)->total_count_ + _hx_array_get($tree, $right)->total_count_;
				_hx_array_get($tree, $j_end)->index_left_ = $left;
				_hx_array_get($tree, $j_end)->index_right_or_value_ = $right;
				$huffmantree3 = new encode_entropy_encode_HuffmanTree();
				$huffmantree3->HuffmanTree3(2147483647, -1, -1);
				$tree_off = $tree_off + 1;
				$tree[$tree_off - 1] = $huffmantree3;
				$k = $k - 1;
				unset($right,$left,$j_end,$huffmantree3);
			}
			encode_Entropy_encode::SetDepth($tree[2 * $n - 1], $tree, 0, $depth, $depth_off, 0);
			$max_element = 0;
			{
				$_g1 = $depth_off;
				$_g = $depth_off + $length;
				while($_g1 < $_g) {
					$_g1 = $_g1 + 1;
					$i2 = $_g1 - 1;
					$a = $depth[$i2];
					$aNeg = $a < 0;
					$tmp = null;
					if($aNeg !== $max_element < 0) {
						$tmp = $aNeg;
					} else {
						$tmp = $a > $max_element;
					}
					if($tmp) {
						$max_element = $depth[$i2];
					}
					unset($tmp,$i2,$aNeg,$a);
				}
				unset($_g1,$_g);
			}
			if($max_element <= $tree_limit) {
				break;
			}
			$count_limit = $count_limit * 2;
			unset($tree_off,$tree,$n,$max_element,$k,$j,$i1,$i,$huffmantree2,$huffmantree1);
		}
	}
	static function Reverse($v, $start, $end) {
		$end = $end - 1;
		while($start < $end) {
			$tmp = $v[$start];
			$v[$start] = $v[$end];
			$v[$end] = $tmp;
			$start = $start + 1;
			$end = $end - 1;
			unset($tmp);
		}
	}
	static function WriteHuffmanTreeRepetitions($previous_value, $value, $repetitions, $tree, $extra_bits_data) {
		if($previous_value !== $value) {
			$tree->push($value);
			$extra_bits_data->push(0);
			$repetitions = $repetitions - 1;
		}
		if($repetitions === 7) {
			$tree->push($value);
			$extra_bits_data->push(0);
			$repetitions = $repetitions - 1;
		}
		if($repetitions < 3) {
			$_g1 = 0;
			$_g = $repetitions;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$tree->push($value);
				$extra_bits_data->push(0);
			}
		} else {
			$repetitions = $repetitions - 3;
			$start = $tree->length;
			while($repetitions >= 0) {
				$tree->push(16);
				$extra_bits_data->push($repetitions & 3);
				$repetitions = $repetitions >> 2;
				$repetitions = $repetitions - 1;
			}
			encode_Entropy_encode::Reverse($tree, $start, $tree->length);
			encode_Entropy_encode::Reverse($extra_bits_data, $start, $tree->length);
		}
	}
	static function WriteHuffmanTreeRepetitionsZeros($repetitions, $tree, $extra_bits_data) {
		if($repetitions === 11) {
			$tree->push(0);
			$extra_bits_data->push(0);
			$repetitions = $repetitions - 1;
		}
		if($repetitions < 3) {
			$_g1 = 0;
			$_g = $repetitions;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$tree->push(0);
				$extra_bits_data->push(0);
			}
		} else {
			$repetitions = $repetitions - 3;
			$start = $tree->length;
			while($repetitions >= 0) {
				$tree->push(17);
				$extra_bits_data->push($repetitions & 7);
				$repetitions = $repetitions >> 3;
				$repetitions = $repetitions - 1;
			}
			encode_Entropy_encode::Reverse($tree, $start, $tree->length);
			encode_Entropy_encode::Reverse($extra_bits_data, $start, $tree->length);
		}
	}
	static function OptimizeHuffmanCountsForRle($length, $counts) {
		$nonzero_count = 0;
		$stride = null;
		$limit = null;
		$sum = null;
		$good_for_rle = null;
		{
			$_g1 = 0;
			$_g = $length;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				if($counts[$_g1 - 1] > 0) {
					$nonzero_count = $nonzero_count + 1;
				}
			}
		}
		if($nonzero_count < 16) {
			return 1;
		}
		while($length >= 0) {
			if($length === 0) {
				return 1;
			}
			if($counts[$length - 1] !== 0) {
				break;
			}
			$length = $length - 1;
		}
		{
			$nonzeros = 0;
			$smallest_nonzero = 1073741824;
			{
				$_g11 = 0;
				$_g2 = $length;
				while($_g11 < $_g2) {
					$_g11 = $_g11 + 1;
					$i = $_g11 - 1;
					if($counts[$i] !== 0) {
						$nonzeros = $nonzeros + 1;
						if($smallest_nonzero > $counts[$i]) {
							$smallest_nonzero = $counts[$i];
						}
					}
					unset($i);
				}
			}
			if($nonzeros < 5) {
				return 1;
			}
			if($smallest_nonzero < 4) {
				if($length - $nonzeros < 6) {
					$_g12 = 1;
					$_g3 = $length - 1;
					while($_g12 < $_g3) {
						$_g12 = $_g12 + 1;
						$i1 = $_g12 - 1;
						$tmp = null;
						$tmp1 = null;
						if($counts[$i1 - 1] !== 0) {
							$tmp1 = $counts[$i1] === 0;
						} else {
							$tmp1 = false;
						}
						if($tmp1) {
							$tmp = $counts[$i1 + 1] !== 0;
						} else {
							$tmp = false;
						}
						if($tmp) {
							$counts[$i1] = 1;
						}
						unset($tmp1,$tmp,$i1);
					}
				}
			}
			if($nonzeros < 28) {
				return 1;
			}
		}
		$good_for_rle = FunctionMalloc::mallocUInt($length);
		if($good_for_rle === null) {
			return 0;
		}
		{
			$symbol = $counts[0];
			$stride1 = 0;
			{
				$_g13 = 0;
				$_g4 = $length + 1;
				while($_g13 < $_g4) {
					$_g13 = $_g13 + 1;
					$i2 = $_g13 - 1;
					$tmp2 = null;
					if($i2 !== $length) {
						$tmp2 = $counts[$i2] !== $symbol;
					} else {
						$tmp2 = true;
					}
					if($tmp2) {
						$tmp3 = null;
						$tmp4 = null;
						if($symbol === 0) {
							$tmp4 = $stride1 >= 5;
						} else {
							$tmp4 = false;
						}
						if(!$tmp4) {
							if($symbol !== 0) {
								$tmp3 = $stride1 >= 7;
							} else {
								$tmp3 = false;
							}
						} else {
							$tmp3 = true;
						}
						if($tmp3) {
							$_g31 = 0;
							$_g21 = $stride1;
							while($_g31 < $_g21) {
								$_g31 = $_g31 + 1;
								$good_for_rle[$i2 - ($_g31 - 1) - 1] = 1;
							}
							unset($_g31,$_g21);
						}
						$stride1 = 1;
						if($i2 !== $length) {
							$symbol = $counts[$i2];
						}
						unset($tmp4,$tmp3);
					} else {
						$stride1 = $stride1 + 1;
					}
					unset($tmp2,$i2);
				}
			}
		}
		$stride = 0;
		$limit = Std::int(256 * ($counts[0] + $counts[1] + $counts[2]) / 3) + 420;
		$sum = 0;
		{
			$_g14 = 0;
			$_g5 = $length + 1;
			while($_g14 < $_g5) {
				$_g14 = $_g14 + 1;
				$i3 = $_g14 - 1;
				$tmp5 = null;
				$tmp6 = null;
				$tmp7 = null;
				if($i3 !== $length) {
					$a = $good_for_rle[$i3];
					$aNeg = $a < 0;
					if($aNeg !== false) {
						$tmp7 = $aNeg;
					} else {
						$tmp7 = $a > 0;
					}
					unset($aNeg,$a);
				} else {
					$tmp7 = true;
				}
				if(!$tmp7) {
					if($i3 !== 0) {
						$a1 = $good_for_rle[$i3 - 1];
						$aNeg1 = $a1 < 0;
						if($aNeg1 !== false) {
							$tmp6 = $aNeg1;
						} else {
							$tmp6 = $a1 > 0;
						}
						unset($aNeg1,$a1);
					} else {
						$tmp6 = false;
					}
				} else {
					$tmp6 = true;
				}
				if(!$tmp6) {
					$tmp5 = Math::abs(256 * $counts[$i3] - $limit) >= 1240;
				} else {
					$tmp5 = true;
				}
				if($tmp5) {
					$tmp8 = null;
					if($stride < 4) {
						if($stride >= 3) {
							$tmp8 = $sum === 0;
						} else {
							$tmp8 = false;
						}
					} else {
						$tmp8 = true;
					}
					if($tmp8) {
						$count = Std::int(($sum + Std::int($stride / 2)) / $stride);
						if($count < 1) {
							$count = 1;
						}
						if($sum === 0) {
							$count = 0;
						}
						{
							$_g32 = 0;
							$_g22 = $stride;
							while($_g32 < $_g22) {
								$_g32 = $_g32 + 1;
								$counts[$i3 - ($_g32 - 1) - 1] = $count;
							}
							unset($_g32,$_g22);
						}
						unset($count);
					}
					$stride = 0;
					$sum = 0;
					if($i3 < $length - 2) {
						$limit = Std::int(256 * ($counts[$i3] + $counts[$i3 + 1] + $counts[$i3 + 2]) / 3) + 420;
					} else {
						if($i3 < $length) {
							$limit = 256 * $counts[$i3];
						} else {
							$limit = 0;
						}
					}
					unset($tmp8);
				}
				$stride = $stride + 1;
				if($i3 !== $length) {
					$sum = $sum + $counts[$i3];
					if($stride >= 4) {
						$limit = Std::int((256 * $sum + Std::int($stride / 2)) / $stride);
					}
					if($stride === 4) {
						$limit = $limit + 120;
					}
				}
				unset($tmp7,$tmp6,$tmp5,$i3);
			}
		}
		return 1;
	}
	static function DecideOverRleUse($depth, $depth_off, $length, $use_rle_for_non_zero, $use_rle_for_zero) {
		$total_reps_zero = 0;
		$total_reps_non_zero = 0;
		$count_reps_zero = 0;
		$count_reps_non_zero = 0;
		$i = 0;
		while($i < $length) {
			$value = $depth[$depth_off + $i];
			$reps = 1;
			$k = $i + 1;
			while(true) {
				$tmp = null;
				if($k < $length) {
					$tmp = $depth[$depth_off + $k] === $value;
				} else {
					$tmp = false;
				}
				if(!$tmp) {
					break;
				}
				$reps = $reps + 1;
				$k = $k + 1;
				unset($tmp);
			}
			$tmp1 = null;
			if($reps >= 3) {
				$tmp1 = $value === 0;
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				$total_reps_zero = $total_reps_zero + $reps;
				$count_reps_zero = $count_reps_zero + 1;
			}
			$tmp2 = null;
			if($reps >= 4) {
				$tmp2 = $value !== 0;
			} else {
				$tmp2 = false;
			}
			if($tmp2) {
				$total_reps_non_zero = $total_reps_non_zero + $reps;
				$count_reps_non_zero = $count_reps_non_zero + 1;
			}
			$i = $i + $reps;
			unset($value,$tmp2,$tmp1,$reps,$k);
		}
		$total_reps_non_zero = $total_reps_non_zero - $count_reps_non_zero * 2;
		$total_reps_zero = $total_reps_zero - $count_reps_zero * 2;
		$use_rle_for_non_zero[0] = $total_reps_non_zero > 2;
		$use_rle_for_zero[0] = $total_reps_zero > 2;
	}
	static function WriteHuffmanTree($depth, $depth_off, $length, $tree, $extra_bits_data) {
		$previous_value = 8;
		$new_length = $length;
		{
			$_g1 = 0;
			$_g = $length;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				if($depth[$depth_off + $length - ($_g1 - 1) - 1] === 0) {
					$new_length = $new_length - 1;
				} else {
					break;
				}
			}
		}
		$use_rle_for_non_zero = (new _hx_array(array(false)));
		$use_rle_for_zero = (new _hx_array(array(false)));
		$aNeg = $length < 0;
		$tmp = null;
		if($aNeg !== false) {
			$tmp = $aNeg;
		} else {
			$tmp = $length > 50;
		}
		if($tmp) {
			encode_Entropy_encode::DecideOverRleUse($depth, $depth_off, $new_length, $use_rle_for_non_zero, $use_rle_for_zero);
		}
		$i = 0;
		while($i < $new_length) {
			$value = $depth[$depth_off + $i];
			$reps = 1;
			$tmp1 = null;
			$tmp2 = null;
			if($value !== 0) {
				$tmp2 = $use_rle_for_non_zero[0];
			} else {
				$tmp2 = false;
			}
			if(!$tmp2) {
				if($value === 0) {
					$tmp1 = $use_rle_for_zero[0];
				} else {
					$tmp1 = false;
				}
			} else {
				$tmp1 = true;
			}
			if($tmp1) {
				$k = $i + 1;
				while(true) {
					$tmp3 = null;
					if($k < $new_length) {
						$tmp3 = $depth[$depth_off + $k] === $value;
					} else {
						$tmp3 = false;
					}
					if(!$tmp3) {
						break;
					}
					$reps = $reps + 1;
					$k = $k + 1;
					unset($tmp3);
				}
				unset($k);
			}
			if($value === 0) {
				encode_Entropy_encode::WriteHuffmanTreeRepetitionsZeros($reps, $tree, $extra_bits_data);
			} else {
				encode_Entropy_encode::WriteHuffmanTreeRepetitions($previous_value, $value, $reps, $tree, $extra_bits_data);
				$previous_value = $value;
			}
			$i = $i + $reps;
			unset($value,$tmp2,$tmp1,$reps);
		}
	}
	static function ReverseBits($num_bits, $bits) {
		$kLut = (new _hx_array(array(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)));
		$retval = $kLut[$bits & 15];
		$i = 4;
		while($i < $num_bits) {
			$retval = $retval << 4;
			$bits = _hx_shift_right($bits, 4);
			$retval = $retval | $kLut[$bits & 15];
			$i = $i + 4;
		}
		$retval = $retval >> (-$num_bits & 3);
		return $retval;
	}
	static function ConvertBitDepthsToSymbols($depth, $depth_off, $len, $bits, $bits_off) {
		$bl_count = FunctionMalloc::mallocUInt(16);
		{
			{
				$_g1 = 0;
				while($_g1 < $len) {
					$_g1 = $_g1 + 1;
					{
						$_g2 = $depth[$depth_off + ($_g1 - 1)];
						$bl_count[$_g2] = $bl_count[$_g2] + 1;
						unset($_g2);
					}
				}
			}
			$bl_count[0] = 0;
		}
		$this1 = (new _hx_array(array()));
		$this1->length = 16;
		$next_code = $this1;
		$next_code[0] = 0;
		{
			$code = 0;
			{
				$_g11 = 1;
				while($_g11 < 16) {
					$_g11 = $_g11 + 1;
					$_bits = $_g11 - 1;
					$code = $code + $bl_count[$_bits - 1] << 1;
					$next_code[$_bits] = $code;
					unset($_bits);
				}
			}
		}
		{
			$_g12 = 0;
			while($_g12 < $len) {
				$_g12 = $_g12 + 1;
				$i = $_g12 - 1;
				$a = $depth[$depth_off + $i];
				$aNeg = $a < 0;
				$tmp = null;
				if($aNeg !== false) {
					$tmp = $aNeg;
				} else {
					$tmp = $a > 0;
				}
				if($tmp) {
					$bits[$bits_off + $i] = encode_Entropy_encode::ReverseBits($depth[$depth_off + $i], $next_code[$depth[$depth_off + $i]]);
					{
						$_g21 = $depth[$depth_off + $i];
						$next_code[$_g21] = $next_code[$_g21] + 1;
						unset($_g21);
					}
				}
				unset($tmp,$i,$aNeg,$a);
			}
		}
	}
	function __toString() { return 'encode.Entropy_encode'; }
}
