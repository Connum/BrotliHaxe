<?php

// Generated by Haxe 3.4.0
class encode_metablock_BlockSplitter {
	public function __construct($HistogramTypeInt, $alphabet_size, $min_block_size, $split_threshold, $num_symbols, $split, $histograms) {
		if(!php_Boot::$skip_constructor) {
		$this->last_entropy_ = new _hx_array(array());
		$this->last_histogram_ix_ = new _hx_array(array());
		$this->HistogramTypeInt = $HistogramTypeInt;
		$this->alphabet_size_ = $alphabet_size;
		$this->min_block_size_ = $min_block_size;
		$this->split_threshold_ = $split_threshold;
		$this->num_blocks_ = 0;
		$this->split_ = $split;
		$this->histograms_ = $histograms;
		$this->target_block_size_ = $min_block_size;
		$this->block_size_ = 0;
		$this->curr_histogram_ix_ = 0;
		$this->merge_last_count_ = 0;
		$max_num_blocks = Std::int($num_symbols / $min_block_size) + 1;
		$max_num_types = Std::int(Math::min($max_num_blocks, encode_metablock_BlockSplitter::$kMaxBlockTypes + 1));
		$this->split_->lengths = new _hx_array(array());
		$this->split_->types = new _hx_array(array());
		{
			$_g1 = 0;
			while($_g1 < $max_num_types) {
				$_g1 = $_g1 + 1;
				$tmp = $this->histograms_;
				$tmp->push(new encode_histogram_Histogram($HistogramTypeInt));
				unset($tmp);
			}
		}
		$this->last_histogram_ix_[1] = 0;
		$this->last_histogram_ix_[0] = 0;
	}}
	public function AddSymbol($symbol) {
		_hx_array_get($this->histograms_, $this->curr_histogram_ix_)->Add1($symbol);
		++$this->block_size_;
		if($this->block_size_ === $this->target_block_size_) {
			$this->FinishBlock(false);
		}
	}
	public function FinishBlock($is_final) {
		if($this->block_size_ < $this->min_block_size_) {
			$this->block_size_ = $this->min_block_size_;
		}
		if($this->num_blocks_ === 0) {
			$this->split_->lengths[0] = $this->block_size_;
			$this->split_->types[0] = 0;
			$this->last_entropy_[0] = encode_Bit_cost::BitsEntropy(_hx_array_get($this->histograms_, 0)->data_, 0, $this->alphabet_size_);
			$this->last_entropy_[1] = $this->last_entropy_[0];
			++$this->num_blocks_;
			++$this->split_->num_types;
			++$this->curr_histogram_ix_;
			$this->block_size_ = 0;
		} else {
			if($this->block_size_ > 0) {
				$entropy = encode_Bit_cost::BitsEntropy(_hx_array_get($this->histograms_, $this->curr_histogram_ix_)->data_, 0, $this->alphabet_size_);
				$combined_histo = new encode_histogram_Histogram($this->HistogramTypeInt);
				$combined_histo1 = (new _hx_array(array($combined_histo, new encode_histogram_Histogram($this->HistogramTypeInt))));
				$combined_entropy = FunctionMalloc::mallocFloat(2);
				$diff = FunctionMalloc::mallocFloat(2);
				{
					$_g = 0;
					while($_g < 2) {
						$_g = $_g + 1;
						$j = $_g - 1;
						$last_histogram_ix = $this->last_histogram_ix_[$j];
						_hx_array_get($combined_histo1, $j)->bit_cost_ = _hx_array_get($this->histograms_, $this->curr_histogram_ix_)->bit_cost_;
						{
							$_g2 = 0;
							$_g1 = _hx_array_get($this->histograms_, $this->curr_histogram_ix_)->data_->length;
							while($_g2 < $_g1) {
								$_g2 = $_g2 + 1;
								$a = $_g2 - 1;
								_hx_array_get($combined_histo1, $j)->data_[$a] = _hx_array_get($this->histograms_, $this->curr_histogram_ix_)->data_[$a];
								unset($a);
							}
							unset($_g2,$_g1);
						}
						_hx_array_get($combined_histo1, $j)->kDataSize = _hx_array_get($this->histograms_, $this->curr_histogram_ix_)->kDataSize;
						_hx_array_get($combined_histo1, $j)->total_count_ = _hx_array_get($this->histograms_, $this->curr_histogram_ix_)->total_count_;
						_hx_array_get($combined_histo1, $j)->AddHistogram($this->histograms_[$last_histogram_ix]);
						$combined_entropy[$j] = encode_Bit_cost::BitsEntropy(_hx_array_get($combined_histo1, $j)->data_, 0, $this->alphabet_size_);
						$diff[$j] = $combined_entropy[$j] - $entropy - $this->last_entropy_[$j];
						unset($last_histogram_ix,$j);
					}
				}
				$tmp = null;
				$tmp1 = null;
				if($this->split_->num_types < encode_metablock_BlockSplitter::$kMaxBlockTypes) {
					$tmp1 = $diff[0] > $this->split_threshold_;
				} else {
					$tmp1 = false;
				}
				if($tmp1) {
					$tmp = $diff[1] > $this->split_threshold_;
				} else {
					$tmp = false;
				}
				if($tmp) {
					$this->split_->lengths[$this->num_blocks_] = $this->block_size_;
					$this->split_->types[$this->num_blocks_] = $this->split_->num_types;
					$this->last_histogram_ix_[1] = $this->last_histogram_ix_[0];
					$this->last_histogram_ix_[0] = $this->split_->num_types;
					$this->last_entropy_[1] = $this->last_entropy_[0];
					$this->last_entropy_[0] = $entropy;
					++$this->num_blocks_;
					++$this->split_->num_types;
					++$this->curr_histogram_ix_;
					$this->block_size_ = 0;
					$this->merge_last_count_ = 0;
					$this->target_block_size_ = $this->min_block_size_;
				} else {
					if($diff[1] < $diff[0] - 20.0) {
						$this->split_->lengths[$this->num_blocks_] = $this->block_size_;
						$this->split_->types[$this->num_blocks_] = $this->split_->types[$this->num_blocks_ - 2];
						$t = $this->last_histogram_ix_[0];
						$this->last_histogram_ix_[0] = $this->last_histogram_ix_[1];
						$this->last_histogram_ix_[1] = $t;
						_hx_array_get($this->histograms_, $this->last_histogram_ix_[0])->bit_cost_ = _hx_array_get($combined_histo1, 1)->bit_cost_;
						{
							$_g11 = 0;
							$_g3 = _hx_array_get($combined_histo1, 1)->data_->length;
							while($_g11 < $_g3) {
								$_g11 = $_g11 + 1;
								$a1 = $_g11 - 1;
								_hx_array_get($this->histograms_, $this->last_histogram_ix_[0])->data_[$a1] = _hx_array_get($combined_histo1, 1)->data_[$a1];
								unset($a1);
							}
						}
						_hx_array_get($this->histograms_, $this->last_histogram_ix_[0])->kDataSize = _hx_array_get($combined_histo1, 1)->kDataSize;
						_hx_array_get($this->histograms_, $this->last_histogram_ix_[0])->total_count_ = _hx_array_get($combined_histo1, 1)->total_count_;
						$this->last_entropy_[1] = $this->last_entropy_[0];
						$this->last_entropy_[0] = $combined_entropy[1];
						++$this->num_blocks_;
						$this->block_size_ = 0;
						_hx_array_get($this->histograms_, $this->curr_histogram_ix_)->Clear();
						$this->merge_last_count_ = 0;
						$this->target_block_size_ = $this->min_block_size_;
					} else {
						$tmp2 = $this->split_->lengths;
						$tmp3 = $this->num_blocks_ - 1;
						$tmp2[$tmp3] = $tmp2->a[$tmp3] + $this->block_size_;
						_hx_array_get($this->histograms_, $this->last_histogram_ix_[0])->bit_cost_ = _hx_array_get($combined_histo1, 0)->bit_cost_;
						{
							$_g12 = 0;
							$_g4 = _hx_array_get($combined_histo1, 0)->data_->length;
							while($_g12 < $_g4) {
								$_g12 = $_g12 + 1;
								$a2 = $_g12 - 1;
								_hx_array_get($this->histograms_, $this->last_histogram_ix_[0])->data_[$a2] = _hx_array_get($combined_histo1, 0)->data_[$a2];
								unset($a2);
							}
						}
						_hx_array_get($this->histograms_, $this->last_histogram_ix_[0])->kDataSize = _hx_array_get($combined_histo1, 0)->kDataSize;
						_hx_array_get($this->histograms_, $this->last_histogram_ix_[0])->total_count_ = _hx_array_get($combined_histo1, 0)->total_count_;
						$this->last_entropy_[0] = $combined_entropy[0];
						if($this->split_->num_types === 1) {
							$this->last_entropy_[1] = $this->last_entropy_[0];
						}
						$this->block_size_ = 0;
						_hx_array_get($this->histograms_, $this->curr_histogram_ix_)->Clear();
						if(++$this->merge_last_count_ > 1) {
							$tmp4 = $this;
							$tmp4->target_block_size_ = $tmp4->target_block_size_ + $this->min_block_size_;
						}
					}
				}
			}
		}
		if($is_final) {
			while($this->histograms_->length > $this->split_->num_types) {
				$this->histograms_->pop();
			}
			while($this->split_->types->length > $this->num_blocks_) {
				$this->split_->types->pop();
			}
			while($this->split_->lengths->length > $this->num_blocks_) {
				$this->split_->lengths->pop();
			}
		}
	}
	public $HistogramTypeInt;
	public $alphabet_size_;
	public $min_block_size_;
	public $split_threshold_;
	public $num_blocks_;
	public $split_;
	public $histograms_;
	public $target_block_size_;
	public $block_size_;
	public $curr_histogram_ix_;
	public $last_histogram_ix_;
	public $last_entropy_;
	public $merge_last_count_;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $kMaxBlockTypes = 256;
	function __toString() { return 'encode.metablock.BlockSplitter'; }
}
