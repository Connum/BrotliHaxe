<?php

// Generated by Haxe 3.4.0
class encode_metablock_ContextBlockSplitter {
	public function __construct($HistogramTypeInt, $alphabet_size, $num_contexts, $min_block_size, $split_threshold, $num_symbols, $split, $histograms) {
		if(!php_Boot::$skip_constructor) {
		$this1 = (new _hx_array(array()));
		$this1->length = 2;
		$this->last_histogram_ix_ = $this1;
		$this->HistogramTypeInt = $HistogramTypeInt;
		$this->alphabet_size_ = $alphabet_size;
		$this->num_contexts_ = $num_contexts;
		$this->max_block_types_ = Std::int(encode_metablock_ContextBlockSplitter::$kMaxBlockTypes / $num_contexts);
		$this->min_block_size_ = $min_block_size;
		$this->split_threshold_ = $split_threshold;
		$this->num_blocks_ = 0;
		$this->split_ = $split;
		$this->histograms_ = $histograms;
		$this->target_block_size_ = $min_block_size;
		$this->block_size_ = 0;
		$this->curr_histogram_ix_ = 0;
		$this->last_entropy_ = FunctionMalloc::mallocFloat(2 * $num_contexts);
		$this->merge_last_count_ = 0;
		$max_num_blocks = Std::int($num_symbols / $min_block_size) + 1;
		$max_num_types = Std::int(Math::min($max_num_blocks, $this->max_block_types_ + 1));
		$this->split_->lengths = new _hx_array(array());
		$this->split_->types = new _hx_array(array());
		{
			$_g1 = 0;
			$_g = $max_num_types * $num_contexts;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$tmp = $this->histograms_;
				$tmp->push(new encode_histogram_Histogram($HistogramTypeInt));
				unset($tmp);
			}
		}
		{
			$this->last_histogram_ix_[1] = 0;
			$this->last_histogram_ix_[0] = 0;
		}
	}}
	public function AddSymbol($symbol, $context) {
		_hx_array_get($this->histograms_, $this->curr_histogram_ix_ + $context)->Add1($symbol);
		++$this->block_size_;
		if($this->block_size_ === $this->target_block_size_) {
			$this->FinishBlock(false);
		}
	}
	public function FinishBlock($is_final) {
		if($this->block_size_ < $this->min_block_size_) {
			$this->block_size_ = $this->min_block_size_;
		}
		if($this->num_blocks_ === 0) {
			$this->split_->lengths[0] = $this->block_size_;
			$this->split_->types[0] = 0;
			{
				$_g1 = 0;
				$_g = $this->num_contexts_;
				while($_g1 < $_g) {
					$_g1 = $_g1 + 1;
					$i = $_g1 - 1;
					$this->last_entropy_[$i] = encode_Bit_cost::BitsEntropy(_hx_array_get($this->histograms_, $i)->data_, 0, $this->alphabet_size_);
					$this->last_entropy_[$this->num_contexts_ + $i] = $this->last_entropy_[$i];
					unset($i);
				}
			}
			++$this->num_blocks_;
			++$this->split_->num_types;
			$tmp = $this;
			$tmp->curr_histogram_ix_ = $tmp->curr_histogram_ix_ + $this->num_contexts_;
			$this->block_size_ = 0;
		} else {
			if($this->block_size_ > 0) {
				$this1 = (new _hx_array(array()));
				$this1->length = $this->num_contexts_;
				$entropy = $this1;
				$this2 = (new _hx_array(array()));
				$this2->length = 2 * $this->num_contexts_;
				$combined_histo = $this2;
				{
					$_g11 = 0;
					$_g2 = 2 * $this->num_contexts_;
					while($_g11 < $_g2) {
						$_g11 = $_g11 + 1;
						{
							$val = new encode_histogram_Histogram($this->HistogramTypeInt);
							$combined_histo[$_g11 - 1] = $val;
							unset($val);
						}
					}
				}
				$this3 = (new _hx_array(array()));
				$this3->length = 2 * $this->num_contexts_;
				$combined_entropy = $this3;
				$diff = (new _hx_array(array(0.0, 0.0)));
				{
					$_g12 = 0;
					$_g3 = $this->num_contexts_;
					while($_g12 < $_g3) {
						$_g12 = $_g12 + 1;
						$i1 = $_g12 - 1;
						$curr_histo_ix = $this->curr_histogram_ix_ + $i1;
						$entropy[$i1] = encode_Bit_cost::BitsEntropy(_hx_array_get($this->histograms_, $curr_histo_ix)->data_, 0, $this->alphabet_size_);
						{
							$_g21 = 0;
							while($_g21 < 2) {
								$_g21 = $_g21 + 1;
								$j = $_g21 - 1;
								$jx = $j * $this->num_contexts_ + $i1;
								$last_histogram_ix = $this->last_histogram_ix_->a[$j] + $i1;
								$combined_histo[$jx]->bit_cost_ = _hx_array_get($this->histograms_, $curr_histo_ix)->bit_cost_;
								{
									$_g4 = 0;
									$_g31 = _hx_array_get($this->histograms_, $curr_histo_ix)->data_->length;
									while($_g4 < $_g31) {
										$_g4 = $_g4 + 1;
										$a = $_g4 - 1;
										$combined_histo[$jx]->data_[$a] = _hx_array_get($this->histograms_, $curr_histo_ix)->data_[$a];
										unset($a);
									}
									unset($_g4,$_g31);
								}
								$combined_histo[$jx]->kDataSize = _hx_array_get($this->histograms_, $curr_histo_ix)->kDataSize;
								$combined_histo[$jx]->total_count_ = _hx_array_get($this->histograms_, $curr_histo_ix)->total_count_;
								$combined_histo[$jx]->AddHistogram($this->histograms_[$last_histogram_ix]);
								$combined_entropy[$jx] = encode_Bit_cost::BitsEntropy($combined_histo[$jx]->data_, 0, $this->alphabet_size_);
								$diff[$j] = $diff->a[$j] + ($combined_entropy[$jx] - $entropy[$i1] - $this->last_entropy_[$jx]);
								unset($last_histogram_ix,$jx,$j);
							}
							unset($_g21);
						}
						unset($i1,$curr_histo_ix);
					}
				}
				$tmp1 = null;
				$tmp2 = null;
				if($this->split_->num_types < $this->max_block_types_) {
					$tmp2 = $diff->a[0] > $this->split_threshold_;
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$tmp1 = $diff->a[1] > $this->split_threshold_;
				} else {
					$tmp1 = false;
				}
				if($tmp1) {
					$this->split_->lengths[$this->num_blocks_] = $this->block_size_;
					$this->split_->types[$this->num_blocks_] = $this->split_->num_types;
					$this->last_histogram_ix_[1] = $this->last_histogram_ix_[0];
					$this->last_histogram_ix_[0] = $this->split_->num_types * $this->num_contexts_;
					{
						$_g13 = 0;
						$_g5 = $this->num_contexts_;
						while($_g13 < $_g5) {
							$_g13 = $_g13 + 1;
							$i2 = $_g13 - 1;
							$this->last_entropy_[$this->num_contexts_ + $i2] = $this->last_entropy_[$i2];
							$this->last_entropy_[$i2] = $entropy[$i2];
							unset($i2);
						}
					}
					++$this->num_blocks_;
					++$this->split_->num_types;
					$tmp3 = $this;
					$tmp3->curr_histogram_ix_ = $tmp3->curr_histogram_ix_ + $this->num_contexts_;
					$this->block_size_ = 0;
					$this->merge_last_count_ = 0;
					$this->target_block_size_ = $this->min_block_size_;
				} else {
					if($diff->a[1] < $diff->a[0] - 20.0) {
						$this->split_->lengths[$this->num_blocks_] = $this->block_size_;
						$this->split_->types[$this->num_blocks_] = $this->split_->types[$this->num_blocks_ - 2];
						$t = $this->last_histogram_ix_[0];
						$this->last_histogram_ix_[0] = $this->last_histogram_ix_[1];
						$this->last_histogram_ix_[1] = $t;
						{
							$_g14 = 0;
							$_g6 = $this->num_contexts_;
							while($_g14 < $_g6) {
								$_g14 = $_g14 + 1;
								$i3 = $_g14 - 1;
								_hx_array_get($this->histograms_, $this->last_histogram_ix_->a[0] + $i3)->bit_cost_ = _hx_array_get($combined_histo, $this->num_contexts_ + $i3)->bit_cost_;
								{
									$_g32 = 0;
									$_g22 = _hx_array_get($combined_histo, $this->num_contexts_ + $i3)->data_->length;
									while($_g32 < $_g22) {
										$_g32 = $_g32 + 1;
										$a1 = $_g32 - 1;
										_hx_array_get($this->histograms_, $this->last_histogram_ix_->a[0] + $i3)->data_[$a1] = _hx_array_get($combined_histo, $this->num_contexts_ + $i3)->data_[$a1];
										unset($a1);
									}
									unset($_g32,$_g22);
								}
								_hx_array_get($this->histograms_, $this->last_histogram_ix_->a[0] + $i3)->kDataSize = _hx_array_get($combined_histo, $this->num_contexts_ + $i3)->kDataSize;
								_hx_array_get($this->histograms_, $this->last_histogram_ix_->a[0] + $i3)->total_count_ = _hx_array_get($combined_histo, $this->num_contexts_ + $i3)->total_count_;
								$this->last_entropy_[$this->num_contexts_ + $i3] = $this->last_entropy_[$i3];
								$this->last_entropy_[$i3] = $combined_entropy[$this->num_contexts_ + $i3];
								_hx_array_get($this->histograms_, $this->curr_histogram_ix_ + $i3)->Clear();
								unset($i3);
							}
						}
						++$this->num_blocks_;
						$this->block_size_ = 0;
						$this->merge_last_count_ = 0;
						$this->target_block_size_ = $this->min_block_size_;
					} else {
						$tmp4 = $this->split_->lengths;
						$tmp5 = $this->num_blocks_ - 1;
						$tmp4[$tmp5] = $tmp4->a[$tmp5] + $this->block_size_;
						{
							$_g15 = 0;
							$_g7 = $this->num_contexts_;
							while($_g15 < $_g7) {
								$_g15 = $_g15 + 1;
								$i4 = $_g15 - 1;
								_hx_array_get($this->histograms_, $this->last_histogram_ix_->a[0] + $i4)->bit_cost_ = $combined_histo[$i4]->bit_cost_;
								{
									$_g33 = 0;
									$_g23 = $combined_histo[$i4]->data_->length;
									while($_g33 < $_g23) {
										$_g33 = $_g33 + 1;
										$a2 = $_g33 - 1;
										_hx_array_get($this->histograms_, $this->last_histogram_ix_->a[0] + $i4)->data_[$a2] = $combined_histo[$i4]->data_[$a2];
										unset($a2);
									}
									unset($_g33,$_g23);
								}
								_hx_array_get($this->histograms_, $this->last_histogram_ix_->a[0] + $i4)->kDataSize = $combined_histo[$i4]->kDataSize;
								_hx_array_get($this->histograms_, $this->last_histogram_ix_->a[0] + $i4)->total_count_ = $combined_histo[$i4]->total_count_;
								$this->last_entropy_[$i4] = $combined_entropy[$i4];
								if($this->split_->num_types === 1) {
									$this->last_entropy_[$this->num_contexts_ + $i4] = $this->last_entropy_[$i4];
								}
								_hx_array_get($this->histograms_, $this->curr_histogram_ix_ + $i4)->Clear();
								unset($i4);
							}
						}
						$this->block_size_ = 0;
						if(++$this->merge_last_count_ > 1) {
							$tmp6 = $this;
							$tmp6->target_block_size_ = $tmp6->target_block_size_ + $this->min_block_size_;
						}
					}
				}
			}
		}
		if($is_final) {
			while($this->histograms_->length > $this->split_->num_types * $this->num_contexts_) {
				$this->histograms_->pop();
			}
			while($this->split_->types->length > $this->num_blocks_) {
				$this->split_->types->pop();
			}
			while($this->split_->lengths->length > $this->num_blocks_) {
				$this->split_->lengths->pop();
			}
		}
	}
	public $HistogramTypeInt;
	public $alphabet_size_;
	public $num_contexts_;
	public $max_block_types_;
	public $min_block_size_;
	public $split_threshold_;
	public $num_blocks_;
	public $split_;
	public $histograms_;
	public $target_block_size_;
	public $block_size_;
	public $curr_histogram_ix_;
	public $last_histogram_ix_;
	public $last_entropy_;
	public $merge_last_count_;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $kMaxBlockTypes = 256;
	function __toString() { return 'encode.metablock.ContextBlockSplitter'; }
}
