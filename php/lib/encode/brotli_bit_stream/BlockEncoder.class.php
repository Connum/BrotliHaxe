<?php

// Generated by Haxe 3.4.0
class encode_brotli_bit_stream_BlockEncoder {
	public function __construct($alphabet_size, $num_block_types, $block_types, $block_lengths) {
		if(!php_Boot::$skip_constructor) {
		$this->block_split_code_ = new encode_brotli_bit_stream_BlockSplitCode();
		$this->alphabet_size_ = $alphabet_size;
		$this->num_block_types_ = $num_block_types;
		$this->block_types_ = $block_types;
		$this->block_lengths_ = $block_lengths;
		$this->block_ix_ = 0;
		$tmp = null;
		if($block_lengths->length === 0) {
			$tmp = 0;
		} else {
			$tmp = $block_lengths[0];
		}
		$this->block_len_ = $tmp;
		$this->entropy_ix_ = 0;
	}}
	public function BuildAndStoreBlockSwitchEntropyCodes($storage_ix, $storage) {
		encode_Brotli_bit_stream::BuildAndStoreBlockSplitCode($this->block_types_, $this->block_lengths_, $this->num_block_types_, $this->block_split_code_, $storage_ix, $storage);
	}
	public function BuildAndStoreEntropyCodes($histograms, $storage_ix, $storage) {
		$this->depths_ = FunctionMalloc::mallocUInt($histograms->length * $this->alphabet_size_);
		$this->bits_ = FunctionMalloc::mallocUInt($histograms->length * $this->alphabet_size_);
		{
			$_g1 = 0;
			$_g = $histograms->length;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$ix = $i * $this->alphabet_size_;
				encode_Brotli_bit_stream::BuildAndStoreHuffmanTree(_hx_array_get($histograms, $i)->data_, $this->alphabet_size_, $this->depths_, $ix, $this->bits_, $ix, $storage_ix, $storage);
				unset($ix,$i);
			}
		}
	}
	public function StoreSymbol($symbol, $storage_ix, $storage) {
		if($this->block_len_ === 0) {
			++$this->block_ix_;
			$this->block_len_ = $this->block_lengths_[$this->block_ix_];
			$this->entropy_ix_ = $this->block_types_->a[$this->block_ix_] * $this->alphabet_size_;
			encode_Brotli_bit_stream::StoreBlockSwitch($this->block_split_code_, $this->block_ix_, $storage_ix, $storage);
		}
		--$this->block_len_;
		$ix = $this->entropy_ix_ + $symbol;
		encode_Write_bits::WriteBits($this->depths_[$ix], $this->bits_[$ix], $storage_ix, $storage);
	}
	public function StoreSymbolWithContext($kContextBits, $symbol, $context, $context_map, $storage_ix, $storage) {
		if($this->block_len_ === 0) {
			++$this->block_ix_;
			$this->block_len_ = $this->block_lengths_[$this->block_ix_];
			$this->entropy_ix_ = $this->block_types_[$this->block_ix_] << $kContextBits;
			encode_Brotli_bit_stream::StoreBlockSwitch($this->block_split_code_, $this->block_ix_, $storage_ix, $storage);
		}
		--$this->block_len_;
		$ix = $context_map->a[$this->entropy_ix_ + $context] * $this->alphabet_size_ + $symbol;
		encode_Write_bits::WriteBits($this->depths_[$ix], $this->bits_[$ix], $storage_ix, $storage);
	}
	public $alphabet_size_;
	public $num_block_types_;
	public $block_types_;
	public $block_lengths_;
	public $block_split_code_;
	public $block_ix_;
	public $block_len_;
	public $entropy_ix_;
	public $depths_;
	public $bits_;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'encode.brotli_bit_stream.BlockEncoder'; }
}
