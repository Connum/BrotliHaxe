<?php

// Generated by Haxe 3.4.0
class encode_BinaryHeap {
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$this->arr = (new _hx_array(array()));
		$this->comp = (property_exists($this, "HistogramPairComparator") ? $this->HistogramPairComparator: array($this, "HistogramPairComparator"));
	}}
	public function HistogramPairComparator($p1, $p2) {
		if(!_hx_equal($p1->cost_diff, $p2->cost_diff)) {
			if($p1->cost_diff < $p2->cost_diff) {
				return 1;
			} else {
				return 0;
			}
		}
		$tmp = Math::abs($p1->idx1 - $p1->idx2);
		if($tmp < Math::abs($p2->idx1 - $p2->idx2)) {
			return 1;
		} else {
			return 0;
		}
	}
	public $comp;
	public $arr;
	public function swap($a, $b) {
		$temp = $this->arr[$a];
		$this->arr[$a] = $this->arr[$b];
		$this->arr[$b] = $temp;
	}
	public function bubbleDown($pos) {
		$left = 2 * $pos + 1;
		$right = $left + 1;
		$largest = $pos;
		$tmp = null;
		if($left < $this->arr->length) {
			$tmp = $this->comp($this->arr[$left], $this->arr[$pos]) > 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$largest = $left;
		}
		$tmp1 = null;
		if($right < $this->arr->length) {
			$tmp1 = $this->comp($this->arr[$right], $this->arr[$largest]) > 0;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			$largest = $right;
		}
		if($largest !== $pos) {
			$this->swap($largest, $pos);
			$this->bubbleDown($largest);
		}
	}
	public function bubbleUp($pos) {
		if($pos <= 0) {
			return;
		}
		$parent = Math::floor(($pos - 1) / 2);
		if($this->comp($this->arr[$pos], $this->arr[$parent]) > 0) {
			$this->swap($pos, $parent);
			$this->bubbleUp($parent);
		}
	}
	public function pop() {
		if($this->arr->length === 0) {
			return null;
		}
		$value = $this->arr[0];
		$last = $this->arr->length - 1;
		$this->arr[0] = $this->arr[$last];
		$this->arr->pop();
		if($last > 0) {
			$this->bubbleDown(0);
		}
		return $value;
	}
	public function push($value) {
		$this->arr->push($value);
		$this->bubbleUp($this->arr->length - 1);
	}
	public function size() {
		return $this->arr->length;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'encode.BinaryHeap'; }
}
