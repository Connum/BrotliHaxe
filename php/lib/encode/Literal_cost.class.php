<?php

// Generated by Haxe 3.4.0
class encode_Literal_cost {
	public function __construct() {}
	static function UTF8Position($last, $c, $clamp) {
		if($c < 128) {
			return 0;
		} else {
			if($c >= 192) {
				return Std::int(Math::min(1, $clamp));
			} else {
				if($last < 224) {
					return 0;
				} else {
					return Std::int(Math::min(2, $clamp));
				}
			}
		}
	}
	static function DecideMultiByteStatsLevel($pos, $len, $mask, $data) {
		$counts = (new _hx_array(array(0, 0, 0)));
		$max_utf8 = 1;
		$last_c = 0;
		$utf8_pos = 0;
		{
			$_g1 = 0;
			while($_g1 < $len) {
				$_g1 = $_g1 + 1;
				$c = $data[$pos + ($_g1 - 1) & $mask];
				$utf8_pos = encode_Literal_cost::UTF8Position($last_c, $c, 2);
				_hx_array_increment($counts,$utf8_pos);
				$last_c = $c;
				unset($c);
			}
		}
		if($counts->a[2] < 500) {
			$max_utf8 = 1;
		}
		if($counts->a[1] + $counts[2] < 25) {
			$max_utf8 = 0;
		}
		return $max_utf8;
	}
	static function EstimateBitCostsForLiteralsUTF8($pos, $len, $mask, $cost_mask, $data, $cost) {
		$max_utf8 = encode_Literal_cost::DecideMultiByteStatsLevel($pos, $len, $mask, $data);
		$histogram = FunctionMalloc::mallocInt(256);
		$histogram1 = FunctionMalloc::mallocInt(256);
		$histogram2 = (new _hx_array(array($histogram, $histogram1, FunctionMalloc::mallocInt(256))));
		$in_window = Std::int(Math::min(495, $len));
		$in_window_utf8 = (new _hx_array(array(0, 0, 0)));
		$last_c = 0;
		$utf8_pos = 0;
		{
			$_g1 = 0;
			while($_g1 < $in_window) {
				$_g1 = $_g1 + 1;
				$c = $data[$pos + ($_g1 - 1) & $mask];
				$histogram2[$utf8_pos][$c] = $histogram2[$utf8_pos][$c] + 1;
				_hx_array_increment($in_window_utf8,$utf8_pos);
				$utf8_pos = encode_Literal_cost::UTF8Position($last_c, $c, $max_utf8);
				$last_c = $c;
				unset($c);
			}
		}
		{
			$_g11 = 0;
			while($_g11 < $len) {
				$_g11 = $_g11 + 1;
				$i = $_g11 - 1;
				if($i - 495 >= 0) {
					$c1 = null;
					if($i - 495 - 1 < 0) {
						$c1 = 0;
					} else {
						$c1 = $data[$pos + $i - 495 - 1 & $mask];
					}
					$last_c1 = null;
					if($i - 495 - 2 < 0) {
						$last_c1 = 0;
					} else {
						$last_c1 = $data[$pos + $i - 495 - 2 & $mask];
					}
					$utf8_pos2 = encode_Literal_cost::UTF8Position($last_c1, $c1, $max_utf8);
					{
						$_g2 = $data[$pos + $i - 495 & $mask];
						$histogram2[$utf8_pos2][$_g2] = $histogram2[$utf8_pos2][$_g2] - 1;
						unset($_g2);
					}
					_hx_array_decrement($in_window_utf8,$utf8_pos2);
					unset($utf8_pos2,$last_c1,$c1);
				}
				if($i + 495 < $len) {
					$c2 = null;
					if($i + 495 - 1 < 0) {
						$c2 = 0;
					} else {
						$c2 = $data[$pos + $i + 495 - 1 & $mask];
					}
					$last_c2 = null;
					if($i + 495 - 2 < 0) {
						$last_c2 = 0;
					} else {
						$last_c2 = $data[$pos + $i + 495 - 2 & $mask];
					}
					$utf8_pos21 = encode_Literal_cost::UTF8Position($last_c2, $c2, $max_utf8);
					{
						$_g21 = $data[$pos + $i + 495 & $mask];
						$histogram2[$utf8_pos21][$_g21] = $histogram2[$utf8_pos21][$_g21] + 1;
						unset($_g21);
					}
					_hx_array_increment($in_window_utf8,$utf8_pos21);
					unset($utf8_pos21,$last_c2,$c2);
				}
				$c3 = null;
				if($i < 1) {
					$c3 = 0;
				} else {
					$c3 = $data[$pos + $i - 1 & $mask];
				}
				$last_c3 = null;
				if($i < 2) {
					$last_c3 = 0;
				} else {
					$last_c3 = $data[$pos + $i - 2 & $mask];
				}
				$utf8_pos1 = encode_Literal_cost::UTF8Position($last_c3, $c3, $max_utf8);
				$histo = $histogram2[$utf8_pos1][$data[$pos + $i & $mask]];
				if($histo === 0) {
					$histo = 1;
				}
				$lit_cost = encode_Fast_log::FastLog2($in_window_utf8[$utf8_pos1]);
				$lit_cost1 = $lit_cost - encode_Fast_log::FastLog2($histo);
				$lit_cost1 = $lit_cost1 + 0.02905;
				if($lit_cost1 < 1.0) {
					$lit_cost1 = $lit_cost1 * 0.5;
					$lit_cost1 = $lit_cost1 + 0.5;
				}
				if($i < 2000) {
					$lit_cost1 = $lit_cost1 + (0.7 - (2000 - $i) / 2000.0 * 0.35);
				}
				$cost[$pos + $i & $cost_mask] = $lit_cost1;
				unset($utf8_pos1,$lit_cost1,$lit_cost,$last_c3,$i,$histo,$c3);
			}
		}
	}
	static function EstimateBitCostsForLiterals($pos, $len, $mask, $cost_mask, $data, $cost) {
		$histogram = FunctionMalloc::mallocInt(256);
		$in_window = Std::int(Math::min(2000, $len));
		{
			$_g1 = 0;
			$_g = $in_window;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				{
					$_g2 = $data[$pos + ($_g1 - 1) & $mask];
					$histogram[$_g2] = $histogram[$_g2] + 1;
					unset($_g2);
				}
			}
		}
		{
			$_g11 = 0;
			while($_g11 < $len) {
				$_g11 = $_g11 + 1;
				$i = $_g11 - 1;
				if($i - 2000 >= 0) {
					{
						$_g21 = $data[$pos + $i - 2000 & $mask];
						$histogram[$_g21] = $histogram[$_g21] - 1;
						unset($_g21);
					}
					$in_window = $in_window - 1;
				}
				if($i + 2000 < $len) {
					{
						$_g22 = $data[$pos + $i + 2000 & $mask];
						$histogram[$_g22] = $histogram[$_g22] + 1;
						unset($_g22);
					}
					$in_window = $in_window + 1;
				}
				$histo = $histogram[$data[$pos + $i & $mask]];
				if($histo === 0) {
					$histo = 1;
				}
				$lit_cost = encode_Fast_log::FastLog2($in_window);
				$lit_cost1 = $lit_cost - encode_Fast_log::FastLog2($histo);
				$lit_cost1 = $lit_cost1 + 0.029;
				if($lit_cost1 < 1.0) {
					$lit_cost1 = $lit_cost1 * 0.5;
					$lit_cost1 = $lit_cost1 + 0.5;
				}
				$cost[$pos + $i & $cost_mask] = $lit_cost1;
				unset($lit_cost1,$lit_cost,$i,$histo);
			}
		}
	}
	function __toString() { return 'encode.Literal_cost'; }
}
