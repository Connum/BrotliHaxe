<?php

// Generated by Haxe 3.4.0
class encode_Backward_references {
	public function __construct() {}
	static $kInfinity;
	static function SetDistanceCache($distance, $distance_code, $max_distance, $dist_cache, $result_dist_cache, $result_dist_cache_off) {
		$tmp = null;
		if($distance <= $max_distance) {
			$tmp = $distance_code > 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$result_dist_cache[0] = $distance;
			DefaultFunctions::memcpy_Int($result_dist_cache, $result_dist_cache_off + 1, $dist_cache, 0, 3);
		} else {
			DefaultFunctions::memcpy_Int($result_dist_cache, $result_dist_cache_off, $dist_cache, 0, 4);
		}
	}
	static function ComputeDistanceCode($distance, $max_distance, $quality, $dist_cache) {
		if($distance <= $max_distance) {
			if($distance === $dist_cache[0]) {
				return 0;
			} else {
				if($distance === $dist_cache[1]) {
					return 1;
				} else {
					if($distance === $dist_cache[2]) {
						return 2;
					} else {
						if($distance === $dist_cache[3]) {
							return 3;
						} else {
							$tmp = null;
							if($quality > 3) {
								$tmp = $distance >= 6;
							} else {
								$tmp = false;
							}
							if($tmp) {
								$_g = 4;
								while($_g < 16) {
									$_g = $_g + 1;
									$k = $_g - 1;
									$tmp1 = null;
									if($distance === $dist_cache[encode_Hash::$kDistanceCacheIndex[$k]] + encode_Hash::$kDistanceCacheOffset[$k]) {
										$tmp1 = $distance >= _hx_array_get((new _hx_array(array(0, 0, 0, 0, 6, 6, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12))), $k);
									} else {
										$tmp1 = false;
									}
									if($tmp1) {
										return $k;
									}
									unset($tmp1,$k);
								}
							}
						}
					}
				}
			}
		}
		return $distance + 15;
	}
	static function UpdateZopfliNode($nodes, $nodes_off, $pos, $start_pos, $len, $len_code, $dist, $dist_code, $max_dist, $dist_cache, $cost) {
		$next = $nodes[$nodes_off + $pos + $len];
		$next->length = $len;
		$next->length_code = $len_code;
		$next->distance = $dist;
		$next->distance_code = $dist_code;
		$next->insert_length = $pos - $start_pos;
		$next->cost = $cost;
		encode_Backward_references::SetDistanceCache($dist, $dist_code, $max_dist, $dist_cache, $next->distance_cache, 0);
	}
	static function ComputeMinimumCopyLength($queue, $nodes, $model, $pos, $min_cost_cmd) {
		$start0 = $queue->GetStartPos(0);
		$min_cost = $nodes[$start0]->cost + $model->GetLiteralCosts($start0, $pos) + $min_cost_cmd;
		$len = 2;
		$next_len_bucket = 4;
		$next_len_offset = 10;
		while(true) {
			$tmp = null;
			if($pos + $len < $nodes->length) {
				$tmp = $nodes[$pos + $len]->cost <= $min_cost;
			} else {
				$tmp = false;
			}
			if(!$tmp) {
				break;
			}
			$len = $len + 1;
			if($len === $next_len_offset) {
				$min_cost = $min_cost + 1.0;
				$next_len_offset = $next_len_offset + $next_len_bucket;
				$next_len_bucket = $next_len_bucket * 2;
			}
			unset($tmp);
		}
		return $len;
	}
	static function ZopfliIterate($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $model, $num_matches, $matches, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals) {
		$orig_commands_off = $commands_off;
		$nodes = FunctionMalloc::malloc_encode_backward_references_ZopfliNode(_hx_qtype("encode.backward_references.ZopfliNode"), $num_bytes + 1);
		$nodes[0]->length = 0;
		$nodes[0]->cost = 0;
		DefaultFunctions::memcpy_Int($nodes[0]->distance_cache, 0, $dist_cache, 0, 4);
		$queue = new encode_backward_references_StartPosQueue(3);
		$min_cost_cmd = $model->GetMinCostCmd();
		$cur_match_pos = 0;
		$i = 0;
		while($i + 3 < $num_bytes) {
			$cur_ix = $position + $i;
			$cur_ix_masked = $cur_ix & $ringbuffer_mask;
			$max_distance = Std::int(Math::min($cur_ix, $max_backward_limit));
			$max_length = $num_bytes - $i;
			$queue->Push($i, $nodes[$i]->cost - $model->GetLiteralCosts(0, $i));
			$min_len = encode_Backward_references::ComputeMinimumCopyLength($queue, $nodes, $model, $i, $min_cost_cmd);
			$k = 0;
			while(true) {
				$tmp = null;
				if($k < 5) {
					$tmp = $k < $queue->size();
				} else {
					$tmp = false;
				}
				if(!$tmp) {
					break;
				}
				$start = $queue->GetStartPos($k);
				$start_costdiff = $nodes[$start]->cost - $model->GetLiteralCosts(0, $start);
				$dist_cache2 = $nodes[$start]->distance_cache;
				$best_len = $min_len - 1;
				{
					$_g = 0;
					while($_g < 16) {
						$_g = $_g + 1;
						$j = $_g - 1;
						$backward = $dist_cache2[encode_Hash::$kDistanceCacheIndex[$j]] + encode_Hash::$kDistanceCacheOffset[$j];
						$prev_ix = $cur_ix - $backward;
						if($prev_ix >= $cur_ix) {
							continue;
						}
						if($backward > $max_distance) {
							continue;
						}
						$prev_ix = $prev_ix & $ringbuffer_mask;
						$tmp1 = null;
						$tmp2 = null;
						if($cur_ix_masked + $best_len <= $ringbuffer_mask) {
							$tmp2 = $prev_ix + $best_len > $ringbuffer_mask;
						} else {
							$tmp2 = true;
						}
						if(!$tmp2) {
							$tmp1 = $ringbuffer[$cur_ix_masked + $best_len] !== $ringbuffer[$prev_ix + $best_len];
						} else {
							$tmp1 = true;
						}
						if($tmp1) {
							continue;
						}
						{
							$_g2 = $best_len + 1;
							$_g1 = encode_Find_match_length::FindMatchLengthWithLimit($ringbuffer, $prev_ix, $ringbuffer, $cur_ix_masked, $max_length) + 1;
							while($_g2 < $_g1) {
								$_g2 = $_g2 + 1;
								$l = $_g2 - 1;
								$cost = $start_costdiff + $model->GetCommandCost($j, $l, $i - $start);
								$cost1 = $cost + $model->GetLiteralCosts(0, $i);
								if($cost1 < $nodes[$i + $l]->cost) {
									encode_Backward_references::UpdateZopfliNode($nodes, 0, $i, $start, $l, $l, $backward, $j, $max_distance, $dist_cache2, $cost1);
								}
								$best_len = $l;
								unset($l,$cost1,$cost);
							}
							unset($_g2,$_g1);
						}
						unset($tmp2,$tmp1,$prev_ix,$j,$backward);
					}
					unset($_g);
				}
				if($k >= 2) {
					$k = $k + 1;
					continue;
				}
				$len = $min_len;
				{
					$_g11 = 0;
					$_g3 = $num_matches[$i];
					while($_g11 < $_g3) {
						$_g11 = $_g11 + 1;
						$match = $matches[$cur_match_pos + ($_g11 - 1)];
						$dist = $match->distance;
						$is_dictionary_match = $dist > $max_distance;
						$dist_code = $dist + 15;
						$max_len = $match->length();
						$tmp3 = null;
						if($len < $max_len) {
							if(!$is_dictionary_match) {
								$tmp3 = $max_len > 325;
							} else {
								$tmp3 = true;
							}
						} else {
							$tmp3 = false;
						}
						if($tmp3) {
							$len = $max_len;
						}
						while($len <= $max_len) {
							$len_code = null;
							if($is_dictionary_match) {
								$len_code = $match->length_code();
							} else {
								$len_code = $len;
							}
							$cost2 = $start_costdiff + $model->GetCommandCost($dist_code, $len_code, $i - $start);
							$cost3 = $cost2 + $model->GetLiteralCosts(0, $i);
							if($cost3 < $nodes[$i + $len]->cost) {
								encode_Backward_references::UpdateZopfliNode($nodes, 0, $i, $start, $len, $len_code, $dist, $dist_code, $max_distance, $dist_cache2, $cost3);
							}
							$len = $len + 1;
							unset($len_code,$cost3,$cost2);
						}
						unset($tmp3,$max_len,$match,$is_dictionary_match,$dist_code,$dist);
					}
					unset($_g3,$_g11);
				}
				$k = $k + 1;
				unset($tmp,$start_costdiff,$start,$len,$dist_cache2,$best_len);
			}
			$cur_match_pos = $cur_match_pos + $num_matches[$i];
			$tmp4 = null;
			if($num_matches[$i] === 1) {
				$tmp4 = _hx_array_get($matches, $cur_match_pos - 1)->length() > 325;
			} else {
				$tmp4 = false;
			}
			if($tmp4) {
				$i = $i + (_hx_array_get($matches, $cur_match_pos - 1)->length() - 1);
				$queue->Clear();
			}
			$i = $i + 1;
			unset($tmp4,$min_len,$max_length,$max_distance,$k,$cur_ix_masked,$cur_ix);
		}
		$backwards = new _hx_array(array());
		$index = $num_bytes;
		while(_hx_equal($nodes[$index]->cost, encode_Backward_references::$kInfinity)) {
			$index = $index - 1;
		}
		while($index > 0) {
			$len1 = $nodes[$index]->length + $nodes[$index]->insert_length;
			$backwards->push($len1);
			$index = $index - $len1;
			unset($len1);
		}
		$path = new _hx_array(array());
		$i1 = $backwards->length;
		while($i1 > 0) {
			$path->push($backwards[$i1 - 1]);
			$i1 = $i1 - 1;
		}
		$pos = 0;
		{
			$_g12 = 0;
			$_g4 = $path->length;
			while($_g12 < $_g4) {
				$_g12 = $_g12 + 1;
				$i2 = $_g12 - 1;
				$next = $nodes[$pos + $path[$i2]];
				$copy_length = $next->length;
				$insert_length = $next->insert_length;
				$pos = $pos + $insert_length;
				if($i2 === 0) {
					$insert_length = $insert_length + $last_insert_len[0];
				}
				$distance = $next->distance;
				$len_code1 = $next->length_code;
				$is_dictionary = $distance > Std::int(Math::min($position + $pos, $max_backward_limit));
				$dist_code1 = $next->distance_code;
				$command = new encode_command_Command();
				$command->Command4($insert_length, $copy_length, $len_code1, $dist_code1);
				$commands_off = $commands_off + 1;
				$commands[$commands_off - 1] = $command;
				$tmp5 = null;
				if(!$is_dictionary) {
					$tmp5 = $dist_code1 > 0;
				} else {
					$tmp5 = false;
				}
				if($tmp5) {
					$dist_cache[3] = $dist_cache[2];
					$dist_cache[2] = $dist_cache[1];
					$dist_cache[1] = $dist_cache[0];
					$dist_cache[0] = $distance;
				}
				$num_literals[0] = $num_literals->a[0] + $insert_length;
				$insert_length = 0;
				$pos = $pos + $copy_length;
				unset($tmp5,$next,$len_code1,$is_dictionary,$insert_length,$i2,$distance,$dist_code1,$copy_length,$command);
			}
		}
		$last_insert_len[0] = $num_bytes - $pos;
		$num_commands[0] = $num_commands->a[0] + ($commands_off - $orig_commands_off);
	}
	static function CreateBackwardReferences_HashLongestMatch($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hasher, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals) {
		$tmp = null;
		if($num_bytes >= 3) {
			$tmp = $position >= 3;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$hasher->Store($ringbuffer, $position - 3 & $ringbuffer_mask, $position - 3);
			$hasher->Store($ringbuffer, $position - 2 & $ringbuffer_mask, $position - 2);
			$hasher->Store($ringbuffer, $position - 1 & $ringbuffer_mask, $position - 1);
		}
		$orig_commands_off = $commands_off;
		$insert_length = $last_insert_len[0];
		$i = $position & $ringbuffer_mask;
		$i_diff = $position - $i;
		$i_end = $i + $num_bytes;
		$random_heuristics_window_size = null;
		if($quality < 9) {
			$random_heuristics_window_size = 64;
		} else {
			$random_heuristics_window_size = 512;
		}
		$apply_random_heuristics = $i + $random_heuristics_window_size;
		while($i + 3 < $i_end) {
			$max_length = $i_end - $i;
			$max_distance = Std::int(Math::min($i + $i_diff, $max_backward_limit));
			$best_len = (new _hx_array(array(0)));
			$best_len_code = (new _hx_array(array(0)));
			$best_dist = (new _hx_array(array(0)));
			$best_score = (new _hx_array(array(4.0)));
			$match_found = $hasher->FindLongestMatch($ringbuffer, $ringbuffer_mask, $dist_cache, $i + $i_diff, $max_length, $max_distance, $best_len, $best_len_code, $best_dist, $best_score);
			if($match_found) {
				$delayed_backward_references_in_row = 0;
				while(true) {
					$max_length = $max_length - 1;
					$best_len_2 = null;
					if($quality < 5) {
						$best_len_2 = Std::int(Math::min($best_len->a[0] - 1, $max_length));
					} else {
						$best_len_2 = 0;
					}
					$best_len_21 = (new _hx_array(array($best_len_2)));
					$best_len_code_2 = (new _hx_array(array(0)));
					$best_dist_2 = (new _hx_array(array(0)));
					$best_score_2 = (new _hx_array(array(4.0)));
					$max_distance = Std::int(Math::min($i + $i_diff + 1, $max_backward_limit));
					$hasher->Store($ringbuffer, $i, $i + $i_diff);
					$match_found = $hasher->FindLongestMatch($ringbuffer, $ringbuffer_mask, $dist_cache, $i + $i_diff + 1, $max_length, $max_distance, $best_len_21, $best_len_code_2, $best_dist_2, $best_score_2);
					$tmp1 = null;
					if($match_found) {
						$tmp1 = $best_score_2->a[0] >= $best_score->a[0] + 7.0;
					} else {
						$tmp1 = false;
					}
					if($tmp1) {
						$i = $i + 1;
						$insert_length = $insert_length + 1;
						$best_len[0] = $best_len_21[0];
						$best_len_code[0] = $best_len_code_2[0];
						$best_dist[0] = $best_dist_2[0];
						$best_score[0] = $best_score_2[0];
						$delayed_backward_references_in_row = $delayed_backward_references_in_row + 1;
						if($delayed_backward_references_in_row < 4) {
							continue;
						}
					}
					break;
					unset($tmp1,$best_score_2,$best_len_code_2,$best_len_21,$best_len_2,$best_dist_2);
				}
				$apply_random_heuristics = $i + 2 * $best_len[0] + $random_heuristics_window_size;
				$max_distance = Std::int(Math::min($i + $i_diff, $max_backward_limit));
				$distance_code = encode_Backward_references::ComputeDistanceCode($best_dist[0], $max_distance, $quality, $dist_cache);
				$tmp2 = null;
				if($best_dist->a[0] <= $max_distance) {
					$tmp2 = $distance_code > 0;
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$dist_cache[3] = $dist_cache[2];
					$dist_cache[2] = $dist_cache[1];
					$dist_cache[1] = $dist_cache[0];
					$dist_cache[0] = $best_dist[0];
				}
				$command = new encode_command_Command();
				$command->Command4($insert_length, $best_len[0], $best_len_code[0], $distance_code);
				$commands_off = $commands_off + 1;
				$commands[$commands_off - 1] = $command;
				$num_literals[0] = $num_literals->a[0] + $insert_length;
				$insert_length = 0;
				{
					$_g1 = 1;
					$_g = $best_len[0];
					while($_g1 < $_g) {
						$_g1 = $_g1 + 1;
						$j = $_g1 - 1;
						$hasher->Store($ringbuffer, $i + $j, $i + $i_diff + $j);
						unset($j);
					}
					unset($_g1,$_g);
				}
				$i = $i + $best_len[0];
				unset($tmp2,$distance_code,$delayed_backward_references_in_row,$command);
			} else {
				$insert_length = $insert_length + 1;
				$hasher->Store($ringbuffer, $i, $i + $i_diff);
				$i = $i + 1;
				if($i > $apply_random_heuristics) {
					if($i > $apply_random_heuristics + 4 * $random_heuristics_window_size) {
						$i_jump = Std::int(Math::min($i + 16, $i_end - 4));
						while($i < $i_jump) {
							$hasher->Store($ringbuffer, $i, $i + $i_diff);
							$insert_length = $insert_length + 4;
							$i = $i + 4;
						}
						unset($i_jump);
					} else {
						$i_jump1 = Std::int(Math::min($i + 8, $i_end - 3));
						while($i < $i_jump1) {
							$hasher->Store($ringbuffer, $i, $i + $i_diff);
							$insert_length = $insert_length + 2;
							$i = $i + 2;
						}
						unset($i_jump1);
					}
				}
			}
			unset($max_length,$max_distance,$match_found,$best_score,$best_len_code,$best_len,$best_dist);
		}
		$insert_length = $insert_length + ($i_end - $i);
		$last_insert_len[0] = $insert_length;
		$num_commands[0] = $num_commands->a[0] + ($commands_off - $orig_commands_off);
	}
	static function CreateBackwardReferences_HashLongestMatchQuickly($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hasher, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals) {
		$tmp = null;
		if($num_bytes >= 3) {
			$tmp = $position >= 3;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$hasher->Store($ringbuffer, $position - 3 & $ringbuffer_mask, $position - 3);
			$hasher->Store($ringbuffer, $position - 2 & $ringbuffer_mask, $position - 2);
			$hasher->Store($ringbuffer, $position - 1 & $ringbuffer_mask, $position - 1);
		}
		$orig_commands_off = $commands_off;
		$insert_length = $last_insert_len[0];
		$i = $position & $ringbuffer_mask;
		$i_diff = $position - $i;
		$i_end = $i + $num_bytes;
		$random_heuristics_window_size = null;
		if($quality < 9) {
			$random_heuristics_window_size = 64;
		} else {
			$random_heuristics_window_size = 512;
		}
		$apply_random_heuristics = $i + $random_heuristics_window_size;
		while($i + 3 < $i_end) {
			$max_length = $i_end - $i;
			$max_distance = Std::int(Math::min($i + $i_diff, $max_backward_limit));
			$best_len = (new _hx_array(array(0)));
			$best_len_code = (new _hx_array(array(0)));
			$best_dist = (new _hx_array(array(0)));
			$best_score = (new _hx_array(array(4.0)));
			$match_found = $hasher->FindLongestMatch($ringbuffer, $ringbuffer_mask, $dist_cache, $i + $i_diff, $max_length, $max_distance, $best_len, $best_len_code, $best_dist, $best_score);
			if($match_found) {
				$delayed_backward_references_in_row = 0;
				while(true) {
					$max_length = $max_length - 1;
					$best_len_2 = null;
					if($quality < 5) {
						$best_len_2 = Std::int(Math::min($best_len->a[0] - 1, $max_length));
					} else {
						$best_len_2 = 0;
					}
					$best_len_21 = (new _hx_array(array($best_len_2)));
					$best_len_code_2 = (new _hx_array(array(0)));
					$best_dist_2 = (new _hx_array(array(0)));
					$best_score_2 = (new _hx_array(array(4.0)));
					$max_distance = Std::int(Math::min($i + $i_diff + 1, $max_backward_limit));
					$hasher->Store($ringbuffer, $i, $i + $i_diff);
					$match_found = $hasher->FindLongestMatch($ringbuffer, $ringbuffer_mask, $dist_cache, $i + $i_diff + 1, $max_length, $max_distance, $best_len_21, $best_len_code_2, $best_dist_2, $best_score_2);
					$tmp1 = null;
					if($match_found) {
						$tmp1 = $best_score_2->a[0] >= $best_score->a[0] + 7.0;
					} else {
						$tmp1 = false;
					}
					if($tmp1) {
						$i = $i + 1;
						$insert_length = $insert_length + 1;
						$best_len[0] = $best_len_21[0];
						$best_len_code[0] = $best_len_code_2[0];
						$best_dist[0] = $best_dist_2[0];
						$best_score[0] = $best_score_2[0];
						$delayed_backward_references_in_row = $delayed_backward_references_in_row + 1;
						if($delayed_backward_references_in_row < 4) {
							continue;
						}
					}
					break;
					unset($tmp1,$best_score_2,$best_len_code_2,$best_len_21,$best_len_2,$best_dist_2);
				}
				$apply_random_heuristics = $i + 2 * $best_len[0] + $random_heuristics_window_size;
				$max_distance = Std::int(Math::min($i + $i_diff, $max_backward_limit));
				$distance_code = encode_Backward_references::ComputeDistanceCode($best_dist[0], $max_distance, $quality, $dist_cache);
				$tmp2 = null;
				if($best_dist->a[0] <= $max_distance) {
					$tmp2 = $distance_code > 0;
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$dist_cache[3] = $dist_cache[2];
					$dist_cache[2] = $dist_cache[1];
					$dist_cache[1] = $dist_cache[0];
					$dist_cache[0] = $best_dist[0];
				}
				$command = new encode_command_Command();
				$command->Command4($insert_length, $best_len[0], $best_len_code[0], $distance_code);
				$commands_off = $commands_off + 1;
				$commands[$commands_off - 1] = $command;
				$num_literals[0] = $num_literals->a[0] + $insert_length;
				$insert_length = 0;
				{
					$_g1 = 1;
					$_g = $best_len[0];
					while($_g1 < $_g) {
						$_g1 = $_g1 + 1;
						$j = $_g1 - 1;
						$hasher->Store($ringbuffer, $i + $j, $i + $i_diff + $j);
						unset($j);
					}
					unset($_g1,$_g);
				}
				$i = $i + $best_len[0];
				unset($tmp2,$distance_code,$delayed_backward_references_in_row,$command);
			} else {
				$insert_length = $insert_length + 1;
				$hasher->Store($ringbuffer, $i, $i + $i_diff);
				$i = $i + 1;
				if($i > $apply_random_heuristics) {
					if($i > $apply_random_heuristics + 4 * $random_heuristics_window_size) {
						$i_jump = Std::int(Math::min($i + 16, $i_end - 4));
						while($i < $i_jump) {
							$hasher->Store($ringbuffer, $i, $i + $i_diff);
							$insert_length = $insert_length + 4;
							$i = $i + 4;
						}
						unset($i_jump);
					} else {
						$i_jump1 = Std::int(Math::min($i + 8, $i_end - 3));
						while($i < $i_jump1) {
							$hasher->Store($ringbuffer, $i, $i + $i_diff);
							$insert_length = $insert_length + 2;
							$i = $i + 2;
						}
						unset($i_jump1);
					}
				}
			}
			unset($max_length,$max_distance,$match_found,$best_score,$best_len_code,$best_len,$best_dist);
		}
		$insert_length = $insert_length + ($i_end - $i);
		$last_insert_len[0] = $insert_length;
		$num_commands[0] = $num_commands->a[0] + ($commands_off - $orig_commands_off);
	}
	static function CreateBackwardReferences($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $literal_cost, $literal_cost_mask, $max_backward_limit, $quality, $hashers, $hash_type, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals) {
		if($quality > 9) {
			$hasher = $hashers->hash_h9;
			$tmp = null;
			if($num_bytes >= 3) {
				$tmp = $position >= 3;
			} else {
				$tmp = false;
			}
			if($tmp) {
				$hasher->Store($ringbuffer, $position - 3 & $ringbuffer_mask, $position - 3);
				$hasher->Store($ringbuffer, $position - 2 & $ringbuffer_mask, $position - 2);
				$hasher->Store($ringbuffer, $position - 1 & $ringbuffer_mask, $position - 1);
			}
			$num_matches = FunctionMalloc::mallocInt($num_bytes);
			$matches = FunctionMalloc::mallocArray_encode_hash_BackwardMatch(_hx_qtype("encode.hash.BackwardMatch"), 3 * $num_bytes);
			$cur_match_pos = 0;
			$i = 0;
			while($i + 3 < $num_bytes) {
				$max_distance = Std::int(Math::min($position + $i, $max_backward_limit));
				if($matches->length < $cur_match_pos + 325) {
					$matches->concat(FunctionMalloc::mallocArray_encode_hash_BackwardMatch(_hx_qtype("encode.hash.BackwardMatch"), $cur_match_pos + 325 - $matches->length));
				}
				$hasher->FindAllMatches($ringbuffer, $ringbuffer_mask, $position + $i, $num_bytes - $i, $max_distance, $num_matches, $i, $matches, $cur_match_pos);
				$hasher->Store($ringbuffer, $position + $i & $ringbuffer_mask, $position + $i);
				$cur_match_pos = $cur_match_pos + $num_matches[$i];
				if($num_matches[$i] === 1) {
					$match_len = _hx_array_get($matches, $cur_match_pos - 1)->length();
					if($match_len > 325) {
						$_g1 = 1;
						while($_g1 < $match_len) {
							$_g1 = $_g1 + 1;
							$i = $i + 1;
							$hasher->Store($ringbuffer, $position + $i & $ringbuffer_mask, $position + $i);
							$num_matches[$i] = 0;
						}
						unset($_g1);
					}
					unset($match_len);
				}
				$i = $i + 1;
				unset($max_distance);
			}
			$orig_num_literals = $num_literals[0];
			$orig_last_insert_len = $last_insert_len[0];
			$this1 = (new _hx_array(array()));
			$this1->length = 4;
			$orig_dist_cache = $this1;
			$orig_dist_cache[0] = $dist_cache[0];
			$orig_dist_cache[1] = $dist_cache[1];
			$orig_dist_cache[2] = $dist_cache[2];
			$orig_dist_cache[3] = $dist_cache[3];
			$orig_num_commands = $num_commands[0];
			{
				$_g11 = 0;
				while($_g11 < 2) {
					$_g11 = $_g11 + 1;
					$model = new encode_backward_references_ZopfliCostModel();
					if($_g11 - 1 === 0) {
						$model->SetFromLiteralCosts($num_bytes, $position, $literal_cost, $literal_cost_mask);
					} else {
						$model->SetFromCommands($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $commands, $commands_off + $num_commands[0] - $orig_num_commands, $orig_last_insert_len);
					}
					$num_commands[0] = $orig_num_commands;
					$num_literals[0] = $orig_num_literals;
					$last_insert_len[0] = $orig_last_insert_len;
					DefaultFunctions::memcpy_Int($dist_cache, 0, $orig_dist_cache, 0, 4);
					encode_Backward_references::ZopfliIterate($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $model, $num_matches, $matches, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
					unset($model);
				}
			}
			return;
		}
		switch($hash_type) {
		case 1:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatchQuickly($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h1, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		case 2:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatchQuickly($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h2, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		case 3:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatchQuickly($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h3, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		case 4:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatchQuickly($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h4, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		case 5:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatch($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h5, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		case 6:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatch($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h6, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		case 7:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatch($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h7, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		case 8:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatch($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h8, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		case 9:{
			encode_Backward_references::CreateBackwardReferences_HashLongestMatch($num_bytes, $position, $ringbuffer, $ringbuffer_mask, $max_backward_limit, $quality, $hashers->hash_h9, $dist_cache, $last_insert_len, $commands, $commands_off, $num_commands, $num_literals);
		}break;
		default:{}break;
		}
	}
	function __toString() { return 'encode.Backward_references'; }
}
encode_Backward_references::$kInfinity = Math::$POSITIVE_INFINITY;
