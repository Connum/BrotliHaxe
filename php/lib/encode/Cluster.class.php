<?php

// Generated by Haxe 3.4.0
class encode_Cluster {
	public function __construct() {}
	static function HistogramPairComparator($p1, $p2) {
		if(!_hx_equal($p1->cost_diff, $p2->cost_diff)) {
			if($p1->cost_diff > $p2->cost_diff) {
				return 1;
			} else {
				return -1;
			}
		}
		$tmp = Math::abs($p1->idx1 - $p1->idx2);
		if($tmp > Math::abs($p2->idx1 - $p2->idx2)) {
			return 1;
		} else {
			return -1;
		}
	}
	static function ClusterCostDiff($size_a, $size_b) {
		$size_c = $size_a + $size_b;
		$tmp = $size_a * encode_Fast_log::FastLog2($size_a);
		$tmp1 = $tmp + $size_b * encode_Fast_log::FastLog2($size_b);
		return $tmp1 - $size_c * encode_Fast_log::FastLog2($size_c);
	}
	static function CompareAndPushToHeap($out, $cluster_size, $idx1, $idx2, $pairs) {
		if($idx1 === $idx2) {
			return;
		}
		if($idx2 < $idx1) {
			$t = $idx2;
			$idx2 = $idx1;
			$idx1 = $t;
		}
		$store_pair = false;
		$p = new encode_cluster_HistogramPair();
		$p->idx1 = $idx1;
		$p->idx2 = $idx2;
		$p->valid = true;
		$p->cost_diff = 0.5 * encode_Cluster::ClusterCostDiff($cluster_size[$idx1], $cluster_size[$idx2]);
		$p->cost_diff = $p->cost_diff - _hx_array_get($out, $idx1)->bit_cost_;
		$p->cost_diff = $p->cost_diff - _hx_array_get($out, $idx2)->bit_cost_;
		if(_hx_array_get($out, $idx1)->total_count_ === 0) {
			$p->cost_combo = _hx_array_get($out, $idx2)->bit_cost_;
			$store_pair = true;
		} else {
			if(_hx_array_get($out, $idx2)->total_count_ === 0) {
				$p->cost_combo = _hx_array_get($out, $idx1)->bit_cost_;
				$store_pair = true;
			} else {
				$threshold = null;
				if($pairs->size() === 0) {
					$threshold = 1e99;
				} else {
					$threshold = Math::max(0.0, _hx_array_get($pairs->arr, 0)->cost_diff);
				}
				$combo = new encode_histogram_Histogram(_hx_array_get($out, $idx1)->data_->length);
				$combo->bit_cost_ = _hx_array_get($out, $idx1)->bit_cost_;
				{
					$_g1 = 0;
					$_g = _hx_array_get($out, $idx1)->data_->length;
					while($_g1 < $_g) {
						$_g1 = $_g1 + 1;
						$a = $_g1 - 1;
						$combo->data_[$a] = _hx_array_get($out, $idx1)->data_[$a];
						unset($a);
					}
				}
				$combo->kDataSize = _hx_array_get($out, $idx1)->kDataSize;
				$combo->total_count_ = _hx_array_get($out, $idx1)->total_count_;
				$combo->AddHistogram($out[$idx2]);
				$cost_combo = encode_Bit_cost::PopulationCost($combo);
				if($cost_combo < $threshold - $p->cost_diff) {
					$p->cost_combo = $cost_combo;
					$store_pair = true;
				}
			}
		}
		if($store_pair) {
			$p->cost_diff = $p->cost_diff + $p->cost_combo;
			$pairs->push($p);
		}
	}
	static function HistogramCombine($out, $cluster_size, $symbols, $symbols_off, $symbols_size, $max_clusters) {
		$cost_diff_threshold = 0.0;
		$min_cluster_size = 1;
		$all_symbols = new _hx_array(array());
		$clusters = new _hx_array(array());
		{
			$_g1 = 0;
			while($_g1 < $symbols_size) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				if($all_symbols->indexOf($symbols[$symbols_off + $i], null) === -1) {
					if($all_symbols->indexOf($symbols[$symbols_off + $i], null) === -1) {
						$all_symbols->push($symbols[$symbols_off + $i]);
					}
					$clusters->push($symbols[$symbols_off + $i]);
				}
				unset($i);
			}
		}
		$pairs = new encode_BinaryHeap();
		{
			$_g11 = 0;
			$_g = $clusters->length;
			while($_g11 < $_g) {
				$_g11 = $_g11 + 1;
				$idx1 = $_g11 - 1;
				{
					$_g3 = $idx1 + 1;
					$_g2 = $clusters->length;
					while($_g3 < $_g2) {
						$_g3 = $_g3 + 1;
						encode_Cluster::CompareAndPushToHeap($out, $cluster_size, $clusters[$idx1], $clusters[$_g3 - 1], $pairs);
					}
					unset($_g3,$_g2);
				}
				unset($idx1);
			}
		}
		while($clusters->length > $min_cluster_size) {
			if(_hx_array_get($pairs->arr, 0)->cost_diff >= $cost_diff_threshold) {
				$cost_diff_threshold = 1e99;
				$min_cluster_size = $max_clusters;
				continue;
			}
			$best_idx1 = _hx_array_get($pairs->arr, 0)->idx1;
			$best_idx2 = _hx_array_get($pairs->arr, 0)->idx2;
			_hx_array_get($out, $best_idx1)->AddHistogram($out[$best_idx2]);
			_hx_array_get($out, $best_idx1)->bit_cost_ = _hx_array_get($pairs->arr, 0)->cost_combo;
			$cluster_size[$best_idx1] = $cluster_size[$best_idx1] + $cluster_size[$best_idx2];
			{
				$_g12 = 0;
				while($_g12 < $symbols_size) {
					$_g12 = $_g12 + 1;
					$i1 = $_g12 - 1;
					if($symbols[$symbols_off + $i1] === $best_idx2) {
						$symbols[$symbols_off + $i1] = $best_idx1;
					}
					unset($i1);
				}
				unset($_g12);
			}
			{
				$_g13 = 0;
				$_g4 = $clusters->length;
				while($_g13 < $_g4) {
					$_g13 = $_g13 + 1;
					$i2 = $_g13 - 1;
					if($clusters->a[$i2] >= $best_idx2) {
						$clusters[$i2] = $clusters[$i2 + 1];
					}
					unset($i2);
				}
				unset($_g4,$_g13);
			}
			$clusters->pop();
			{
				$_g14 = 0;
				$_g5 = $pairs->size();
				while($_g14 < $_g5) {
					$_g14 = $_g14 + 1;
					$p = $pairs->arr[$_g14 - 1];
					$tmp = null;
					$tmp1 = null;
					$tmp2 = null;
					if($p->idx1 !== $best_idx1) {
						$tmp2 = $p->idx2 === $best_idx1;
					} else {
						$tmp2 = true;
					}
					if(!$tmp2) {
						$tmp1 = $p->idx1 === $best_idx2;
					} else {
						$tmp1 = true;
					}
					if(!$tmp1) {
						$tmp = $p->idx2 === $best_idx2;
					} else {
						$tmp = true;
					}
					if($tmp) {
						$p->valid = false;
					}
					unset($tmp2,$tmp1,$tmp,$p);
				}
				unset($_g5,$_g14);
			}
			while(true) {
				$tmp3 = null;
				if($pairs->size() !== 0) {
					$tmp3 = !_hx_array_get($pairs->arr, 0)->valid;
				} else {
					$tmp3 = false;
				}
				if(!$tmp3) {
					break;
				}
				$pairs->pop();
				unset($tmp3);
			}
			{
				$_g15 = 0;
				$_g6 = $clusters->length;
				while($_g15 < $_g6) {
					$_g15 = $_g15 + 1;
					encode_Cluster::CompareAndPushToHeap($out, $cluster_size, $best_idx1, $clusters[$_g15 - 1], $pairs);
				}
				unset($_g6,$_g15);
			}
			unset($best_idx2,$best_idx1);
		}
	}
	static function HistogramBitCostDistance($histogram, $candidate) {
		if($histogram->total_count_ === 0) {
			return 0.0;
		}
		$tmp = new encode_histogram_Histogram($histogram->data_->length);
		$tmp->bit_cost_ = $histogram->bit_cost_;
		{
			$_g1 = 0;
			$_g = $histogram->data_->length;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$a = $_g1 - 1;
				$tmp->data_[$a] = $histogram->data_[$a];
				unset($a);
			}
		}
		$tmp->kDataSize = $histogram->kDataSize;
		$tmp->total_count_ = $histogram->total_count_;
		$tmp->AddHistogram($candidate);
		$tmp1 = encode_Bit_cost::PopulationCost($tmp);
		return $tmp1 - $candidate->bit_cost_;
	}
	static function HistogramRemap($input, $in_size, $output, $symbols) {
		$all_symbols = new _hx_array(array());
		{
			$_g1 = 0;
			while($_g1 < $in_size) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				if($all_symbols->indexOf($symbols[$i], null) === -1) {
					$all_symbols->push($symbols[$i]);
				}
				unset($i);
			}
		}
		{
			$_g11 = 0;
			while($_g11 < $in_size) {
				$_g11 = $_g11 + 1;
				$i1 = $_g11 - 1;
				$best_out = null;
				if($i1 === 0) {
					$best_out = $symbols[0];
				} else {
					$best_out = $symbols[$i1 - 1];
				}
				$best_bits = encode_Cluster::HistogramBitCostDistance($input[$i1], $output[$best_out]);
				{
					$_g3 = 0;
					$_g2 = $all_symbols->length;
					while($_g3 < $_g2) {
						$_g3 = $_g3 + 1;
						$k = $_g3 - 1;
						$cur_bits = encode_Cluster::HistogramBitCostDistance($input[$i1], $output[$all_symbols[$k]]);
						if($cur_bits < $best_bits) {
							$best_bits = $cur_bits;
							$best_out = $all_symbols[$k];
						}
						unset($k,$cur_bits);
					}
					unset($_g3,$_g2);
				}
				$symbols[$i1] = $best_out;
				unset($i1,$best_out,$best_bits);
			}
		}
		{
			$_g12 = 0;
			$_g = $all_symbols->length;
			while($_g12 < $_g) {
				$_g12 = $_g12 + 1;
				_hx_array_get($output, $all_symbols[$_g12 - 1])->Clear();
			}
		}
		{
			$_g13 = 0;
			while($_g13 < $in_size) {
				$_g13 = $_g13 + 1;
				$i2 = $_g13 - 1;
				_hx_array_get($output, $symbols[$i2])->AddHistogram($input[$i2]);
				unset($i2);
			}
		}
	}
	static function HistogramReindex($out, $symbols) {
		$tmp = new _hx_array(array());
		{
			$_g1 = 0;
			$_g = $out->length;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$tmp[$i] = new encode_histogram_Histogram(_hx_array_get($out, $i)->data_->length);
				_hx_array_get($tmp, $i)->bit_cost_ = _hx_array_get($out, $i)->bit_cost_;
				{
					$_g3 = 0;
					$_g2 = _hx_array_get($out, $i)->data_->length;
					while($_g3 < $_g2) {
						$_g3 = $_g3 + 1;
						$a = $_g3 - 1;
						_hx_array_get($tmp, $i)->data_[$a] = _hx_array_get($out, $i)->data_[$a];
						unset($a);
					}
					unset($_g3,$_g2);
				}
				_hx_array_get($tmp, $i)->kDataSize = _hx_array_get($out, $i)->kDataSize;
				_hx_array_get($tmp, $i)->total_count_ = _hx_array_get($out, $i)->total_count_;
				unset($i);
			}
		}
		$new_index = new haxe_ds_IntMap();
		$next_index = 0;
		{
			$_g11 = 0;
			$_g4 = $symbols->length;
			while($_g11 < $_g4) {
				$_g11 = $_g11 + 1;
				$i1 = $_g11 - 1;
				if($new_index->exists($symbols[$i1]) === false) {
					$new_index->set($symbols[$i1], $next_index);
					_hx_array_get($out, $next_index)->bit_cost_ = _hx_array_get($tmp, $symbols[$i1])->bit_cost_;
					{
						$_g31 = 0;
						$_g21 = _hx_array_get($tmp, $symbols[$i1])->data_->length;
						while($_g31 < $_g21) {
							$_g31 = $_g31 + 1;
							$a1 = $_g31 - 1;
							_hx_array_get($out, $next_index)->data_[$a1] = _hx_array_get($tmp, $symbols[$i1])->data_[$a1];
							unset($a1);
						}
						unset($_g31,$_g21);
					}
					_hx_array_get($out, $next_index)->kDataSize = _hx_array_get($tmp, $symbols[$i1])->kDataSize;
					_hx_array_get($out, $next_index)->total_count_ = _hx_array_get($tmp, $symbols[$i1])->total_count_;
					$next_index = $next_index + 1;
				}
				unset($i1);
			}
		}
		while($out->length > $next_index) {
			$out->pop();
		}
		{
			$_g12 = 0;
			$_g5 = $symbols->length;
			while($_g12 < $_g5) {
				$_g12 = $_g12 + 1;
				$i2 = $_g12 - 1;
				$symbols[$i2] = $new_index->get($symbols[$i2]);
				unset($i2);
			}
		}
	}
	static function ClusterHistograms($input, $num_contexts, $num_blocks, $max_histograms, $output, $outputInt, $histogram_symbols) {
		$in_size = $num_contexts * $num_blocks;
		$this1 = (new _hx_array(array()));
		$this1->length = $in_size;
		$cluster_size = $this1;
		DefaultFunctions::memset_Int($cluster_size, 0, 1, $in_size);
		while($output->length > $in_size) {
			$output->pop();
		}
		{
			$_g1 = 0;
			while($_g1 < $in_size) {
				$_g1 = $_g1 + 1;
				$output[$_g1 - 1] = new encode_histogram_Histogram($outputInt);
			}
		}
		{
			$_g11 = 0;
			while($_g11 < $in_size) {
				$_g11 = $_g11 + 1;
				$i = $_g11 - 1;
				{
					$_g3 = 0;
					$_g2 = _hx_array_get($input, $i)->data_->length;
					while($_g3 < $_g2) {
						$_g3 = $_g3 + 1;
						$a = $_g3 - 1;
						_hx_array_get($output, $i)->data_[$a] = _hx_array_get($input, $i)->data_[$a];
						unset($a);
					}
					unset($_g3,$_g2);
				}
				_hx_array_get($output, $i)->kDataSize = _hx_array_get($input, $i)->kDataSize;
				_hx_array_get($output, $i)->total_count_ = _hx_array_get($input, $i)->total_count_;
				_hx_array_get($output, $i)->bit_cost_ = encode_Bit_cost::PopulationCost($input[$i]);
				$histogram_symbols[$i] = $i;
				unset($i);
			}
		}
		$i1 = 0;
		while($i1 < $in_size) {
			encode_Cluster::HistogramCombine($output, $cluster_size, $histogram_symbols, $i1, Std::int(Math::min($in_size - $i1, 64)), $max_histograms);
			$i1 = $i1 + 64;
		}
		encode_Cluster::HistogramCombine($output, $cluster_size, $histogram_symbols, 0, $in_size, $max_histograms);
		encode_Cluster::HistogramRemap($input, $in_size, $output, $histogram_symbols);
		encode_Cluster::HistogramReindex($output, $histogram_symbols);
	}
	function __toString() { return 'encode.Cluster'; }
}
