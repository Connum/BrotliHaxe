<?php

// Generated by Haxe 3.4.0
class encode_RingBuffer {
	public function __construct($window_bits, $tail_bits) {
		if(!php_Boot::$skip_constructor) {
		$this->window_bits_ = $window_bits;
		$this->mask_ = (1 << $window_bits) - 1;
		$this->tail_size_ = 1 << $tail_bits;
		$this->pos_ = 0;
		$buflen = (1 << $this->window_bits_) + $this->tail_size_;
		$this1 = (new _hx_array(array()));
		$this1->length = $buflen + 3;
		$this->buffer_ = $this1;
		{
			$_g1 = 0;
			while($_g1 < 3) {
				$_g1 = $_g1 + 1;
				$this->buffer_[$buflen + ($_g1 - 1)] = 0;
			}
		}
	}}
	public function WriteTail($bytes, $n) {
		$masked_pos = $this->pos_ & $this->mask_;
		if($masked_pos < $this->tail_size_) {
			$p = (1 << $this->window_bits_) + $masked_pos;
			$tmp = $this->buffer_;
			DefaultFunctions::memcpy_UInt($tmp, $p, $bytes, 0, Std::int(Math::min($n, $this->tail_size_ - $masked_pos)));
		}
	}
	public $window_bits_;
	public $mask_;
	public $tail_size_;
	public $pos_;
	public $buffer_;
	public $buffer_off;
	public function Write($bytes, $n) {
		$masked_pos = $this->pos_ & $this->mask_;
		$this->WriteTail($bytes, $n);
		if($masked_pos + $n <= 1 << $this->window_bits_) {
			DefaultFunctions::memcpy_UInt($this->buffer_, $masked_pos, $bytes, 0, $n);
		} else {
			$tmp = $this->buffer_;
			DefaultFunctions::memcpy_UInt($tmp, $masked_pos, $bytes, 0, Std::int(Math::min($n, (1 << $this->window_bits_) + $this->tail_size_ - $masked_pos)));
			DefaultFunctions::memcpy_UInt($this->buffer_, 0, $bytes, (1 << $this->window_bits_) - $masked_pos, $n - ((1 << $this->window_bits_) - $masked_pos));
		}
		$tmp1 = $this;
		$tmp1->pos_ = $tmp1->pos_ + $n;
	}
	public function position() {
		return $this->pos_;
	}
	public function mask() {
		return $this->mask_;
	}
	public function start() {
		return $this->buffer_;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'encode.RingBuffer'; }
}
