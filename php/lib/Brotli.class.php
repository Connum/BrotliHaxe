<?php

// Generated by Haxe 3.4.0
class Brotli {
	public function __construct($dictionary_path = null) { if(!php_Boot::$skip_constructor) {
		if($dictionary_path === null) {
			$dictionary_path = "dictionary.txt";
		}
		$dictionary = Brotli::OpenInputBinary($dictionary_path);
		$DictionaryHash = Brotli::OpenInputBinary("DictionaryHash.txt");
		$DictionaryWords = Brotli::OpenInputBinary("DictionaryWords.txt");
		$DictionaryBuckets = Brotli::OpenInputBinary("DictionaryBuckets.txt");
		decode_Dictionary::$kBrotliDictionary = $dictionary;
		encode_Dictionary::$kBrotliDictionary = $dictionary;
		$kStaticDictionaryHash = encode_Dictionary_hash::$kStaticDictionaryHash;
		$kStaticDictionaryBuckets = encode_Static_dict_lut::$kStaticDictionaryBuckets;
		{
			$_g = 0;
			while($_g < 32768) {
				$_g = $_g + 1;
				$i = $_g - 1;
				$kStaticDictionaryHash->push($DictionaryHash[$i * 2 + 1] << 8 | $DictionaryHash[$i * 2]);
				$kStaticDictionaryBuckets->push($DictionaryBuckets[$i * 3 + 2] << 16 | $DictionaryBuckets[$i * 3 + 1] << 8 | $DictionaryBuckets[$i * 3]);
				unset($i);
			}
		}
		$kStaticDictionaryWords = encode_Static_dict_lut::$kStaticDictionaryWords;
		{
			$_g1 = 0;
			while($_g1 < 31704) {
				$_g1 = $_g1 + 1;
				$i1 = $_g1 - 1;
				$kStaticDictionaryWords->push(new encode_static_dict_lut_DictWord(_hx_shift_right($DictionaryWords[$i1 * 3 + 1], 3), $DictionaryWords[$i1 * 3 + 2], ($DictionaryWords[$i1 * 3 + 1] & 7) << 8 | $DictionaryWords[$i1 * 3]));
				unset($i1);
			}
		}
	}}
	public function decompress($content) {
		$fin = new _hx_array(array());
		{
			$_g1 = 0;
			$_g = _hx_len($content);
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$fin[$i] = _hx_string_call($content, "charCodeAt", array($i));
				unset($i);
			}
		}
		$fout = new _hx_array(array());
		$input = decode_Streams::BrotliInitMemInput($fin, $fin->length);
		$output = decode_Streams::BrotliInitMemOutput($fout);
		decode_Decode::BrotliDecompress($input, $output);
		$bytes = haxe_io_Bytes::alloc($output->data_->pos);
		{
			$_g11 = 0;
			$_g2 = $output->data_->pos;
			while($_g11 < $_g2) {
				$_g11 = $_g11 + 1;
				$i1 = $_g11 - 1;
				{
					$v = $output->data_->buffer[$i1];
					{
						$this1 = $bytes->b;
						$this1->s[$i1] = chr($v);
						unset($this1);
					}
					unset($v);
				}
				unset($i1);
			}
		}
		return $bytes->getString(0, $output->data_->pos);
	}
	public function compress($content, $quality) {
		$tmp = null;
		if($quality >= 0) {
			$tmp = $quality > 11;
		} else {
			$tmp = true;
		}
		if($tmp) {
			haxe_Log::trace("Quality 0...11", _hx_anonymous(array("fileName" => "Brotli.hx", "lineNumber" => 243, "className" => "Brotli", "methodName" => "compress")));
			return null;
		}
		$fin = new _hx_array(array());
		{
			$_g1 = 0;
			$_g = _hx_len($content);
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$fin[$i] = _hx_string_call($content, "charCodeAt", array($i));
				unset($i);
			}
		}
		$fout = new _hx_array(array());
		$params = new encode_encode_BrotliParams();
		$params->quality = $quality;
		$input = new encode_streams_BrotliMemIn($fin, $fin->length);
		$output = new encode_streams_BrotliMemOut($fout);
		encode_Encode::BrotliCompress($params, $input, $output);
		$bytes = haxe_io_Bytes::alloc($output->position());
		{
			$_g11 = 0;
			$_g2 = $output->position();
			while($_g11 < $_g2) {
				$_g11 = $_g11 + 1;
				$i1 = $_g11 - 1;
				{
					$v = $output->buf_[$i1];
					{
						$this1 = $bytes->b;
						$this1->s[$i1] = chr($v);
						unset($this1);
					}
					unset($v);
				}
				unset($i1);
			}
		}
		return $bytes->getString(0, $output->position());
	}
	public function decompressArray($content) {
		$fin = $content;
		$fout = new _hx_array(array());
		$input = decode_Streams::BrotliInitMemInput($fin, $fin->length);
		$output = decode_Streams::BrotliInitMemOutput($fout);
		decode_Decode::BrotliDecompress($input, $output);
		return $output->data_->buffer->slice(0, $output->data_->pos);
	}
	public function compressArray($content, $quality) {
		$tmp = null;
		if($quality >= 0) {
			$tmp = $quality > 11;
		} else {
			$tmp = true;
		}
		if($tmp) {
			haxe_Log::trace("Quality 0...11", _hx_anonymous(array("fileName" => "Brotli.hx", "lineNumber" => 268, "className" => "Brotli", "methodName" => "compressArray")));
			return null;
		}
		$fin = $content;
		$fout = new _hx_array(array());
		$params = new encode_encode_BrotliParams();
		$params->quality = $quality;
		$input = new encode_streams_BrotliMemIn($fin, $fin->length);
		$output = new encode_streams_BrotliMemOut($fout);
		encode_Encode::BrotliCompress($params, $input, $output);
		$bytes = haxe_io_Bytes::alloc($output->position());
		{
			$_g1 = 0;
			$_g = $output->position();
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				{
					$v = $output->buf_[$i];
					{
						$this1 = $bytes->b;
						$this1->s[$i] = chr($v);
						unset($this1);
					}
					unset($v);
				}
				unset($i);
			}
		}
		return $output->buf_->slice(0, $output->position());
	}
	static function OpenInputFile($input_path) {
		return sys_io_File::read($input_path, true);
	}
	static function OpenOutputFile($output_path, $force) {
		return sys_io_File::write($output_path, true);
	}
	static function OpenInputBinary($input_path) {
		$input = sys_io_File::read($input_path, true);
		$bytes = $input->readAll(null);
		$this1 = (new _hx_array(array()));
		$this1->length = $bytes->length;
		$content = $this1;
		{
			$_g1 = 0;
			$_g = $bytes->length;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				{
					$this2 = $bytes->b;
					$content[$i] = ord($this2->s[$i]);
					unset($this2);
				}
				unset($i);
			}
		}
		return $content;
	}
	function __toString() { return 'Brotli'; }
}
